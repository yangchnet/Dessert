---
author: "李昌"
title: "概览容器篇一：镜像"
date: "2022-07-10"
tags: ["docker"]
categories: ["cloud"]
ShowToc: true
TocOpen: true
---

## 1. 分层的镜像

在我们启动一个容器之前，通畅需要下载这个容器对应的镜像，以这个镜像为基础启动容器。镜像提供了容器中程序执行需要的所有文件。这样，我们就可以为容器中的进程提供一个干净的文件系统。

创建一个镜像（`image`）的最简单方法是使用Dockerfile。

```dockerfile
FROM scratch
COPY hello /
CMD ["/hello"]
```

`scratch`是docker为我们提供的一个空镜像，我们可以在此基础上构建任何我们想要的镜像。

在书写`Dockerfile`时，想必你听说过这么一句话，*不要在Dockerfile中创建太多层*.

在Dockerfile中，每一个指令都会创建一个新的“层”，这里的层，指的是UnionFS中的一个文件目录。当我们创建了过多的层，会导致镜像体积变大，除此之外，Union FS 也会有最大层数限制。

因此对于如下的Dockerfile文件写法，应尽量避免：
```dockerfile
FROM debian:stretch

RUN apt-get update
RUN apt-get install -y gcc libc6-dev make wget
RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"
RUN mkdir -p /usr/src/redis
RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install
```

可优化为如下写法
```dockerfile
FROM debian:stretch

RUN set -x; buildDeps='gcc libc6-dev make wget' \
    && apt-get update \
    && apt-get install -y $buildDeps \
    && wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
    && mkdir -p /usr/src/redis \
    && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    && make -C /usr/src/redis \
    && make -C /usr/src/redis install \
    && rm -rf /var/lib/apt/lists/* \
    && rm redis.tar.gz \
    && rm -r /usr/src/redis \
    && apt-get purge -y --auto-remove $buildDeps
```

为什么要将镜像分为很多层，而不是像系统镜像那样打包为一个ISO文件。

不同的镜像，其所需的文件存在重复，如果对每个镜像都单独复制一份，会导致镜像过于臃肿，浪费磁盘空间，也会占用大量网络资源下载镜像文件。

例如我们有100个服务都需要依赖于ubuntu18.04环境，如果我们需要为这些服务制作镜像，显然不可能真的将ubuntu18.04的所有文件复制100份，最好的办法是机器上只存在一份这样的文件，每个容器都来复用它，这就需要使用UnionFS。

## 2. image分层的基础：UnionFS

UnionFS称：联合挂载。其最主要的功能是将多个目录挂载在同一个目录下。

前面说到，对于100个都需要Ubuntu18.04环境的服务，最好的办法是在机器上提供一份ubuntu18.04环境文件。

但这就产生了另一个问题：如果某一个服务需要对ubuntu18.04中的某个文件进行修改，或是在这之上产生新的文件，那么其他同样依赖于这个环境的服务可能会被影响。

目前docker使用的UnionFS实现是OverlayFS.下面通过一个小实验来掌握overlay的基本特性：

执行以下脚本

```sh
#!/bin/bash

umount ./merged
rm upper lower merged work -r

mkdir upper lower merged work
echo "I'm from lower!" > lower/in_lower.txt
echo "I'm from upper!" > upper/in_upper.txt
# `in_both` is in both directories
echo "I'm from lower!" > lower/in_both.txt
echo "I'm from upper!" > upper/in_both.txt

sudo mount -t overlay overlay \
 -o lowerdir=./lower,upperdir=./upper,workdir=./work \
 ./merged
```

![20220710170306](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220710170306.png)

OverlayFS 的一个 mount 命令牵涉到四类目录，分别是 lower，upper，merged 和 work，

- "lower/"，也就是被 mount 两层目录中底下的这层（lowerdir）。在 OverlayFS 中，最底下这一层里的文件是不会被修改的，你可以认为它是只读的。OverlayFS 支持多个 lowerdir。

- "upper/"，它是被 mount 两层目录中上面的这层 （upperdir）。在 OverlayFS 中，如果有文件的创建，修改，删除操作，那么都会在这一层反映出来，它是可读写的。

- "merged" ，是挂载点（mount point）目录，也是用户看到的目录，用户的实际文件操作在这里进行。

- "work/"，是一个存放临时文件的目录，OverlayFS 中如果有文件修改，就会在中间过程中临时存放文件到这里。并未表现在图中。

对于以下三种文件操作：

1. 新建文件。这个文件将会出现在upper目录中。

2. 删除文件。如果我们删除"in_upper.txt"，那么这个文件会在 upper/ 目录中消失。如果删除"in_lower.txt", 在 lower/ 目录里的"in_lower.txt"文件不会有变化，只是在 upper/ 目录中增加了一个特殊文件来告诉 OverlayFS，"in_lower.txt'这个文件不能出现在 merged/ 里了，这就表示它已经被删除了。

3. 修改文件。如果修改"in_lower.txt"，那么就会在 upper/ 目录中新建一个"in_lower.txt"文件，包含更新的内容，而在 lower/ 中的原来的实际文件"in_lower.txt"不会改变。

所有的更改都不会反映到lowerdir上，因此容器的镜像文件中各层正好作为 OverlayFS 的 lowerdir 的目录，然后加上一个空的 upperdir 一起挂载好后，就组成了容器的文件系统。



## References

https://cloud.tencent.com/developer/article/1769020

https://yeasy.gitbook.io/docker_practice/image/list

https://www.jianshu.com/p/3ba255463047

https://staight.github.io/2019/10/04/%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0-overlay2/

https://www.jianshu.com/p/3826859a6d6e

https://time.geekbang.org/column/article/318173

https://jvns.ca/blog/2019/11/18/how-containers-work--overlayfs/