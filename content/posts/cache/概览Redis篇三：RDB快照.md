---
author: "李昌"
title: "概览Redis篇三：RDB快照"
date: "2022-07-22"
tags: ["cache"]
categories: ["cache"]
ShowToc: true
TocOpen: true
---

> 极客时间《Redis 核心技术与实战》学习笔记

## 什么是RDB

所谓`RDB`，即`Redis DataBase`。是对Redis做的一个内存快照，即将内存中的数据在某一个时刻的状态记录。

对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件。

和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。

## 給哪些内存数据做快照

給哪些内存数据做快照，这关系到快照的执行效率。

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中。这样做的好处是，一次性记录了所有数据，一个都不少。

但给内存的全量数据做快照，把它们全部写入磁盘也会花费很多时间。而且，全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。

这里我们要做一个“灵魂之问”：RDB文件的生成会阻塞主线程吗？

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。
- `save`：在主线程中执行，会导致阻塞；
- `bgsave`：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

因此我们可以使用`bgsave`命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。

## 快照时数据能修改吗

这个问题非常重要，这是因为，如果数据能被修改，那就意味着 Redis 还能正常处理写操作。否则，所有写操作都得等到快照完了才能执行，性能一下子就降低了。

如果我们使用`save`命令，显然是不能修改的，以为主线程已经被阻塞掉了。

如果使用`bgsave`命令，看起来数据还是可以修改的，因为主线程没有被阻塞。但**避免阻塞和正常处理写操作并不是一回事**。此时，主线程的确没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据。

为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的`写时复制技术（Copy-On-Write, COW）`，在执行快照的同时，正常处理写操作。

简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。

此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。

![20220722102955](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220722102955.png)

这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。

## 可以连拍吗
对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。

但是，如果频繁地执行全量快照，也会带来两方面的开销。
1. 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。

2. bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了

那么，如何防止在上一次快照之后修改的数据丢失呢？

可以使用增量快照，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。

但这样又带来另外一个问题：做增量快照需要记住哪些数据被修改了，这又是一笔不小的内存开销。

对比之前的AOF日志可以发现，快照的恢复速度较快，但频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销。

Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

![20220722103556](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220722103556.png)

## 关于AOF和RDB的选择

- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
- 如果允许分钟级别的数据丢失，可以只使用 RDB；
- 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。



