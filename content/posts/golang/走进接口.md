---
author: "李昌"
title: "走进接口"
date: "2022-08-04"
tags: ["golang"]
categories: ["golang"]
ShowToc: true
TocOpen: true
---

> 以下代码基于golang1.18

## 1. 接口的内部结构
```go
type iface struct {
	tab  *itab
	data unsafe.Pointer
}
```

一个接口是一个`iface`结构体，其中包含一个`itab`指针和一个`unsafe.Pointer`。

概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。

一个`itab`可以表示一个接口的类型和赋给这个接口的实体类型，即为接口的动态类型，而`data`所指向的`unsafe.Pointer`则指向接口的动态值。

近距离来看`itab`：

```go
type itab struct {
	inter *interfacetype
	_type *_type
	hash  uint32 // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}
```

其中`inter`字段描述了接口的类型，`_type`字段描述了实体类型，`hash`字段是类型哈希，用于类型匹配，`fun`字段放置和接口方法对应的具体数据类型的方法地址。

再来看`interfacetype`
```go
type interfacetype struct {
	typ     _type
	pkgpath name
	mhdr    []imethod
}
```
其中`typ`和`itab`中的`_type`为同一个值，`pkgpath`则存储了接口的包名，`mhdr`则表示接口所定义的函数列表。

这样来看，一个接口主要有两个部分构成：第一是对于接口本身的描述，包括接口的包名`iface.itab.inter.pkgpath`、接口的函数列表`iface.itab.inter.mhdr`，接口的hash值`iface.itab.hash`。第二部分是对于实现接口的实体的描述，包括实体的类型`iface.itab._type`，实体的值`iface.data`。

可以将itab的值输出看看：
```go
type iface struct {
	tab  *itab
	data unsafe.Pointer
}

type itab struct {
	inter  *interfacetype
	_type  uintptr
	hash   uint32
	_      [4]byte
	myfunc [1]uintptr
}

type interfacetype struct {
	mytype  uintptr
	pkgpath string
	mhdr    []uintptr
}

type Person interface {
	Walk()
	Say(words []string) string
}

type Student struct {
	name string
	age  int
}

func (s Student) Walk() {
	return
}

func (s Student) Say(words []string) string {
	return strings.Join(words, " ")
}

func main() {
	var p = Person(Student{
		name: "lichang",
		age:  18,
	})

	// 查看iface的结构
	p_iface := *(*iface)(unsafe.Pointer(&p))
	fmt.Println(p_iface.tab)

	// 查看接口的动态值
	s := (*Student)(unsafe.Pointer(p_iface.data))
	fmt.Println(*s)
}
```

输出：
```
&{0x489a80 4773888 3558907866 [0 0 0 0] [4234176]}
{lichang 18}
```

而对于一个空接口来说，其并不是一个`iface`，而是一个`eface`:
```go
type eface struct {
	_type *_type
	data  unsafe.Pointer
}
```

一个空接口，其没有函数列表，用于描述空接口的结构体只有两个字段，一是`_type`，表示实体类型，二是`data`，指向动态值。

## 2. 接口的类型转换

### 2.1 结构体到接口类型的转换


对于如下代码：
```go
type Person interface {
	Walk()
	Say(words []string) string
}

type Student struct {
	name string
	age  int
}

func (s Student) Walk() {
	return
}

func (s Student) Say(words []string) string {
	return strings.Join(words, " ")
}

func main() {
	var p = Person(Student{
		name: "lichang",
		age:  18,
	})

	fmt.Println(p)
}
```

通过查看汇编代码可知，其在进行`Student`->`Person`的转换时，调用了`runtime.convT`，来看一下这个函数：
```go
func convT(t *_type, v unsafe.Pointer) unsafe.Pointer {
	// ... 部分条件检查

	x := mallocgc(t.size, t, true)
	typedmemmove(t, x, v)
	return x
}

func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer

func typedmemmove(typ *_type, dst, src unsafe.Pointer)
```

`convT`函数接收一个`*_type`：t, 一个`unsafe.Pointer`：v，将类型为t的v指向的值转换为一个可以作为iface结构体第二个字段的值。

真正工作的只有两行，第一行分配一个类型为t的新的内存空间，并为其赋零值，第二行将v指向的值复制到x，最后返回。

对于如下代码：
```go
var _ Person = (*Student)(nil)
```
可以检查Student是否实现了Person接口，其底层同样是调用的`runtime.convT()`，如果Student未实现Person接口，则在typedmemmove会发生panic

### 2.2 接口类型之间的转换

```go
type Person interface {
	Walk()
	Say(words []string) string
}

type Walker interface {
	Walk()
}

type Student struct {
	name string
	age  int
}

func (s Student) Walk() {
	return
}

func (s Student) Say(words []string) string {
	return strings.Join(words, " ")
}

func main() {
	var p = Person(Student{
		name: "lichang",
		age:  18,
	})

	var w Walker = p

	fmt.Println(w)
}
```

编译后查看汇编代码可知，在进行`Person`接口到`Student`接口的转换时调用了`runtime.convI2I`:
```go
func convI2I(dst *interfacetype, src *itab) *itab {
	if src == nil {
		return nil
	}
	if src.inter == dst {
		return src
	}
	return getitab(dst, src._type, false)
}
```

`runtime.convI2I`函数将src itab中的inter转换到dst类型，并返回一个新的itab，首先检查src不为空，然后判断src的inter是否与dst相等，最后调用了`runtime.getitab`

来看`runtime.getitab`
```go
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
	// ...

	var m *itab

    // 首先会从已经存在的表中查找，如果找到了可以直接结束，否则进行下一步。
    // 这里使用原子操作保证在这之前对itabTable的写操作结束。
	t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&itabTable)))
	if m = t.find(inter, typ); m != nil {
		goto finish
	}

	// 如果没找到，加锁继续找
	lock(&itabLock)
	if m = itabTable.find(inter, typ); m != nil {
		unlock(&itabLock)
		goto finish
	}

    // 还没找到，搞个新的
	m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*goarch.PtrSize, 0, &memstats.other_sys))
	m.inter = inter
	m._type = typ
	m.hash = 0
	m.init()
	itabAdd(m)
	unlock(&itabLock)
finish:
	if m.fun[0] != 0 {
		return m
	}
	if canfail {
		return nil
	}

	panic(&TypeAssertionError{concrete: typ, asserted: &inter.typ, missingMethod: m.init()})
}
```

这里一开始在构造`itab`时并没有直接构造，而是去一个`runtime.itabTableType`结构体中去查找这个`itab`是否存在，`runtime.itabTableType`的定义如下：
```go
type itabTableType struct {
	size    uintptr             // length of entries array. Always a power of 2.
	count   uintptr             // current number of filled entries.
	entries [itabInitSize]*itab // really [size] large
}
```

用于查找`itab`的函数如下：
```go
func (t *itabTableType) find(inter *interfacetype, typ *_type) *itab {
	// Implemented using quadratic probing.
	// Probe sequence is h(i) = h0 + i*(i+1)/2 mod 2^k.
	// We're guaranteed to hit all table entries using this probe sequence.
	mask := t.size - 1
	h := itabHashFunc(inter, typ) & mask
	for i := uintptr(1); ; i++ {
		p := (**itab)(add(unsafe.Pointer(&t.entries), h*goarch.PtrSize))
		// Use atomic read here so if we see m != nil, we also see
		// the initializations of the fields of m.
		// m := *p
		m := (*itab)(atomic.Loadp(unsafe.Pointer(p)))
		if m == nil {
			return nil
		}
		if m.inter == inter && m._type == typ {
			return m
		}
		h += i
		h &= mask
	}
}
```

在完成这些步骤之后，一个新的`itab`就构造完成了，而由于在进行转换时实现接口的实体并没有变化，只是接口类型发生了变化，因此我们只需要将`iface.itab`重新赋值为我们需要的`itab`即可。

### 2.3 空接口的转换
```go
func main() {
        var x int = 1

        var ix interface{} = x

        fmt.Println(ix)
}
```

这里调用的是`runtime.convT64(SB)`函数：
```go
func convT64(val uint64) (x unsafe.Pointer) {
	if val < uint64(len(staticuint64s)) {
		x = unsafe.Pointer(&staticuint64s[val])
	} else {
		x = mallocgc(8, uint64Type, false)
		*(*uint64)(x) = val
	}
	return
}
```

这里首先检查其值是否小于`len(staticuint64s)`，如果是的话，就不需要再去进行内存分配，而是直接到数组中取，算是进行了一步优化。否则调用`mallocgc`为其分配一个新的内存空间，然后将其底层值赋值为val。

这里如果是将一个字符串转换为空接口类型，则调用的是`runtime.convTstring`:
```go
func convTstring(val string) (x unsafe.Pointer) {
	if val == "" {
		x = unsafe.Pointer(&zeroVal[0])
	} else {
		x = mallocgc(unsafe.Sizeof(val), stringType, true)
		*(*string)(x) = val
	}
	return
}
```
逻辑相差不大。

在runtime包中，对于某些特殊的类型做了优化，可直接调用相应的函数进行实体类型到空接口类型的转化，这些被调用的函数有：
```go
func convT16(val uint16) unsafe.Pointer
func convT32(val uint32) unsafe.Pointer
func convT64(val uint64) unsafe.Pointer
func convTstring(val string) unsafe.Pointer
func convTslice(val []uint8) unsafe.Pointer
```

## 3. 类型断言

TODO

## References

[Go Questions](https://golang.design/go-questions/interface/assert/)

[interface的类型断言是如何实现](https://segmentfault.com/a/1190000039894161)
