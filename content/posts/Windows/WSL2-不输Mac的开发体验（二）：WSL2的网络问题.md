---
author: "李昌"
title: "WSL2-不输Mac的开发体验（二）：WSL2的网络问题"
date: "2021-08-10"
tags: ["wsl", "windows", "proxy"]
categories: ["Windows"]
ShowToc: true
TocOpen: true
---

## 1. 代理服务

### 1.1 获取Windows主机ip并使用其代理
可以在wsl中安装代理软件，但如果win主机上也有代理软件的话，会感觉有点乱。这里让wsl使用主机的代理。

我使用的代理软件是`clash`，这里首先要确保clash允许局域网  
![20210810162350](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20210810162350.png)

确认完clash支持局域网后，我们来看如何从wsl中获取win主机的ip地址。
在Windows主机上，我们可以用`ipconfig`命令来查看本地的ip地址
```sh
ipconfig
```
![20210810172327](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20210810172327.png)

如图所示，命令行输出了在wsl网络中Win主机的ip地址。（wsl和windows处于一个网络中，这里得到的是windows在这个网络中的ip地址）。

如果我们想使用windows的代理，那么可以使用如下命令(在wsl中)：
```bash
export ALL_PROXY="http://172.28.48.1:7890"
```
这里， `172.28.48.1`是Windows在这个网络中的ip地址，`7890`是代理接口。

通过访问google查看是否代理成功：
![20210810172708](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20210810172708.png)

### 1.2 使用脚本自动获取ip地址并设置代理
通过[1.1](获取Windows主机ip并使用其代理)我们知道，可以在Windows主机中获取其在wsl网络中的ip地址，那我们是否可以在wsl中获取到这个地址呢？

```bash
cat /etc/resolv.conf
```
得到类似下面的输出：
```bash
# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:
# [network]
# generateResolvConf = false
nameserver 172.28.48.1
```

这里的`nameserver`，是不是就和我们在Windows下获取到的ip地址是一样的。

我们通过一个脚本来自动获取到这个ip地址，并将其设置为代理地址：
```bash
#!/bin/bash
host_ip=$(cat /etc/resolv.conf |grep "nameserver" |cut -f 2 -d " ") # 获取ip地址
echo $host_ip # 输出ip地址
export ALL_PROXY="http://$host_ip:7890" # 设置代理，7890为我的代理端口
curl -I https://www.google.com # 尝试访问Google, 验证代理的有效性
```

将这个脚本移动到某个目录下，例如我将其放在`/opt/proxy/proxy.sh`  
再为其设置一个快捷启动方式：
```bash
vim ~/.bashrc
```
在`~/.bashrc`最后输入下行
```bash
alias proxy=/opt/proxy/proxy.sh
```

```bash
source ~/.bashrc
```

现在，我们可以使用`proxy`命令来一键设置代理了
![20210810173807](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20210810173807.png)

## 2. 从windows主机访问wsl2

### 2.1 获取WSL的ip地址
当我们使用WSL2时，wsl和Windows相当于两台处于一个网络中但分贝独立的主机（我们称这个网络为WSL网络）。在Windows主机上使用`ipconfig`我们可以看到Windows主机在WSL网络中的地址，相应的，在wsl中我们可以使用`ifconfig`命令来查看wsl在WSL网络中的地址。
```bash
ifconfig
```
![20210810174254](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20210810174254.png)

其中的`eth0`就是wsl在WSL网络中的IP地址，这里为：172.28.62.74

打开Windows文件夹，定位到`C:\Windows\System32\drivers\etc\hosts`这个文件，在其最后一行加上：
```
172.28.62.74 wsl #wsl2 dns config
```

配置完成之后，你就可以使用`wsl`域名来直接访问wsl中的服务。如：`https://wsl:8080/index`。（如果你的8080端口有服务监听的话）。

### 2.2 使用脚本自动为windows配置dns

```bash
#!/bin/bash
HOSTS_FILE_WIN='/mnt/c/Windows/System32/drivers/etc/hosts'
inetIp=`ifconfig eth0 | grep -o "inet [0-9]*\.[0-9]*\.[0-9]*\.[0-9]*  netmask" | cut -f 2 -d " "` # 获取本机ip

nu=`cat -n ${HOSTS_FILE_WIN} | grep wsl2 | awk '{print $1}'`   # 获取已设置dns行号

dnsIp=`cat ${HOSTS_FILE_WIN} | grep -o "[0-9]*\.[0-9]*\.[0-9]*\.[0-9]* wsl #" | cut -f 1 -d " "` # 获取已设置dns ip

echo "wsl's ip is: ${inetIp}"

# set -x
set -e
if [ ${nu} ]  # 若已设置
then
        if [ ${inetIp} != ${dnsIp} ] # 已设置dns不正确
        then
                echo reset
                sed -i "${nu}d" ${HOSTS_FILE_WIN}  # 删除对应行
                echo "${inetIp} wsl #wsl2 dns config" >> ${HOSTS_FILE_WIN} # 重新设置
        fi
else # 未设置
        echo "${inetIp} wsl #wsl2 dns config" >> ${HOSTS_FILE_WIN} # 直接设置
fi
```

同样，将这个脚本保存到`/opt/dns/dns.sh`，然后为其设置别名（快捷启动）`alias dns="/opt/dns/dns.sh"`。   

当需要从Windows访问wsl中的服务时，就可以使用`dns`命令来设置为通过使用`wsl`域名来访问。

> 关于这个脚本，我还实现了golang版本，并编译出二进制文件，你可以直接下载二进制文件放在你的`/usr/local/bin`目录下面，在需要的时候使用命令一键设置dns.
> 地址在这里：https://github.com/yangchnet/wsl-Ip


### 2.3 遇到访问权限问题怎么办
如果遇到因权限问题不能更改文件，可按照以下步骤更改`C:\Windows\System32\drivers\etc\hosts`文件权限
右击文件，选择`属性`，选择`安全`选项卡，点击`编辑`来更改文件权限  
![20210820194359](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20210820194359.png)

为`User`增加写入权限
![20210820194659](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20210820194659.png)

点击确定保存退出。

这时候，可以在wsl中cd进入`/mnt/c/Windows/System32/drivers/etc`，使用`ll`命令查看`hosts`文件的权限
![20210820194929](https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20210820194929.png)
可以看到，对于`hosts`文件，已经有了写权限


