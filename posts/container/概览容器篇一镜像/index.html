<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>概览容器篇一：镜像 | Linote</title><meta name=keywords content="docker,container"><meta name=description content="1. 分层的镜像 在我们启动一个容器之前，通常需要下载这个容器对应的镜像，以这个镜像为基础启动容器。镜像中包含了对应的程序的二进制文件与其所依赖的文件，程序在启动后看到的rootfs只是这个镜像中存在的文件。这样，我们就可以为容器中的进程提供一个干净的文件系统。
创建一个镜像（image）的最简单方法是使用Dockerfile。
FROMscratchCOPY hello /CMD [&#34;/hello&#34;]scratch是docker为我们提供的一个空镜像，我们可以在此基础上构建任何我们想要的镜像。
在书写Dockerfile时，想必你听说过这么一句话，不要在Dockerfile中创建太多层.
在Dockerfile中，每一个指令都会创建一个新的“层”，这里的层，指的是UnionFS中的一个文件目录。当我们创建了过多的层，会导致镜像体积变大，除此之外，Union FS 也会有最大层数限制。
因此对于如下的Dockerfile文件写法，应尽量避免：
FROMdebian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install可优化为如下写法
FROMdebian:stretchRUN set -x; buildDeps='gcc libc6-dev make wget' \  && apt-get update \  && apt-get install -y $buildDeps \  && wget -O redis.tar.gz &#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34; \  && mkdir -p /usr/src/redis \  && tar -xzf redis."><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/container/%E6%A6%82%E8%A7%88%E5%AE%B9%E5%99%A8%E7%AF%87%E4%B8%80%E9%95%9C%E5%83%8F/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="概览容器篇一：镜像"><meta property="og:description" content="1. 分层的镜像 在我们启动一个容器之前，通常需要下载这个容器对应的镜像，以这个镜像为基础启动容器。镜像中包含了对应的程序的二进制文件与其所依赖的文件，程序在启动后看到的rootfs只是这个镜像中存在的文件。这样，我们就可以为容器中的进程提供一个干净的文件系统。
创建一个镜像（image）的最简单方法是使用Dockerfile。
FROMscratchCOPY hello /CMD [&#34;/hello&#34;]scratch是docker为我们提供的一个空镜像，我们可以在此基础上构建任何我们想要的镜像。
在书写Dockerfile时，想必你听说过这么一句话，不要在Dockerfile中创建太多层.
在Dockerfile中，每一个指令都会创建一个新的“层”，这里的层，指的是UnionFS中的一个文件目录。当我们创建了过多的层，会导致镜像体积变大，除此之外，Union FS 也会有最大层数限制。
因此对于如下的Dockerfile文件写法，应尽量避免：
FROMdebian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install可优化为如下写法
FROMdebian:stretchRUN set -x; buildDeps='gcc libc6-dev make wget' \  && apt-get update \  && apt-get install -y $buildDeps \  && wget -O redis.tar.gz &#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34; \  && mkdir -p /usr/src/redis \  && tar -xzf redis."><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/container/%E6%A6%82%E8%A7%88%E5%AE%B9%E5%99%A8%E7%AF%87%E4%B8%80%E9%95%9C%E5%83%8F/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-10T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-10T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="概览容器篇一：镜像"><meta name=twitter:description content="1. 分层的镜像 在我们启动一个容器之前，通常需要下载这个容器对应的镜像，以这个镜像为基础启动容器。镜像中包含了对应的程序的二进制文件与其所依赖的文件，程序在启动后看到的rootfs只是这个镜像中存在的文件。这样，我们就可以为容器中的进程提供一个干净的文件系统。
创建一个镜像（image）的最简单方法是使用Dockerfile。
FROMscratchCOPY hello /CMD [&#34;/hello&#34;]scratch是docker为我们提供的一个空镜像，我们可以在此基础上构建任何我们想要的镜像。
在书写Dockerfile时，想必你听说过这么一句话，不要在Dockerfile中创建太多层.
在Dockerfile中，每一个指令都会创建一个新的“层”，这里的层，指的是UnionFS中的一个文件目录。当我们创建了过多的层，会导致镜像体积变大，除此之外，Union FS 也会有最大层数限制。
因此对于如下的Dockerfile文件写法，应尽量避免：
FROMdebian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install可优化为如下写法
FROMdebian:stretchRUN set -x; buildDeps='gcc libc6-dev make wget' \  && apt-get update \  && apt-get install -y $buildDeps \  && wget -O redis.tar.gz &#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34; \  && mkdir -p /usr/src/redis \  && tar -xzf redis."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"概览容器篇一：镜像","item":"http://yangchnet.github.io/Dessert/posts/container/%E6%A6%82%E8%A7%88%E5%AE%B9%E5%99%A8%E7%AF%87%E4%B8%80%E9%95%9C%E5%83%8F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"概览容器篇一：镜像","name":"概览容器篇一：镜像","description":"1. 分层的镜像 在我们启动一个容器之前，通常需要下载这个容器对应的镜像，以这个镜像为基础启动容器。镜像中包含了对应的程序的二进制文件与其所依赖的文件，程序在启动后看到的rootfs只是这个镜像中存在的文件。这样，我们就可以为容器中的进程提供一个干净的文件系统。\n创建一个镜像（image）的最简单方法是使用Dockerfile。\nFROMscratchCOPY hello /CMD [\u0026#34;/hello\u0026#34;]scratch是docker为我们提供的一个空镜像，我们可以在此基础上构建任何我们想要的镜像。\n在书写Dockerfile时，想必你听说过这么一句话，不要在Dockerfile中创建太多层.\n在Dockerfile中，每一个指令都会创建一个新的“层”，这里的层，指的是UnionFS中的一个文件目录。当我们创建了过多的层，会导致镜像体积变大，除此之外，Union FS 也会有最大层数限制。\n因此对于如下的Dockerfile文件写法，应尽量避免：\nFROMdebian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz \u0026#34;http://download.redis.io/releases/redis-5.0.3.tar.gz\u0026#34;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install可优化为如下写法\nFROMdebian:stretchRUN set -x; buildDeps=\u0026#39;gcc libc6-dev make wget\u0026#39; \\  \u0026amp;\u0026amp; apt-get update \\  \u0026amp;\u0026amp; apt-get install -y $buildDeps \\  \u0026amp;\u0026amp; wget -O redis.tar.gz \u0026#34;http://download.redis.io/releases/redis-5.0.3.tar.gz\u0026#34; \\  \u0026amp;\u0026amp; mkdir -p /usr/src/redis \\  \u0026amp;\u0026amp; tar -xzf redis.","keywords":["docker","container"],"articleBody":"1. 分层的镜像 在我们启动一个容器之前，通常需要下载这个容器对应的镜像，以这个镜像为基础启动容器。镜像中包含了对应的程序的二进制文件与其所依赖的文件，程序在启动后看到的rootfs只是这个镜像中存在的文件。这样，我们就可以为容器中的进程提供一个干净的文件系统。\n创建一个镜像（image）的最简单方法是使用Dockerfile。\nFROMscratchCOPY hello /CMD [\"/hello\"]scratch是docker为我们提供的一个空镜像，我们可以在此基础上构建任何我们想要的镜像。\n在书写Dockerfile时，想必你听说过这么一句话，不要在Dockerfile中创建太多层.\n在Dockerfile中，每一个指令都会创建一个新的“层”，这里的层，指的是UnionFS中的一个文件目录。当我们创建了过多的层，会导致镜像体积变大，除此之外，Union FS 也会有最大层数限制。\n因此对于如下的Dockerfile文件写法，应尽量避免：\nFROMdebian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\"RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install可优化为如下写法\nFROMdebian:stretchRUN set -x; buildDeps='gcc libc6-dev make wget' \\  \u0026\u0026 apt-get update \\  \u0026\u0026 apt-get install -y $buildDeps \\  \u0026\u0026 wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\  \u0026\u0026 mkdir -p /usr/src/redis \\  \u0026\u0026 tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\  \u0026\u0026 make -C /usr/src/redis \\  \u0026\u0026 make -C /usr/src/redis install \\  \u0026\u0026 rm -rf /var/lib/apt/lists/* \\  \u0026\u0026 rm redis.tar.gz \\  \u0026\u0026 rm -r /usr/src/redis \\  \u0026\u0026 apt-get purge -y --auto-remove $buildDeps这里的原理有点类似于Redis的AOF日志重写。\n为什么要将镜像分为很多层，而不是像系统镜像那样打包为一个ISO文件。\n不同的镜像，其所需的文件存在重复，如果对每个镜像都单独复制一份，会导致镜像过于臃肿，浪费磁盘空间，也会占用大量网络资源下载镜像文件。\n例如我们有100个服务都需要依赖于ubuntu18.04环境，如果我们需要为这些服务制作镜像，显然不可能真的将ubuntu18.04的所有文件复制100份，最好的办法是机器上只存在一份这样的文件，每个容器都来复用它，这就需要使用UnionFS。\n2. image分层的基础：UnionFS UnionFS称：联合挂载。其最主要的功能是将多个目录挂载在同一个目录下。\n前面说到，对于100个都需要Ubuntu18.04环境的服务，最好的办法是在机器上提供一份ubuntu18.04环境文件，所有的服务都来依赖这一份文件。\n但这就产生了另一个问题：如果某一个服务需要对ubuntu18.04中的某个文件进行修改，或是在这之上产生新的文件，那么其他同样依赖于这个环境的服务可能会被影响。\n这就需要用到UnionFS的特性。\n目前docker使用的UnionFS实现是OverlayFS.下面通过一个小实验来掌握overlay的基本特性：\n执行以下脚本\n#!/bin/bash  umount ./merged rm upper lower merged work -r mkdir upper lower merged work echo \"I'm from lower!\"  lower/in_lower.txt echo \"I'm from upper!\"  upper/in_upper.txt # `in_both` is in both directories echo \"I'm from lower!\"  lower/in_both.txt echo \"I'm from upper!\"  upper/in_both.txt sudo mount -t overlay overlay \\  -o lowerdir=./lower,upperdir=./upper,workdir=./work \\  ./merged OverlayFS 的一个 mount 命令牵涉到四类目录，分别是 lower，upper，merged 和 work，\n  “lower/\"，也就是被 mount 两层目录中底下的这层（lowerdir）。在 OverlayFS 中，最底下这一层里的文件是不会被修改的，你可以认为它是只读的。OverlayFS 支持多个 lowerdir。\n  “upper/\"，它是被 mount 两层目录中上面的这层 （upperdir）。在 OverlayFS 中，如果有文件的创建，修改，删除操作，那么都会在这一层反映出来，它是可读写的。\n  “merged” ，是挂载点（mount point）目录，也是用户看到的目录，用户的实际文件操作在这里进行。\n  “work/\"，是一个存放临时文件的目录，OverlayFS 中如果有文件修改，就会在中间过程中临时存放文件到这里。并未表现在图中。\n  如果lower和upper中存在同名文件，那么不会显示lower中的文件。\n对于以下三种文件操作：\n  新建文件。这个文件将会出现在upper目录中。\n  删除文件。如果我们删除\"in_upper.txt”，那么这个文件会在 upper/ 目录中消失。如果删除\"in_lower.txt”, 在 lower/ 目录里的\"in_lower.txt\"文件不会有变化，只是在 upper/ 目录中增加了一个特殊文件来告诉 OverlayFS，“in_lower.txt’这个文件不能出现在 merged/ 里了，这就表示它已经被删除了。\n  修改文件。如果修改\"in_lower.txt”，那么就会在 upper/ 目录中新建一个\"in_lower.txt\"文件，包含更新的内容，而在 lower/ 中的原来的实际文件\"in_lower.txt\"不会改变。\n  所有的更改都不会反映到lowerdir上，因此容器的镜像文件中各层正好作为 OverlayFS 的 lowerdir 的目录，然后加上一个空的 upperdir 一起挂载好后，就组成了容器的文件系统。\n同时，overlayfs还支持挂载多个lower目录，这样就实现了镜像的多个层。\n以下是一个正在运行的容器他的UnionFS挂载情况：\n\"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/94809845e9decf34968235fe45bc9d66780a6c2f1929e6aeace43c62ae8a8473-init/diff:/var/lib/docker/overlay2/c95ef099ca18c9b33ff36907bb94c28f3c81a9758058b1698ae438fc88552ac7/diff:/var/lib/docker/overlay2/84cc0780b885789c335f30a784fde4355bfc11b4b9c538da0d6be665d0e87f74/diff:/var/lib/docker/overlay2/94ab5f531aa05c31918599de4a947b6af18488a5bd9f62186060aa32a0938677/diff:/var/lib/docker/overlay2/4154cfa0480d3be6d22ecd4b52225798d8c7d2f349602d36a821fd310318f19e/diff\", \"MergedDir\": \"/var/lib/docker/overlay2/94809845e9decf34968235fe45bc9d66780a6c2f1929e6aeace43c62ae8a8473/merged\", \"UpperDir\": \"/var/lib/docker/overlay2/94809845e9decf34968235fe45bc9d66780a6c2f1929e6aeace43c62ae8a8473/diff\", \"WorkDir\": \"/var/lib/docker/overlay2/94809845e9decf34968235fe45bc9d66780a6c2f1929e6aeace43c62ae8a8473/work\" }, \"Name\": \"overlay2\" }, 3. 镜像的组成 docker对镜像的管理是根据OCI标准来的，根据OCI标准，一个image可以分为以下四个部分：\n Image Index: image index是个json文件，用于使image能支持多个平台和多tag。 Image Manifest: manifest是一个json文件，这个文件包含了对filesystem layers和image config的描述。 Image Config: image config就是一个json文件，这个json文件包含了对这个image的描述。 FileSystem Layer: Filesystem Layer包含了文件系统的信息，即该image包含了哪些文件/目录，以及它们的属性和数据。  它们之间的关系如下：\n3.1 Media Type Media Type, 媒体类型。\n在OCI标准中，不同的文件对应不同的media type。其对应关系如下：\n   Media Type 说明     application/vnd.oci.descriptor.v1+json Content Descriptor 内容描述文件   application/vnd.oci.layout.header.v1+json OCI Layout 布局描述文件   application/vnd.oci.image.index.v1+json Image Index 高层次的镜像元信息文件   application/vnd.oci.image.manifest.v1+json Image Manifest 镜像元信息文件   application/vnd.oci.image.config.v1+json Image Config 镜像配置文件   application/vnd.oci.image.layer.v1.tar Image Layer 镜像层文件   application/vnd.oci.image.layer.v1.tar+gzip Image Layer 镜像层文件gzip压缩   application/vnd.oci.image.layer.nondistributable.v1.tar Image Layer 非内容寻址管理   application/vnd.oci.image.layer.nondistributable.v1.tar+gzip Image Layer, gzip压缩 非内容寻址管理    3.2 FileSystem Layer 每个filesystem layer都包含了在上一个layer上的改动情况，主要包含三方面的内容：\n  变化类型：是增加、修改还是删除了文件\n  文件类型：每个变化发生在哪种文件类型上\n  文件属性：文件的修改时间、用户ID、组ID、RWX权限等\n  根据我们上面所介绍的UnionFS，很容易理解。\n3.3 Image Config Config包含了对镜像文件的描述，它是一个json文件，示例如下：\n{ \"created\": \"2015-10-31T22:22:56.015925234Z\", \"author\": \"Alyssa P. Hacker \", \"architecture\": \"amd64\", \"os\": \"linux\", \"config\": { \"User\": \"alice\", \"ExposedPorts\": { \"8080/tcp\": {} }, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"FOO=oci_is_a\", \"BAR=well_written_spec\" ], ... }, \"rootfs\": { \"diff_ids\": [ \"sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1\", \"sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\" ], \"type\": \"layers\" }, \"history\": [ ... ] } 其中大部分是可选参数，必须的参数有：\n architecture: CPU架构 os： 镜像在什么操作系统上运行 rootfs：指定了image所包含的filesystem layers，type的值必须是layers，diff_ids包含了layer的列表（顺序排列），每一个sha256就是每层layer对应tar包的sha256码  type： type的值必须是layers diff_ids: 每层layer包的哈希值的列表    其他都是可选参数，见名知意\n3.4 Image Manifest Image Manifest为特定架构和操作系统的单个容器镜像提供配置和一系列的layer。\nManifest 的三大主要目标：\n  内容可寻址（通过 hash 算法为镜像和它的组件生成唯一ID）\n  支持多种平台的架构镜像（由一个更上层的 manifest 说明包含的镜像 manifests 其具体平台的版本情况）\n  能被解析成为 OCI 运行时规范\n  示例如下：\n{ \"schemaVersion\": 2, \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"config\": { \"mediaType\": \"application/vnd.oci.image.config.v1+json\", \"size\": 7023, \"digest\": \"sha256:b5b2b2c507a0944348e0303114d8d93aaaa081732b86451d9bce1f432a537bc7\" }, \"layers\": [ { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"size\": 32654, \"digest\": \"sha256:9834876dcfb05cb167a5c24953eba58c4ac89b1adf57f28f2f9d09af107ee8f0\" }, { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"size\": 16724, \"digest\": \"sha256:3c3a4604a545cdc127456d94e421cd355bca5b528f4a9c1905b15da2eb4a4c6b\" }, { \"mediaType\": \"application/vnd.oci.image.layer.v1.tar+gzip\", \"size\": 73109, \"digest\": \"sha256:ec4b8955958665577945c89419d1af06b5f7636b4ac3da7f12184802ad867736\" } ], \"annotations\": { \"com.example.key1\": \"value1\", \"com.example.key2\": \"value2\" } } 从上面的json文件中可以看出，manifest中包含对config的描述，包括其mediaType， size，digest等，这里的digest就是config文件的sha256值，可以看出manifest与config的一对一对应关系。而layer中则指明了这个manifest包含哪些层，manifest与layer是一对多关系。\n3.5 Image Index Image Index指向一个特定manifests的更高层manifest，用于支持多平台。index是可选的。\n示例如下：\n{ \"schemaVersion\": 2, \"mediaType\": \"application/vnd.oci.image.index.v1+json\", \"manifests\": [ { \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"size\": 7143, \"digest\": \"sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f\", \"platform\": { \"architecture\": \"ppc64le\", \"os\": \"linux\" } }, { \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"size\": 7682, \"digest\": \"sha256:5b0bcabd1ed22e9fb1310cf6c2dec7cdef19f0ad69efa1f392e94a4333501270\", \"platform\": { \"architecture\": \"amd64\", \"os\": \"linux\" } } ], \"annotations\": { \"com.example.key1\": \"value1\", \"com.example.key2\": \"value2\" } } index文件包含了对image中所有manifest的描述，相当于一个manifest列表，包括每个manifest的media type，文件大小，sha256码，支持的平台以及平台特殊的配置。\n比如ubuntu想让它的image支持amd64和arm64平台，于是它在两个平台上都编译好相应的包，然后将两个平台的layer都放到这个image的filesystem layers里面，然后写两个config文件和两个manifest文件，再加上这样一个描述不同平台manifest的index文件，就可以让这个image支持两个平台了，两个平台的用户可以使用同样的命令得到自己平台想要的那些layer。\n3.6 镜像layout 镜像的布局包含以下内容：\n blobs：内容寻址的块文件，目录必须存在，但是可以为空 oci-layout: 必须存在的json对象，必须包含imageLayoutVersion字段 index.json: 必须存在的JSON格式，文件中必须包含镜像Index的基本属性  可以查看hello-world镜像的内容：\n$ yay -S skopeo # 安装skopeo $ skopeo copy docker://hello-world oci:hello-world # 利用skopeo下载hello-world镜像 $ tree -L 3 hello-world hello-world ├── blobs │ └── sha256 │ ├── 2db29710123e3e53a794f2694094b9b4338aa9ee5c40b930cb8063a1be392c54 │ ├── 75ab15a4973c91d13d02b8346763142ad26095e155ca756c79ee3a4aa792991f │ └── 811f3caa888b1ee5310e2135cfd3fe36b42e233fe0d76d9798ebd324621238b9 ├── index.json └── oci-layout index.json\n{ \"schemaVersion\": 2, \"manifests\": [ { \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\", \"digest\": \"sha256:75ab15a4973c91d13d02b8346763142ad26095e155ca756c79ee3a4aa792991f\", \"size\": 402 } ] } oci-layout\n{ \"imageLayoutVersion\": \"1.0.0\" } 4. 从远程获取镜像的过程   docker发送image的名称+tag（或者digest）给registry服务器，服务器根据收到的image的名称+tag（或者digest），找到相应image的manifest，然后将manifest返回给docker\n  docker得到manifest后，读取里面image配置文件的digest(sha256)，这个sha256码就是image的ID\n  根据ID在本地找有没有存在同样ID的image，有的话就不用继续下载了\n  如果没有，那么会给registry服务器发请求（里面包含配置文件的sha256和media type），拿到image的配置文件（Image Config）\n  根据配置文件中的diff_ids（每个diffid对应一个layer tar包的sha256，tar包相当于layer的原始格式），在本地找对应的layer是否存在\n  如果layer不存在，则根据manifest里面layer的sha256和media type去服务器拿相应的layer（相当去拿压缩格式的包）。\n  拿到后进行解压，并检查解压后tar包的sha256能否和配置文件（Image Config）中的diff_id对的上，对不上说明有问题，下载失败\n  根据docker所用的后台文件系统类型，解压tar包并放到指定的目录\n  等所有的layer都下载完成后，整个image下载完成，就可以使用了\n  上面的过程涉及到两个接口：\nGET /v2//manifests/ 其中为镜像名称，可能包含tag或digest。\n这个接口用于获取镜像的manifest。\nGET /v2//blobs/ 这个接口用于获取镜像的layer\n5. 镜像在本地的存储  镜像默认在系统中的存储位置在/var/lib/docker\n  这里我们单独选择一个镜像golang:1.16.6来看\n 5.1 镜像的digest 镜像的digest即为镜像manifest文件的sha256值，当镜像内容发生变化，即其中的layer发生了变化，则其layer的sha256值必然发生变化，而相应的包含layer哈希值的manifest必然也会发生变化，这样就保证了digest能唯一对应一个镜像。\n5.2 repositories.json repositories.json中记录了和本地image相关的repository信息，主要是name和image id的对应关系，当image从registry上被pull下来后，就会更新该文件，其位置在/var/lib/docker/image/overlay2/repositories.json\n$ cat repositories.json | jq { \"Repositories\": { \"golang\": { \"golang:1.16.6\": \"sha256:028d102f774acfd5d9a17d60dc321add40bea5cc6f06e0a84fd3aca1bb4c2b12\", \"golang@sha256:4544ae57fc735d7e415603d194d9fb09589b8ad7acd4d66e928eabfb1ed85ff1\": \"sha256:028d102f774acfd5d9a17d60dc321add40bea5cc6f06e0a84fd3aca1bb4c2b12\", }, ... }, } 记住golang:1.16.6的digest为028d102f774acfd5d9a17d60dc321add40bea5cc6f06e0a84fd3aca1bb4c2b12，记住前三个字母就可以了028\n5.3 配置文件（image config） 在从服务器获取image时，会先获取manifest，然后从manifest中拿到config的hash，从而获取config，保存在/var/lib/docker/image/overlay2/imagedb/content/sha256，文件名就是image id\n$ cat 028d102f774acfd5d9a17d60dc321add40bea5cc6f06e0a84fd3aca1bb4c2b12 | jq { ... \"rootfs\": { \"type\": \"layers\", \"diff_ids\": [ \"sha256:afa3e488a0ee76983343f8aa759e4b7b898db65b715eb90abc81c181388374e3\", \"sha256:4b0edb23340c111e75557748161eed3ca159584871569ce7ec9b659e1db201b4\", \"sha256:5a9a65095453efb15a9b378a3c1e7699e8004744ecd6dd519bdbabd0ca9d2efc\", \"sha256:ad83f0aa5c0abe35b7711f226037a5557292d479c21635b3522e1e5a41e3ce23\", \"sha256:d1c59e37fbfc7294184d6fbe4ff8e1690d9119b6233f91af5ad0a4b36e45dff7\", \"sha256:e46b2fd4e4eadc0ee107417c66e968f417e0759fd7d625ab6f0537ba02c1c868\", \"sha256:9672a02ff8cffb302a4c5cef60f8b36cbbe9709a5ba78b7d0ce56db3219c5e51\" ] } } 这里要注意的时，如果image存在多个层，即diff_ids数组长度大于一，则diff_ids[0]是UnionFS最底层，diff_ids[-1]是UnionFS最高层。\n5.4 layer的diff_id和digest的对应关系 layer的diff_id存在image的配置文件中，而layer的digest存在image的manifest中，他们的对应关系被存储在了/var/lib/docker/image/overlay2/distribution目录下：\n. ├── diffid-by-digest │ └── sha256 └── v2metadata-by-diffid └── sha256   diffid-by-digest： 存放digest到diffid的对应关系\n  v2metadata-by-diffid： 存放diffid到digest的对应关系\n  查看mysql最上层layer的digest:\n$ cd /var/lib/docker/image/overlay2/distribution/v2metadata-by-diffid/sha256 $ cat 9672a02ff8cffb302a4c5cef60f8b36cbbe9709a5ba78b7d0ce56db3219c5e51 | jq # sha256:967...是golang:1.16.6的最上层layer [ { \"Digest\": \"sha256:ff36ba4656980ea99a067c8a9b39f210a4da82badccaa2bae27317e711985668\", \"SourceRepository\": \"docker.io/library/golang\", \"HMAC\": \"\" } ] 5.5 layer元数据 从image config中我们可以得到diff_ids，从而得到image各个层的sha256值，这时我们可以到/var/lib/docker/image/overlay2/layerdb/sha256去查看这些层，例如golang:1.16.6的最底层sha256为afa3e488a0ee76983343f8aa759e4b7b898db65b715eb90abc81c181388374e3：\n$ cat /var/lib/docker/image/overlay2/layerdb/sha256/afa3e488a0ee76983343f8aa759e4b7b898db65b715eb90abc81c181388374e3 $ tree . ├── cache-id ├── diff ├── size └── tar-split.json.gz 但在查看第二层的时候发现：\n$ cd 4b0edb23340c111e75557748161eed3ca159584871569ce7ec9b659e1db201b4 bash: cd: 4b0edb23340c111e75557748161eed3ca159584871569ce7ec9b659e1db201b4: 没有那个文件或目录 这是因为docker使用了chainID的方式去保存这些layer，简单来说就是chainID=sha256sum(H(chainID), diffid)，因此golang:1.16.6的第二层为：\n$ echo -n \"sha256:afa3e488a0ee76983343f8aa759e4b7b898db65b715eb90abc81c181388374e3 sha256:4b0edb23340c111e75557748161eed3ca159584871569ce7ec9b659e1db201b4\" | sha256sum - c21ff68b02e7caf277f5d356e8b323a95e8d3969dd1ab0d9f60e7c8b4a01c874 - 这时候查看c21ff68b02e7caf277f5d356e8b323a95e8d3969dd1ab0d9f60e7c8b4a01c874:\n$ cd c21ff68b02e7caf277f5d356e8b323a95e8d3969dd1ab0d9f60e7c8b4a01c874 $ tree . ├── cache-id ├── diff ├── parent ├── size └── tar-split.json.gz 以此类推，我们可以找到任意一层。\n在每一层中，一般包含5个文件：\n cache-id是docker下载layer的时候在本地生成的一个随机uuid，指向真正存放layer文件的地方 diff文件存放layer的diffid parent文件存放当前layer的父layer的diffid，而由于最底层layer没有parent，因此它没有这个文件 size当前layer的大小，单位是字节 tar-split.json.gz，layer压缩包的split文件，通过这个文件可以还原layer的tar包  打印出golang:1.16.6第二层的cache-id:\n$ cat cache-id 40a11a2b4f594bcccbe2cbb6cd3e6fa4a3c2f8427817f43bbade4331173611d2 5.6 layer数据 layer数据在/var/lib/docker/overlay2/\n通过我们刚才打印的golang:1.16.6第二层的cache-id，可以在这里找到golang:1.16.6第二层的文件：\n$ cd /var/lib/docker/overlay2/40a11a2b4f594bcccbe2cbb6cd3e6fa4a3c2f8427817f43bbade4331173611d2 $ tree . ├── committed ├── diff ├── link ├── lower └── work diff文件夹中就是这一层相对于下层修改的文件。\n5.7 manifest文件 manifest里面包含的内容就是对config和layer的sha256 + media type描述，目的就是为了下载config和layer，等image下载完成后，manifest的使命就完成了，里面的信息对于image的本地管理来说没什么用，因此本地并没与单独对manifest进行存储。\nReferences https://cloud.tencent.com/developer/article/1769020\nhttps://yeasy.gitbook.io/docker_practice/image/list\nhttps://www.jianshu.com/p/3ba255463047\nhttps://staight.github.io/2019/10/04/%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0-overlay2/\nhttps://www.jianshu.com/p/3826859a6d6e\nhttps://time.geekbang.org/column/article/318173\nhttps://jvns.ca/blog/2019/11/18/how-containers-work--overlayfs/\nhttps://vividcode.cc/oci-image-spec-introduction/\nhttps://segmentfault.com/a/1190000009309276\nhttps://github.com/opencontainers/image-spec\nhttps://github.com/containers/skopeo\nhttps://docs.docker.com/registry/spec/api/#pulling-an-image\n","wordCount":"804","inLanguage":"en","datePublished":"2022-07-10T00:00:00Z","dateModified":"2022-07-10T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/container/%E6%A6%82%E8%A7%88%E5%AE%B9%E5%99%A8%E7%AF%87%E4%B8%80%E9%95%9C%E5%83%8F/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>概览容器篇一：镜像</h1><div class=post-meta><span title="2022-07-10 00:00:00 +0000 UTC">July 10, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e5%88%86%e5%b1%82%e7%9a%84%e9%95%9c%e5%83%8f aria-label="1. 分层的镜像">1. 分层的镜像</a></li><li><a href=#2-image%e5%88%86%e5%b1%82%e7%9a%84%e5%9f%ba%e7%a1%80unionfs aria-label="2. image分层的基础：UnionFS">2. image分层的基础：UnionFS</a></li><li><a href=#3-%e9%95%9c%e5%83%8f%e7%9a%84%e7%bb%84%e6%88%90 aria-label="3. 镜像的组成">3. 镜像的组成</a><ul><li><a href=#31-media-type aria-label="3.1 Media Type">3.1 Media Type</a></li><li><a href=#32-filesystem-layer aria-label="3.2 FileSystem Layer">3.2 FileSystem Layer</a></li><li><a href=#33-image-config aria-label="3.3 Image Config">3.3 Image Config</a></li><li><a href=#34-image-manifest aria-label="3.4 Image Manifest">3.4 Image Manifest</a></li><li><a href=#35-image-index aria-label="3.5 Image Index">3.5 Image Index</a></li><li><a href=#36-%e9%95%9c%e5%83%8flayout aria-label="3.6 镜像layout">3.6 镜像layout</a></li></ul></li><li><a href=#4-%e4%bb%8e%e8%bf%9c%e7%a8%8b%e8%8e%b7%e5%8f%96%e9%95%9c%e5%83%8f%e7%9a%84%e8%bf%87%e7%a8%8b aria-label="4. 从远程获取镜像的过程">4. 从远程获取镜像的过程</a></li><li><a href=#5-%e9%95%9c%e5%83%8f%e5%9c%a8%e6%9c%ac%e5%9c%b0%e7%9a%84%e5%ad%98%e5%82%a8 aria-label="5. 镜像在本地的存储">5. 镜像在本地的存储</a><ul><li><a href=#51-%e9%95%9c%e5%83%8f%e7%9a%84digest aria-label="5.1 镜像的digest">5.1 镜像的digest</a></li><li><a href=#52-repositoriesjson aria-label="5.2 repositories.json">5.2 repositories.json</a></li><li><a href=#53-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6image-config aria-label="5.3 配置文件（image config）">5.3 配置文件（image config）</a></li><li><a href=#54-layer%e7%9a%84diff_id%e5%92%8cdigest%e7%9a%84%e5%af%b9%e5%ba%94%e5%85%b3%e7%b3%bb aria-label="5.4 layer的diff_id和digest的对应关系">5.4 layer的diff_id和digest的对应关系</a></li><li><a href=#55-layer%e5%85%83%e6%95%b0%e6%8d%ae aria-label="5.5 layer元数据">5.5 layer元数据</a></li><li><a href=#56-layer%e6%95%b0%e6%8d%ae aria-label="5.6 layer数据">5.6 layer数据</a></li><li><a href=#57-manifest%e6%96%87%e4%bb%b6 aria-label="5.7 manifest文件">5.7 manifest文件</a></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><h2 id=1-分层的镜像>1. 分层的镜像<a hidden class=anchor aria-hidden=true href=#1-分层的镜像>#</a></h2><p>在我们启动一个容器之前，通常需要下载这个容器对应的镜像，以这个镜像为基础启动容器。镜像中包含了对应的程序的二进制文件与其所依赖的文件，程序在启动后看到的rootfs只是这个镜像中存在的文件。这样，我们就可以为容器中的进程提供一个干净的文件系统。</p><p>创建一个镜像（<code>image</code>）的最简单方法是使用Dockerfile。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> scratch</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> hello /<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;/hello&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p><code>scratch</code>是docker为我们提供的一个空镜像，我们可以在此基础上构建任何我们想要的镜像。</p><p>在书写<code>Dockerfile</code>时，想必你听说过这么一句话，<em>不要在Dockerfile中创建太多层</em>.</p><p>在Dockerfile中，每一个指令都会创建一个新的“层”，这里的层，指的是UnionFS中的一个文件目录。当我们创建了过多的层，会导致镜像体积变大，除此之外，Union FS 也会有最大层数限制。</p><p>因此对于如下的Dockerfile文件写法，应尽量避免：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> debian:stretch</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get update<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt-get install -y gcc libc6-dev make wget<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> wget -O redis.tar.gz <span style=color:#e6db74>&#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir -p /usr/src/redis<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> make -C /usr/src/redis<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> make -C /usr/src/redis install<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>可优化为如下写法</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> debian:stretch</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> set -x; buildDeps<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;gcc libc6-dev make wget&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> apt-get update <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> apt-get install -y $buildDeps <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> wget -O redis.tar.gz <span style=color:#e6db74>&#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> mkdir -p /usr/src/redis <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> make -C /usr/src/redis <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> make -C /usr/src/redis install <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> rm -rf /var/lib/apt/lists/* <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> rm redis.tar.gz <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> rm -r /usr/src/redis <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> apt-get purge -y --auto-remove $buildDeps<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>这里的原理有点类似于Redis的AOF日志重写。</p><p>为什么要将镜像分为很多层，而不是像系统镜像那样打包为一个ISO文件。</p><p>不同的镜像，其所需的文件存在重复，如果对每个镜像都单独复制一份，会导致镜像过于臃肿，浪费磁盘空间，也会占用大量网络资源下载镜像文件。</p><p>例如我们有100个服务都需要依赖于ubuntu18.04环境，如果我们需要为这些服务制作镜像，显然不可能真的将ubuntu18.04的所有文件复制100份，最好的办法是机器上只存在一份这样的文件，每个容器都来复用它，这就需要使用UnionFS。</p><h2 id=2-image分层的基础unionfs>2. image分层的基础：UnionFS<a hidden class=anchor aria-hidden=true href=#2-image分层的基础unionfs>#</a></h2><p>UnionFS称：联合挂载。其最主要的功能是将多个目录挂载在同一个目录下。</p><p>前面说到，对于100个都需要Ubuntu18.04环境的服务，最好的办法是在机器上提供一份ubuntu18.04环境文件，所有的服务都来依赖这一份文件。</p><p>但这就产生了另一个问题：如果某一个服务需要对ubuntu18.04中的某个文件进行修改，或是在这之上产生新的文件，那么其他同样依赖于这个环境的服务可能会被影响。</p><p>这就需要用到UnionFS的特性。</p><p>目前docker使用的UnionFS实现是OverlayFS.下面通过一个小实验来掌握overlay的基本特性：</p><p>执行以下脚本</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>
umount ./merged
rm upper lower merged work -r

mkdir upper lower merged work
echo <span style=color:#e6db74>&#34;I&#39;m from lower!&#34;</span> &gt; lower/in_lower.txt
echo <span style=color:#e6db74>&#34;I&#39;m from upper!&#34;</span> &gt; upper/in_upper.txt
<span style=color:#75715e># `in_both` is in both directories</span>
echo <span style=color:#e6db74>&#34;I&#39;m from lower!&#34;</span> &gt; lower/in_both.txt
echo <span style=color:#e6db74>&#34;I&#39;m from upper!&#34;</span> &gt; upper/in_both.txt

sudo mount -t overlay overlay <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> -o lowerdir<span style=color:#f92672>=</span>./lower,upperdir<span style=color:#f92672>=</span>./upper,workdir<span style=color:#f92672>=</span>./work <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> ./merged
</code></pre></div><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220710170306.png alt=20220710170306></p><p>OverlayFS 的一个 mount 命令牵涉到四类目录，分别是 lower，upper，merged 和 work，</p><ul><li><p>&ldquo;lower/"，也就是被 mount 两层目录中底下的这层（lowerdir）。在 OverlayFS 中，最底下这一层里的文件是不会被修改的，你可以认为它是只读的。OverlayFS 支持多个 lowerdir。</p></li><li><p>&ldquo;upper/"，它是被 mount 两层目录中上面的这层 （upperdir）。在 OverlayFS 中，如果有文件的创建，修改，删除操作，那么都会在这一层反映出来，它是可读写的。</p></li><li><p>&ldquo;merged&rdquo; ，是挂载点（mount point）目录，也是用户看到的目录，用户的实际文件操作在这里进行。</p></li><li><p>&ldquo;work/"，是一个存放临时文件的目录，OverlayFS 中如果有文件修改，就会在中间过程中临时存放文件到这里。并未表现在图中。</p></li></ul><p>如果lower和upper中存在同名文件，那么不会显示lower中的文件。</p><p>对于以下三种文件操作：</p><ol><li><p>新建文件。这个文件将会出现在upper目录中。</p></li><li><p>删除文件。如果我们删除"in_upper.txt&rdquo;，那么这个文件会在 upper/ 目录中消失。如果删除"in_lower.txt&rdquo;, 在 lower/ 目录里的"in_lower.txt"文件不会有变化，只是在 upper/ 目录中增加了一个特殊文件来告诉 OverlayFS，&ldquo;in_lower.txt&rsquo;这个文件不能出现在 merged/ 里了，这就表示它已经被删除了。</p></li><li><p>修改文件。如果修改"in_lower.txt&rdquo;，那么就会在 upper/ 目录中新建一个"in_lower.txt"文件，包含更新的内容，而在 lower/ 中的原来的实际文件"in_lower.txt"不会改变。</p></li></ol><p>所有的更改都不会反映到lowerdir上，因此容器的镜像文件中各层正好作为 OverlayFS 的 lowerdir 的目录，然后加上一个空的 upperdir 一起挂载好后，就组成了容器的文件系统。</p><p>同时，overlayfs还支持挂载多个lower目录，这样就实现了镜像的多个层。</p><p>以下是一个正在运行的容器他的UnionFS挂载情况：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#e6db74>&#34;GraphDriver&#34;</span><span style=color:#960050;background-color:#1e0010>:</span> {
  <span style=color:#f92672>&#34;Data&#34;</span>: {
    <span style=color:#f92672>&#34;LowerDir&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/overlay2/94809845e9decf34968235fe45bc9d66780a6c2f1929e6aeace43c62ae8a8473-init/diff:/var/lib/docker/overlay2/c95ef099ca18c9b33ff36907bb94c28f3c81a9758058b1698ae438fc88552ac7/diff:/var/lib/docker/overlay2/84cc0780b885789c335f30a784fde4355bfc11b4b9c538da0d6be665d0e87f74/diff:/var/lib/docker/overlay2/94ab5f531aa05c31918599de4a947b6af18488a5bd9f62186060aa32a0938677/diff:/var/lib/docker/overlay2/4154cfa0480d3be6d22ecd4b52225798d8c7d2f349602d36a821fd310318f19e/diff&#34;</span>,
    <span style=color:#f92672>&#34;MergedDir&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/overlay2/94809845e9decf34968235fe45bc9d66780a6c2f1929e6aeace43c62ae8a8473/merged&#34;</span>,
    <span style=color:#f92672>&#34;UpperDir&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/overlay2/94809845e9decf34968235fe45bc9d66780a6c2f1929e6aeace43c62ae8a8473/diff&#34;</span>,
    <span style=color:#f92672>&#34;WorkDir&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/overlay2/94809845e9decf34968235fe45bc9d66780a6c2f1929e6aeace43c62ae8a8473/work&#34;</span>
    },
    <span style=color:#f92672>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;overlay2&#34;</span>
}<span style=color:#960050;background-color:#1e0010>,</span>
</code></pre></div><h2 id=3-镜像的组成>3. 镜像的组成<a hidden class=anchor aria-hidden=true href=#3-镜像的组成>#</a></h2><p>docker对镜像的管理是根据<a href=https://github.com/opencontainers/image-spec>OCI标准</a>来的，根据OCI标准，一个image可以分为以下四个部分：</p><ul><li><code>Image Index</code>: image index是个json文件，用于使image能支持多个平台和多tag。</li><li><code>Image Manifest</code>: manifest是一个json文件，这个文件包含了对filesystem layers和image config的描述。</li><li><code>Image Config</code>: image config就是一个json文件，这个json文件包含了对这个image的描述。</li><li><code>FileSystem Layer</code>: Filesystem Layer包含了文件系统的信息，即该image包含了哪些文件/目录，以及它们的属性和数据。</li></ul><p>它们之间的关系如下：</p><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220811093358.png alt=20220811093358></p><h3 id=31-media-type>3.1 Media Type<a hidden class=anchor aria-hidden=true href=#31-media-type>#</a></h3><p>Media Type, 媒体类型。</p><p>在OCI标准中，不同的文件对应不同的media type。其对应关系如下：</p><table><thead><tr><th>Media Type</th><th>说明</th></tr></thead><tbody><tr><td>application/vnd.oci.descriptor.v1+json</td><td>Content Descriptor 内容描述文件</td></tr><tr><td>application/vnd.oci.layout.header.v1+json</td><td>OCI Layout 布局描述文件</td></tr><tr><td>application/vnd.oci.image.index.v1+json</td><td>Image Index 高层次的镜像元信息文件</td></tr><tr><td>application/vnd.oci.image.manifest.v1+json</td><td>Image Manifest 镜像元信息文件</td></tr><tr><td>application/vnd.oci.image.config.v1+json</td><td>Image Config 镜像配置文件</td></tr><tr><td>application/vnd.oci.image.layer.v1.tar</td><td>Image Layer 镜像层文件</td></tr><tr><td>application/vnd.oci.image.layer.v1.tar+gzip</td><td>Image Layer 镜像层文件gzip压缩</td></tr><tr><td>application/vnd.oci.image.layer.nondistributable.v1.tar</td><td>Image Layer 非内容寻址管理</td></tr><tr><td>application/vnd.oci.image.layer.nondistributable.v1.tar+gzip</td><td>Image Layer, gzip压缩 非内容寻址管理</td></tr></tbody></table><h3 id=32-filesystem-layer>3.2 FileSystem Layer<a hidden class=anchor aria-hidden=true href=#32-filesystem-layer>#</a></h3><p>每个filesystem layer都包含了在上一个layer上的改动情况，主要包含三方面的内容：</p><ul><li><p>变化类型：是增加、修改还是删除了文件</p></li><li><p>文件类型：每个变化发生在哪种文件类型上</p></li><li><p>文件属性：文件的修改时间、用户ID、组ID、RWX权限等</p></li></ul><p>根据我们上面所介绍的UnionFS，很容易理解。</p><h3 id=33-image-config>3.3 Image Config<a hidden class=anchor aria-hidden=true href=#33-image-config>#</a></h3><p>Config包含了对镜像文件的描述，它是一个json文件，示例如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:#f92672>&#34;created&#34;</span>: <span style=color:#e6db74>&#34;2015-10-31T22:22:56.015925234Z&#34;</span>,
    <span style=color:#f92672>&#34;author&#34;</span>: <span style=color:#e6db74>&#34;Alyssa P. Hacker &lt;alyspdev@example.com&gt;&#34;</span>,
    <span style=color:#f92672>&#34;architecture&#34;</span>: <span style=color:#e6db74>&#34;amd64&#34;</span>,
    <span style=color:#f92672>&#34;os&#34;</span>: <span style=color:#e6db74>&#34;linux&#34;</span>,
    <span style=color:#f92672>&#34;config&#34;</span>: {
        <span style=color:#f92672>&#34;User&#34;</span>: <span style=color:#e6db74>&#34;alice&#34;</span>,
        <span style=color:#f92672>&#34;ExposedPorts&#34;</span>: {
            <span style=color:#f92672>&#34;8080/tcp&#34;</span>: {}
        },
        <span style=color:#f92672>&#34;Env&#34;</span>: [
            <span style=color:#e6db74>&#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&#34;</span>,
            <span style=color:#e6db74>&#34;FOO=oci_is_a&#34;</span>,
            <span style=color:#e6db74>&#34;BAR=well_written_spec&#34;</span>
        ],
        <span style=color:#960050;background-color:#1e0010>...</span>
    },
    <span style=color:#f92672>&#34;rootfs&#34;</span>: {
      <span style=color:#f92672>&#34;diff_ids&#34;</span>: [
        <span style=color:#e6db74>&#34;sha256:c6f988f4874bb0add23a778f753c65efe992244e148a1d2ec2a8b664fb66bbd1&#34;</span>,
        <span style=color:#e6db74>&#34;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&#34;</span>
      ],
      <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;layers&#34;</span>
    },
    <span style=color:#f92672>&#34;history&#34;</span>: [
        <span style=color:#960050;background-color:#1e0010>...</span>
    ]
}
</code></pre></div><p>其中大部分是可选参数，必须的参数有：</p><ul><li>architecture: CPU架构</li><li>os： 镜像在什么操作系统上运行</li><li>rootfs：指定了image所包含的filesystem layers，type的值必须是layers，diff_ids包含了layer的列表（顺序排列），每一个sha256就是每层layer对应tar包的sha256码<ul><li>type： type的值必须是layers</li><li>diff_ids: 每层layer包的哈希值的列表</li></ul></li></ul><p>其他都是可选参数，见名知意</p><h3 id=34-image-manifest>3.4 Image Manifest<a hidden class=anchor aria-hidden=true href=#34-image-manifest>#</a></h3><p>Image Manifest为特定架构和操作系统的单个容器镜像提供配置和一系列的layer。</p><p>Manifest 的三大主要目标：</p><ul><li><p>内容可寻址（通过 hash 算法为镜像和它的组件生成唯一ID）</p></li><li><p>支持多种平台的架构镜像（由一个更上层的 manifest 说明包含的镜像 manifests 其具体平台的版本情况）</p></li><li><p>能被解析成为 OCI 运行时规范</p></li></ul><p>示例如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#f92672>&#34;schemaVersion&#34;</span>: <span style=color:#ae81ff>2</span>,
  <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
  <span style=color:#f92672>&#34;config&#34;</span>: {
    <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.config.v1+json&#34;</span>,
    <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>7023</span>,
    <span style=color:#f92672>&#34;digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:b5b2b2c507a0944348e0303114d8d93aaaa081732b86451d9bce1f432a537bc7&#34;</span>
  },
  <span style=color:#f92672>&#34;layers&#34;</span>: [
    {
      <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;</span>,
      <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>32654</span>,
      <span style=color:#f92672>&#34;digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:9834876dcfb05cb167a5c24953eba58c4ac89b1adf57f28f2f9d09af107ee8f0&#34;</span>
    },
    {
      <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;</span>,
      <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>16724</span>,
      <span style=color:#f92672>&#34;digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:3c3a4604a545cdc127456d94e421cd355bca5b528f4a9c1905b15da2eb4a4c6b&#34;</span>
    },
    {
      <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;</span>,
      <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>73109</span>,
      <span style=color:#f92672>&#34;digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:ec4b8955958665577945c89419d1af06b5f7636b4ac3da7f12184802ad867736&#34;</span>
    }
  ],
  <span style=color:#f92672>&#34;annotations&#34;</span>: {
    <span style=color:#f92672>&#34;com.example.key1&#34;</span>: <span style=color:#e6db74>&#34;value1&#34;</span>,
    <span style=color:#f92672>&#34;com.example.key2&#34;</span>: <span style=color:#e6db74>&#34;value2&#34;</span>
  }
}
</code></pre></div><p>从上面的json文件中可以看出，manifest中包含对config的描述，包括其mediaType， size，digest等，这里的digest就是config文件的sha256值，可以看出manifest与config的一对一对应关系。而layer中则指明了这个manifest包含哪些层，manifest与layer是一对多关系。</p><h3 id=35-image-index>3.5 Image Index<a hidden class=anchor aria-hidden=true href=#35-image-index>#</a></h3><p>Image Index指向一个特定manifests的更高层manifest，用于支持多平台。index是可选的。</p><p>示例如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#f92672>&#34;schemaVersion&#34;</span>: <span style=color:#ae81ff>2</span>,
  <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.index.v1+json&#34;</span>,
  <span style=color:#f92672>&#34;manifests&#34;</span>: [
    {
      <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
      <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>7143</span>,
      <span style=color:#f92672>&#34;digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f&#34;</span>,
      <span style=color:#f92672>&#34;platform&#34;</span>: {
        <span style=color:#f92672>&#34;architecture&#34;</span>: <span style=color:#e6db74>&#34;ppc64le&#34;</span>,
        <span style=color:#f92672>&#34;os&#34;</span>: <span style=color:#e6db74>&#34;linux&#34;</span>
      }
    },
    {
      <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
      <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>7682</span>,
      <span style=color:#f92672>&#34;digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:5b0bcabd1ed22e9fb1310cf6c2dec7cdef19f0ad69efa1f392e94a4333501270&#34;</span>,
      <span style=color:#f92672>&#34;platform&#34;</span>: {
        <span style=color:#f92672>&#34;architecture&#34;</span>: <span style=color:#e6db74>&#34;amd64&#34;</span>,
        <span style=color:#f92672>&#34;os&#34;</span>: <span style=color:#e6db74>&#34;linux&#34;</span>
      }
    }
  ],
  <span style=color:#f92672>&#34;annotations&#34;</span>: {
    <span style=color:#f92672>&#34;com.example.key1&#34;</span>: <span style=color:#e6db74>&#34;value1&#34;</span>,
    <span style=color:#f92672>&#34;com.example.key2&#34;</span>: <span style=color:#e6db74>&#34;value2&#34;</span>
  }
}
</code></pre></div><p>index文件包含了对image中所有manifest的描述，相当于一个manifest列表，包括每个manifest的media type，文件大小，sha256码，支持的平台以及平台特殊的配置。</p><p>比如ubuntu想让它的image支持amd64和arm64平台，于是它在两个平台上都编译好相应的包，然后将两个平台的layer都放到这个image的filesystem layers里面，然后写两个config文件和两个manifest文件，再加上这样一个描述不同平台manifest的index文件，就可以让这个image支持两个平台了，两个平台的用户可以使用同样的命令得到自己平台想要的那些layer。</p><h3 id=36-镜像layout>3.6 镜像layout<a hidden class=anchor aria-hidden=true href=#36-镜像layout>#</a></h3><p>镜像的布局包含以下内容：</p><ul><li>blobs：内容寻址的块文件，目录必须存在，但是可以为空</li><li>oci-layout: 必须存在的json对象，必须包含<code>imageLayoutVersion</code>字段</li><li>index.json: 必须存在的JSON格式，文件中必须包含镜像Index的基本属性</li></ul><p>可以查看hello-world镜像的内容：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ yay -S skopeo <span style=color:#75715e># 安装skopeo</span>

$ skopeo copy docker://hello-world oci:hello-world <span style=color:#75715e># 利用skopeo下载hello-world镜像</span>

$ tree -L <span style=color:#ae81ff>3</span> hello-world
hello-world
├── blobs
│   └── sha256
│       ├── 2db29710123e3e53a794f2694094b9b4338aa9ee5c40b930cb8063a1be392c54
│       ├── 75ab15a4973c91d13d02b8346763142ad26095e155ca756c79ee3a4aa792991f
│       └── 811f3caa888b1ee5310e2135cfd3fe36b42e233fe0d76d9798ebd324621238b9
├── index.json
└── oci-layout
</code></pre></div><p>index.json</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#f92672>&#34;schemaVersion&#34;</span>: <span style=color:#ae81ff>2</span>,
  <span style=color:#f92672>&#34;manifests&#34;</span>: [
    {
      <span style=color:#f92672>&#34;mediaType&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
      <span style=color:#f92672>&#34;digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:75ab15a4973c91d13d02b8346763142ad26095e155ca756c79ee3a4aa792991f&#34;</span>,
      <span style=color:#f92672>&#34;size&#34;</span>: <span style=color:#ae81ff>402</span>
    }
  ]
}
</code></pre></div><p>oci-layout</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:#f92672>&#34;imageLayoutVersion&#34;</span>: <span style=color:#e6db74>&#34;1.0.0&#34;</span>
}
</code></pre></div><h2 id=4-从远程获取镜像的过程>4. 从远程获取镜像的过程<a hidden class=anchor aria-hidden=true href=#4-从远程获取镜像的过程>#</a></h2><ul><li><p>docker发送image的名称+tag（或者digest）给registry服务器，服务器根据收到的image的名称+tag（或者digest），找到相应image的manifest，然后将manifest返回给docker</p></li><li><p>docker得到manifest后，读取里面image配置文件的digest(sha256)，这个sha256码就是image的ID</p></li><li><p>根据ID在本地找有没有存在同样ID的image，有的话就不用继续下载了</p></li><li><p>如果没有，那么会给registry服务器发请求（里面包含配置文件的sha256和media type），拿到image的配置文件（Image Config）</p></li><li><p>根据配置文件中的diff_ids（每个diffid对应一个layer tar包的sha256，tar包相当于layer的原始格式），在本地找对应的layer是否存在</p></li><li><p>如果layer不存在，则根据manifest里面layer的sha256和media type去服务器拿相应的layer（相当去拿压缩格式的包）。</p></li><li><p>拿到后进行解压，并检查解压后tar包的sha256能否和配置文件（Image Config）中的diff_id对的上，对不上说明有问题，下载失败</p></li><li><p>根据docker所用的后台文件系统类型，解压tar包并放到指定的目录</p></li><li><p>等所有的layer都下载完成后，整个image下载完成，就可以使用了</p></li></ul><p>上面的过程涉及到两个接口：</p><pre><code>GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;
</code></pre><p>其中为镜像名称，可能包含tag或digest。</p><p>这个接口用于获取镜像的manifest。</p><pre><code>GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;
</code></pre><p>这个接口用于获取镜像的layer</p><h2 id=5-镜像在本地的存储>5. 镜像在本地的存储<a hidden class=anchor aria-hidden=true href=#5-镜像在本地的存储>#</a></h2><blockquote><p>镜像默认在系统中的存储位置在<code>/var/lib/docker</code></p></blockquote><blockquote><p>这里我们单独选择一个镜像<code>golang:1.16.6</code>来看</p></blockquote><h3 id=51-镜像的digest>5.1 镜像的digest<a hidden class=anchor aria-hidden=true href=#51-镜像的digest>#</a></h3><p>镜像的digest即为镜像manifest文件的sha256值，当镜像内容发生变化，即其中的layer发生了变化，则其layer的sha256值必然发生变化，而相应的包含layer哈希值的manifest必然也会发生变化，这样就保证了digest能唯一对应一个镜像。</p><h3 id=52-repositoriesjson>5.2 repositories.json<a hidden class=anchor aria-hidden=true href=#52-repositoriesjson>#</a></h3><p>repositories.json中记录了和本地image相关的repository信息，主要是name和image id的对应关系，当image从registry上被pull下来后，就会更新该文件，其位置在<code>/var/lib/docker/image/overlay2/repositories.json</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cat repositories.json | jq
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;Repositories&#34;</span>: <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;golang&#34;</span>: <span style=color:#f92672>{</span>
      <span style=color:#e6db74>&#34;golang:1.16.6&#34;</span>: <span style=color:#e6db74>&#34;sha256:028d102f774acfd5d9a17d60dc321add40bea5cc6f06e0a84fd3aca1bb4c2b12&#34;</span>,
      <span style=color:#e6db74>&#34;golang@sha256:4544ae57fc735d7e415603d194d9fb09589b8ad7acd4d66e928eabfb1ed85ff1&#34;</span>: <span style=color:#e6db74>&#34;sha256:028d102f774acfd5d9a17d60dc321add40bea5cc6f06e0a84fd3aca1bb4c2b12&#34;</span>,
    <span style=color:#f92672>}</span>,
    ...
  <span style=color:#f92672>}</span>,
<span style=color:#f92672>}</span>
</code></pre></div><p>记住golang:1.16.6的digest为<code>028d102f774acfd5d9a17d60dc321add40bea5cc6f06e0a84fd3aca1bb4c2b12</code>，记住前三个字母就可以了<code>028</code></p><h3 id=53-配置文件image-config>5.3 配置文件（image config）<a hidden class=anchor aria-hidden=true href=#53-配置文件image-config>#</a></h3><p>在从服务器获取image时，会先获取manifest，然后从manifest中拿到config的hash，从而获取config，保存在<code>/var/lib/docker/image/overlay2/imagedb/content/sha256</code>，文件名就是image id</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cat 028d102f774acfd5d9a17d60dc321add40bea5cc6f06e0a84fd3aca1bb4c2b12 | jq
<span style=color:#f92672>{</span>
  ...
  <span style=color:#e6db74>&#34;rootfs&#34;</span>: <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;layers&#34;</span>,
    <span style=color:#e6db74>&#34;diff_ids&#34;</span>: <span style=color:#f92672>[</span>
      <span style=color:#e6db74>&#34;sha256:afa3e488a0ee76983343f8aa759e4b7b898db65b715eb90abc81c181388374e3&#34;</span>,
      <span style=color:#e6db74>&#34;sha256:4b0edb23340c111e75557748161eed3ca159584871569ce7ec9b659e1db201b4&#34;</span>,
      <span style=color:#e6db74>&#34;sha256:5a9a65095453efb15a9b378a3c1e7699e8004744ecd6dd519bdbabd0ca9d2efc&#34;</span>,
      <span style=color:#e6db74>&#34;sha256:ad83f0aa5c0abe35b7711f226037a5557292d479c21635b3522e1e5a41e3ce23&#34;</span>,
      <span style=color:#e6db74>&#34;sha256:d1c59e37fbfc7294184d6fbe4ff8e1690d9119b6233f91af5ad0a4b36e45dff7&#34;</span>,
      <span style=color:#e6db74>&#34;sha256:e46b2fd4e4eadc0ee107417c66e968f417e0759fd7d625ab6f0537ba02c1c868&#34;</span>,
      <span style=color:#e6db74>&#34;sha256:9672a02ff8cffb302a4c5cef60f8b36cbbe9709a5ba78b7d0ce56db3219c5e51&#34;</span>
    <span style=color:#f92672>]</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>这里要注意的时，如果image存在多个层，即diff_ids数组长度大于一，则<code>diff_ids[0]</code>是UnionFS最底层，<code>diff_ids[-1]</code>是UnionFS最高层。</p><h3 id=54-layer的diff_id和digest的对应关系>5.4 layer的diff_id和digest的对应关系<a hidden class=anchor aria-hidden=true href=#54-layer的diff_id和digest的对应关系>#</a></h3><p>layer的diff_id存在image的配置文件中，而layer的digest存在image的manifest中，他们的对应关系被存储在了<code>/var/lib/docker/image/overlay2/distribution</code>目录下：</p><pre><code>.
├── diffid-by-digest
│   └── sha256
└── v2metadata-by-diffid
    └── sha256
</code></pre><ul><li><p>diffid-by-digest： 存放digest到diffid的对应关系</p></li><li><p>v2metadata-by-diffid： 存放diffid到digest的对应关系</p></li></ul><p>查看mysql最上层layer的digest:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cd /var/lib/docker/image/overlay2/distribution/v2metadata-by-diffid/sha256
$ cat 9672a02ff8cffb302a4c5cef60f8b36cbbe9709a5ba78b7d0ce56db3219c5e51 | jq <span style=color:#75715e># sha256:967...是golang:1.16.6的最上层layer</span>
<span style=color:#f92672>[</span>
  <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;Digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:ff36ba4656980ea99a067c8a9b39f210a4da82badccaa2bae27317e711985668&#34;</span>,
    <span style=color:#e6db74>&#34;SourceRepository&#34;</span>: <span style=color:#e6db74>&#34;docker.io/library/golang&#34;</span>,
    <span style=color:#e6db74>&#34;HMAC&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>]</span>
</code></pre></div><h3 id=55-layer元数据>5.5 layer元数据<a hidden class=anchor aria-hidden=true href=#55-layer元数据>#</a></h3><p>从image config中我们可以得到diff_ids，从而得到image各个层的sha256值，这时我们可以到<code>/var/lib/docker/image/overlay2/layerdb/sha256</code>去查看这些层，例如golang:1.16.6的最底层sha256为<code>afa3e488a0ee76983343f8aa759e4b7b898db65b715eb90abc81c181388374e3</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cat /var/lib/docker/image/overlay2/layerdb/sha256/afa3e488a0ee76983343f8aa759e4b7b898db65b715eb90abc81c181388374e3
$ tree
.
├── cache-id
├── diff
├── size
└── tar-split.json.gz
</code></pre></div><p>但在查看第二层的时候发现：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cd 4b0edb23340c111e75557748161eed3ca159584871569ce7ec9b659e1db201b4
bash: cd: 4b0edb23340c111e75557748161eed3ca159584871569ce7ec9b659e1db201b4: 没有那个文件或目录
</code></pre></div><p>这是因为docker使用了chainID的方式去保存这些layer，简单来说就是<code>chainID=sha256sum(H(chainID), diffid)</code>，因此golang:1.16.6的第二层为：</p><pre><code>$ echo -n &quot;sha256:afa3e488a0ee76983343f8aa759e4b7b898db65b715eb90abc81c181388374e3 sha256:4b0edb23340c111e75557748161eed3ca159584871569ce7ec9b659e1db201b4&quot; | sha256sum -

c21ff68b02e7caf277f5d356e8b323a95e8d3969dd1ab0d9f60e7c8b4a01c874  -
</code></pre><p>这时候查看<code>c21ff68b02e7caf277f5d356e8b323a95e8d3969dd1ab0d9f60e7c8b4a01c874</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cd c21ff68b02e7caf277f5d356e8b323a95e8d3969dd1ab0d9f60e7c8b4a01c874
$ tree
.
├── cache-id
├── diff
├── parent
├── size
└── tar-split.json.gz
</code></pre></div><p>以此类推，我们可以找到任意一层。</p><p>在每一层中，一般包含5个文件：</p><ul><li>cache-id是docker下载layer的时候在本地生成的一个随机uuid，指向真正存放layer文件的地方</li><li>diff文件存放layer的diffid</li><li>parent文件存放当前layer的父layer的diffid，而由于最底层layer没有parent，因此它没有这个文件</li><li>size当前layer的大小，单位是字节</li><li>tar-split.json.gz，layer压缩包的split文件，通过这个文件可以还原layer的tar包</li></ul><p>打印出golang:1.16.6第二层的cache-id:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cat cache-id
40a11a2b4f594bcccbe2cbb6cd3e6fa4a3c2f8427817f43bbade4331173611d2
</code></pre></div><h3 id=56-layer数据>5.6 layer数据<a hidden class=anchor aria-hidden=true href=#56-layer数据>#</a></h3><p>layer数据在<code>/var/lib/docker/overlay2/</code></p><p>通过我们刚才打印的golang:1.16.6第二层的cache-id，可以在这里找到golang:1.16.6第二层的文件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cd /var/lib/docker/overlay2/40a11a2b4f594bcccbe2cbb6cd3e6fa4a3c2f8427817f43bbade4331173611d2
$ tree
.
├── committed
├── diff
├── link
├── lower
└── work
</code></pre></div><p>diff文件夹中就是这一层相对于下层修改的文件。</p><h3 id=57-manifest文件>5.7 manifest文件<a hidden class=anchor aria-hidden=true href=#57-manifest文件>#</a></h3><p>manifest里面包含的内容就是对config和layer的sha256 + media type描述，目的就是为了下载config和layer，等image下载完成后，manifest的使命就完成了，里面的信息对于image的本地管理来说没什么用，因此本地并没与单独对manifest进行存储。</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://cloud.tencent.com/developer/article/1769020>https://cloud.tencent.com/developer/article/1769020</a></p><p><a href=https://yeasy.gitbook.io/docker_practice/image/list>https://yeasy.gitbook.io/docker_practice/image/list</a></p><p><a href=https://www.jianshu.com/p/3ba255463047>https://www.jianshu.com/p/3ba255463047</a></p><p><a href=https://staight.github.io/2019/10/04/%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0-overlay2/>https://staight.github.io/2019/10/04/%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0-overlay2/</a></p><p><a href=https://www.jianshu.com/p/3826859a6d6e>https://www.jianshu.com/p/3826859a6d6e</a></p><p><a href=https://time.geekbang.org/column/article/318173>https://time.geekbang.org/column/article/318173</a></p><p><a href=https://jvns.ca/blog/2019/11/18/how-containers-work--overlayfs/>https://jvns.ca/blog/2019/11/18/how-containers-work--overlayfs/</a></p><p><a href=https://vividcode.cc/oci-image-spec-introduction/>https://vividcode.cc/oci-image-spec-introduction/</a></p><p><a href=https://segmentfault.com/a/1190000009309276>https://segmentfault.com/a/1190000009309276</a></p><p><a href=https://github.com/opencontainers/image-spec>https://github.com/opencontainers/image-spec</a></p><p><a href=https://github.com/containers/skopeo>https://github.com/containers/skopeo</a></p><p><a href=https://docs.docker.com/registry/spec/api/#pulling-an-image>https://docs.docker.com/registry/spec/api/#pulling-an-image</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/docker/>docker</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/container/>container</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/cache/%E6%A6%82%E8%A7%88redis%E7%AF%87%E4%BA%8Caof%E6%97%A5%E5%BF%97/><span class=title>« Prev Page</span><br><span>概览Redis篇二：AOF日志</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/cache/%E6%A6%82%E8%A7%88redis%E7%AF%87%E4%B8%80%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/><span class=title>Next Page »</span><br><span>概览Redis篇一：单线程模型</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>