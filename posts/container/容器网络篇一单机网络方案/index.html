<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>容器网络篇一：单机网络方案 | Linote</title><meta name=keywords content="container,network"><meta name=description content="安装工具：
apt install bridge-utils net-tools 容器与宿主机的通信 创建一个新的网络命名空间，这里模拟容器内部的网络
$ ip netns add net1 # net1为该网络空间（容器内部网络空间）的名称 查看命名空间的iptable， 路由表，设备
$ ip netns exec net1 route # 查看容器内部路由表 Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface $ ip netns exec net1 iptables -L # 查看容器内部iptable Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination $ ip netns exec net1 ip link list # 查看容器内部设备 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 # 目前只有本地回环设备， 并且状态为DOWN（未启动） 创建一对veth，并将veth的一头添加到net1中"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/container/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%AF%87%E4%B8%80%E5%8D%95%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="容器网络篇一：单机网络方案"><meta property="og:description" content="安装工具：
apt install bridge-utils net-tools 容器与宿主机的通信 创建一个新的网络命名空间，这里模拟容器内部的网络
$ ip netns add net1 # net1为该网络空间（容器内部网络空间）的名称 查看命名空间的iptable， 路由表，设备
$ ip netns exec net1 route # 查看容器内部路由表 Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface $ ip netns exec net1 iptables -L # 查看容器内部iptable Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination $ ip netns exec net1 ip link list # 查看容器内部设备 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 # 目前只有本地回环设备， 并且状态为DOWN（未启动） 创建一对veth，并将veth的一头添加到net1中"><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/container/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%AF%87%E4%B8%80%E5%8D%95%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-28T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-28T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="容器网络篇一：单机网络方案"><meta name=twitter:description content="安装工具：
apt install bridge-utils net-tools 容器与宿主机的通信 创建一个新的网络命名空间，这里模拟容器内部的网络
$ ip netns add net1 # net1为该网络空间（容器内部网络空间）的名称 查看命名空间的iptable， 路由表，设备
$ ip netns exec net1 route # 查看容器内部路由表 Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface $ ip netns exec net1 iptables -L # 查看容器内部iptable Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination $ ip netns exec net1 ip link list # 查看容器内部设备 1: lo: <LOOPBACK> mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 # 目前只有本地回环设备， 并且状态为DOWN（未启动） 创建一对veth，并将veth的一头添加到net1中"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"容器网络篇一：单机网络方案","item":"http://yangchnet.github.io/Dessert/posts/container/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%AF%87%E4%B8%80%E5%8D%95%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"容器网络篇一：单机网络方案","name":"容器网络篇一：单机网络方案","description":"安装工具：\napt install bridge-utils net-tools 容器与宿主机的通信 创建一个新的网络命名空间，这里模拟容器内部的网络\n$ ip netns add net1 # net1为该网络空间（容器内部网络空间）的名称 查看命名空间的iptable， 路由表，设备\n$ ip netns exec net1 route # 查看容器内部路由表 Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface $ ip netns exec net1 iptables -L # 查看容器内部iptable Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination $ ip netns exec net1 ip link list # 查看容器内部设备 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 # 目前只有本地回环设备， 并且状态为DOWN（未启动） 创建一对veth，并将veth的一头添加到net1中","keywords":["container","network"],"articleBody":"安装工具：\napt install bridge-utils net-tools 容器与宿主机的通信 创建一个新的网络命名空间，这里模拟容器内部的网络\n$ ip netns add net1 # net1为该网络空间（容器内部网络空间）的名称 查看命名空间的iptable， 路由表，设备\n$ ip netns exec net1 route # 查看容器内部路由表 Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface $ ip netns exec net1 iptables -L # 查看容器内部iptable Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination $ ip netns exec net1 ip link list # 查看容器内部设备 1: lo:  mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 # 目前只有本地回环设备， 并且状态为DOWN（未启动） 创建一对veth，并将veth的一头添加到net1中\n Veth Pair 设备的特点是：它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里。这就使得 Veth Pair 常常被用作连接不同 Network Namespace 的“网线”。\n $ ip link add veth1 type veth peer name veth1_p $ ip link set veth1 netns net1 # veth1设备被移动到容器中 查看主机上当前设备，只能看到veth1_p这个设备了\n$ ip link list | grep veth 1284: veth1_p@if1285:  mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 查看net1容器网络命名空间，veth1在这个空间里面\n$ ip netns exec net1 ip link list 1: lo:  mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 1285: veth1@if1284:  mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 8a:b3:bb:2a:3a:92 brd ff:ff:ff:ff:ff:ff link-netnsid 0 为这对veth配置ip，并启动起来\n$ ip addr add 10.68.0.100/24 dev veth1_p # 配置容器中的veth设备ip $ ip netns exec net1 ip addr add 10.68.0.101/24 dev veth1 $ ip netns exec net1 ip link set dev veth1 up # 启动net1中的设备 $ ip link set dev veth1_p up # 启动宿主机中的设备 分别查看当前启动的网络设备\n$ ifconfig | grep veth1 # 宿主机 veth1_p: flags=4163 mtu 1500 $ ip netns exec net1 ifconfig # 容器 veth1: flags=4163 mtu 1500 inet 192.168.0.101 netmask 255.255.255.0 broadcast 0.0.0.0 inet6 fe80::88b3:bbff:fe2a:3a92 prefixlen 64 scopeid 0x20 ether 8a:b3:bb:2a:3a:92 txqueuelen 1000 (Ethernet) RX packets 57 bytes 7088 (6.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 10 bytes 796 (796.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 测试通信\n$ ip netns exec net1 ping 10.68.0.100 -I veth1 # 从容器内部ping宿主机 PING 10.68.0.100 (10.68.0.100) 来自 10.68.0.101 veth1 56(84) 字节的数据。 64 字节，来自 10.68.0.100: icmp_seq=1 ttl=64 时间=0.040 毫秒 64 字节，来自 10.68.0.100: icmp_seq=2 ttl=64 时间=0.096 毫秒 64 字节，来自 10.68.0.100: icmp_seq=3 ttl=64 时间=0.057 毫秒 64 字节，来自 10.68.0.100: icmp_seq=4 ttl=64 时间=0.070 毫秒 64 字节，来自 10.68.0.100: icmp_seq=5 ttl=64 时间=0.070 毫秒 64 字节，来自 10.68.0.100: icmp_seq=6 ttl=64 时间=0.070 毫秒 ^C --- 10.68.0.100 ping 统计 --- 已发送 6 个包， 已接收 6 个包, 0% packet loss, time 5077ms rtt min/avg/max/mdev = 0.040/0.067/0.096/0.016 ms 宿主机与宿主机上容器成功\n宿主机上多个容器的通信 创建网桥\n 网桥（Bridge）。是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上。\n $ brctl addbr mybridge 设置网桥ip\n$ ip addr add 10.68.0.1/24 dev mybridge 启动网桥\n$ ip link set dev mybridge up 查看网桥\n$ ip addr show mybridge 35: mybridge:  mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 7e:06:1f:5a:53:f5 brd ff:ff:ff:ff:ff:ff inet 10.68.0.1/24 scope global mybridge valid_lft forever preferred_lft forever 将设备插入网桥\n 一旦一张虚拟网卡被“插”在网桥上，它就会变成该网桥的“从设备”。从设备会被“剥夺”调用网络协议栈处理数据包的资格，从而“降级”成为网桥上的一个端口。而这个端口唯一的作用，就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥。\n $ ip link set veth1_p master mybridge 查看是否插入成功\n$ brctl show bridge name\tbridge id\tSTP enabled\tinterfaces mybridge\t8000.7e061f5a53f5\tno\tveth1_p 从veth对的另一端ping网桥\n$ ip netns exec net1 ping 10.68.0.1 -I veth1 PING 10.68.0.1 (10.68.0.1) 来自 10.68.0.101 veth1 56(84) 字节的数据。 64 字节，来自 10.68.0.1: icmp_seq=1 ttl=64 时间=0.051 毫秒 64 字节，来自 10.68.0.1: icmp_seq=2 ttl=64 时间=0.063 毫秒 64 字节，来自 10.68.0.1: icmp_seq=3 ttl=64 时间=0.094 毫秒 ^C --- 10.68.0.1 ping 统计 --- 已发送 3 个包， 已接收 3 个包, 0% packet loss, time 2036ms rtt min/avg/max/mdev = 0.051/0.069/0.094/0.018 ms 查看net1空间中的路由规则\n$ ip netns exec net1 ip route 10.68.0.0/24 dev veth1 proto kernel scope link src 10.68.0.101 设置一条默认路由：\n$ ip netns exec net1 route add default gw 10.68.0.1 dev veth1 当这条默认路由被设置，所有的网络包默认被发往网桥。此时如果有另一个容器网络命名空间，例如net2，其veth设备一端插在网桥上，对应的另一端在net2中，就可以实现从net1到net2的通信。现在为止，已经可以实现在一台宿主机上的两个容器的相互通信。\n容器与外部通信 $ brctl addif mybridge eth0 配置路由和转发\nsysctl net.ipv4.ip_forward=1 现在，应该可以从net1中的veth1向外界发送消息：\n$ ip netns exec net1 ping 8.8.8.8 -I veth1 PING 8.8.8.8 (8.8.8.8) from 10.68.0.101 veth1: 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=2 ttl=62 time=39.5 ms 64 bytes from 8.8.8.8: icmp_seq=3 ttl=62 time=40.5 ms 64 bytes from 8.8.8.8: icmp_seq=4 ttl=62 time=39.3 ms 64 bytes from 8.8.8.8: icmp_seq=5 ttl=62 time=49.9 ms 64 bytes from 8.8.8.8: icmp_seq=6 ttl=62 time=40.3 ms 64 bytes from 8.8.8.8: icmp_seq=7 ttl=62 time=39.1 ms 64 bytes from 8.8.8.8: icmp_seq=8 ttl=62 time=39.1 ms ^C --- 8.8.8.8 ping statistics --- 8 packets transmitted, 7 received, 12.5% packet loss, time 7015ms rtt min/avg/max/mdev = 39.062/41.081/49.859/3.620 ms 现在已经可以实现容器与外部网络环境的相互通信，但是，如何实现不同宿主机上的容器之间互相通信呢？请看下篇。 Refercences Build your own bridgeHow to Configure Network Bridge on Linux? - zenarmor.comhttps://zhuanlan.zhihu.com/p/65566171https://time.geekbang.org/column/article/64948\n","wordCount":"706","inLanguage":"en","datePublished":"2024-02-28T00:00:00Z","dateModified":"2024-02-28T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/container/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%AF%87%E4%B8%80%E5%8D%95%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>容器网络篇一：单机网络方案</h1><div class=post-meta><span title="2024-02-28 00:00:00 +0000 UTC">February 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%ae%b9%e5%99%a8%e4%b8%8e%e5%ae%bf%e4%b8%bb%e6%9c%ba%e7%9a%84%e9%80%9a%e4%bf%a1 aria-label=容器与宿主机的通信>容器与宿主机的通信</a></li><li><a href=#%e5%ae%bf%e4%b8%bb%e6%9c%ba%e4%b8%8a%e5%a4%9a%e4%b8%aa%e5%ae%b9%e5%99%a8%e7%9a%84%e9%80%9a%e4%bf%a1 aria-label=宿主机上多个容器的通信>宿主机上多个容器的通信</a></li><li><a href=#%e5%ae%b9%e5%99%a8%e4%b8%8e%e5%a4%96%e9%83%a8%e9%80%9a%e4%bf%a1 aria-label=容器与外部通信>容器与外部通信</a></li><li><a href=#refercences aria-label=Refercences>Refercences</a></li></ul></div></details></div><div class=post-content><p>安装工具：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>apt install bridge-utils net-tools
</code></pre></div><h1 id=容器与宿主机的通信>容器与宿主机的通信<a hidden class=anchor aria-hidden=true href=#容器与宿主机的通信>#</a></h1><p>创建一个新的网络命名空间，这里模拟容器内部的网络</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip netns add net1  <span style=color:#75715e># net1为该网络空间（容器内部网络空间）的名称</span>
</code></pre></div><p>查看命名空间的iptable， 路由表，设备</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip netns exec net1 route  <span style=color:#75715e># 查看容器内部路由表</span>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface

$ ip netns exec net1 iptables -L <span style=color:#75715e># 查看容器内部iptable</span>
Chain INPUT <span style=color:#f92672>(</span>policy ACCEPT<span style=color:#f92672>)</span>
target     prot opt source               destination         

Chain FORWARD <span style=color:#f92672>(</span>policy ACCEPT<span style=color:#f92672>)</span>
target     prot opt source               destination         

Chain OUTPUT <span style=color:#f92672>(</span>policy ACCEPT<span style=color:#f92672>)</span>
target     prot opt source               destination  

$ ip netns exec net1 ip link list <span style=color:#75715e># 查看容器内部设备</span>
1: lo: &lt;LOOPBACK&gt; mtu <span style=color:#ae81ff>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#ae81ff>1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    <span style=color:#75715e># 目前只有本地回环设备， 并且状态为DOWN（未启动）</span>


</code></pre></div><p>创建一对veth，并将veth的一头添加到net1中</p><blockquote><p>Veth Pair 设备的特点是：它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里。这就使得 Veth Pair 常常被用作连接不同 Network Namespace 的“网线”。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip link add veth1 type veth peer name veth1_p
$ ip link set veth1 netns net1 <span style=color:#75715e># veth1设备被移动到容器中</span>
</code></pre></div><p>查看主机上当前设备，只能看到veth1_p这个设备了</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip link list | grep veth
1284: veth1_p@if1285: &lt;BROADCAST,MULTICAST&gt; mtu <span style=color:#ae81ff>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#ae81ff>1000</span>
</code></pre></div><p>查看net1容器网络命名空间，veth1在这个空间里面</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip netns exec net1 ip link list
1: lo: &lt;LOOPBACK&gt; mtu <span style=color:#ae81ff>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#ae81ff>1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
1285: veth1@if1284: &lt;BROADCAST,MULTICAST&gt; mtu <span style=color:#ae81ff>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#ae81ff>1000</span>
    link/ether 8a:b3:bb:2a:3a:92 brd ff:ff:ff:ff:ff:ff link-netnsid <span style=color:#ae81ff>0</span>
</code></pre></div><p>为这对veth配置ip，并启动起来</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip addr add 10.68.0.100/24 dev veth1_p <span style=color:#75715e># 配置容器中的veth设备ip</span>
$ ip netns exec net1 ip addr add 10.68.0.101/24 dev veth1 
$ ip netns exec net1 ip link set dev veth1 up <span style=color:#75715e># 启动net1中的设备</span>
$ ip link set dev veth1_p up <span style=color:#75715e># 启动宿主机中的设备</span>
</code></pre></div><p>分别查看当前启动的网络设备</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ifconfig | grep veth1 <span style=color:#75715e># 宿主机</span>
veth1_p: flags<span style=color:#f92672>=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span style=color:#ae81ff>1500</span>

$ ip netns exec net1 ifconfig <span style=color:#75715e># 容器</span>
veth1: flags<span style=color:#f92672>=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span style=color:#ae81ff>1500</span>
        inet 192.168.0.101  netmask 255.255.255.0  broadcast 0.0.0.0
        inet6 fe80::88b3:bbff:fe2a:3a92  prefixlen <span style=color:#ae81ff>64</span>  scopeid 0x20&lt;link&gt;
        ether 8a:b3:bb:2a:3a:92  txqueuelen <span style=color:#ae81ff>1000</span>  <span style=color:#f92672>(</span>Ethernet<span style=color:#f92672>)</span>
        RX packets <span style=color:#ae81ff>57</span>  bytes <span style=color:#ae81ff>7088</span> <span style=color:#f92672>(</span>6.9 KiB<span style=color:#f92672>)</span>
        RX errors <span style=color:#ae81ff>0</span>  dropped <span style=color:#ae81ff>0</span>  overruns <span style=color:#ae81ff>0</span>  frame <span style=color:#ae81ff>0</span>
        TX packets <span style=color:#ae81ff>10</span>  bytes <span style=color:#ae81ff>796</span> <span style=color:#f92672>(</span>796.0 B<span style=color:#f92672>)</span>
        TX errors <span style=color:#ae81ff>0</span>  dropped <span style=color:#ae81ff>0</span> overruns <span style=color:#ae81ff>0</span>  carrier <span style=color:#ae81ff>0</span>  collisions <span style=color:#ae81ff>0</span>
</code></pre></div><p>测试通信</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip netns exec net1 ping 10.68.0.100 -I veth1 <span style=color:#75715e># 从容器内部ping宿主机</span>
PING 10.68.0.100 <span style=color:#f92672>(</span>10.68.0.100<span style=color:#f92672>)</span> 来自 10.68.0.101 veth1 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> 字节的数据。
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.100: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.040 毫秒
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.100: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.096 毫秒
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.100: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.057 毫秒
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.100: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.070 毫秒
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.100: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.070 毫秒
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.100: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.070 毫秒
^C
--- 10.68.0.100 ping 统计 ---
已发送 <span style=color:#ae81ff>6</span> 个包， 已接收 <span style=color:#ae81ff>6</span> 个包, 0% packet loss, time 5077ms
rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.040/0.067/0.096/0.016 ms
</code></pre></div><p>宿主机与宿主机上容器成功</p><h1 id=宿主机上多个容器的通信>宿主机上多个容器的通信<a hidden class=anchor aria-hidden=true href=#宿主机上多个容器的通信>#</a></h1><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20240228203631.png alt=20240228203631></p><p>创建网桥</p><blockquote><p>网桥（Bridge）。是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ brctl addbr mybridge
</code></pre></div><p>设置网桥ip</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip addr add 10.68.0.1/24 dev mybridge
</code></pre></div><p>启动网桥</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip link set dev mybridge up
</code></pre></div><p>查看网桥</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip addr show mybridge
35: mybridge: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span style=color:#ae81ff>1500</span> qdisc noqueue state DOWN group default qlen <span style=color:#ae81ff>1000</span>
    link/ether 7e:06:1f:5a:53:f5 brd ff:ff:ff:ff:ff:ff
    inet 10.68.0.1/24 scope global mybridge
       valid_lft forever preferred_lft forever
</code></pre></div><p>将设备插入网桥</p><blockquote><p>一旦一张虚拟网卡被“插”在网桥上，它就会变成该网桥的“从设备”。从设备会被“剥夺”调用网络协议栈处理数据包的资格，从而“降级”成为网桥上的一个端口。而这个端口唯一的作用，就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip link set veth1_p master mybridge
</code></pre></div><p>查看是否插入成功</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ brctl show
bridge name	bridge id		STP enabled	interfaces
mybridge		8000.7e061f5a53f5	no		veth1_p
</code></pre></div><p>从veth对的另一端ping网桥</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip netns exec net1 ping 10.68.0.1 -I veth1
PING 10.68.0.1 <span style=color:#f92672>(</span>10.68.0.1<span style=color:#f92672>)</span> 来自 10.68.0.101 veth1 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> 字节的数据。
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.051 毫秒
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.063 毫秒
<span style=color:#ae81ff>64</span> 字节，来自 10.68.0.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> 时间<span style=color:#f92672>=</span>0.094 毫秒
^C
--- 10.68.0.1 ping 统计 ---
已发送 <span style=color:#ae81ff>3</span> 个包， 已接收 <span style=color:#ae81ff>3</span> 个包, 0% packet loss, time 2036ms
rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.051/0.069/0.094/0.018 ms
</code></pre></div><p>查看net1空间中的路由规则</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip netns exec net1 ip route
10.68.0.0/24 dev veth1 proto kernel scope link src 10.68.0.101 
</code></pre></div><p>设置一条默认路由：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip netns exec net1 route add default gw 10.68.0.1 dev veth1
</code></pre></div><p>当这条默认路由被设置，所有的网络包默认被发往网桥。此时如果有另一个容器网络命名空间，例如net2，其veth设备一端插在网桥上，对应的另一端在net2中，就可以实现从net1到net2的通信。现在为止，已经可以实现在一台宿主机上的两个容器的相互通信。</p><h1 id=容器与外部通信>容器与外部通信<a hidden class=anchor aria-hidden=true href=#容器与外部通信>#</a></h1><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20240228203742.png alt=20240228203742></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ brctl addif mybridge eth0
</code></pre></div><p>配置路由和转发</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sysctl net.ipv4.ip_forward<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</code></pre></div><p>现在，应该可以从net1中的veth1向外界发送消息：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ip netns exec net1 ping 8.8.8.8 -I veth1
PING 8.8.8.8 <span style=color:#f92672>(</span>8.8.8.8<span style=color:#f92672>)</span> from 10.68.0.101 veth1: 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
<span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>62</span> time<span style=color:#f92672>=</span>39.5 ms
<span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>62</span> time<span style=color:#f92672>=</span>40.5 ms
<span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>62</span> time<span style=color:#f92672>=</span>39.3 ms
<span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>62</span> time<span style=color:#f92672>=</span>49.9 ms
<span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>62</span> time<span style=color:#f92672>=</span>40.3 ms
<span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>7</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>62</span> time<span style=color:#f92672>=</span>39.1 ms
<span style=color:#ae81ff>64</span> bytes from 8.8.8.8: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>62</span> time<span style=color:#f92672>=</span>39.1 ms
^C
--- 8.8.8.8 ping statistics ---
<span style=color:#ae81ff>8</span> packets transmitted, <span style=color:#ae81ff>7</span> received, 12.5% packet loss, time 7015ms
rtt min/avg/max/mdev <span style=color:#f92672>=</span> 39.062/41.081/49.859/3.620 ms
</code></pre></div><p>现在已经可以实现容器与外部网络环境的相互通信，但是，如何实现不同宿主机上的容器之间互相通信呢？请看下篇。</p><h1 id=refercences>Refercences<a hidden class=anchor aria-hidden=true href=#refercences>#</a></h1><p><a href=https://docs.docker.com.zh.xy2401.com/v17.09/engine/userguide/networking/default_network/build-bridges/>Build your own bridge</a><a href=https://www.zenarmor.com/docs/linux-tutorials/how-to-configure-network-bridge-on-linux>How to Configure Network Bridge on Linux? - zenarmor.com</a><a href=https://zhuanlan.zhihu.com/p/65566171>https://zhuanlan.zhihu.com/p/65566171</a><a href=https://time.geekbang.org/column/article/64948>https://time.geekbang.org/column/article/64948</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/container/>container</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/network/>network</a></li></ul><nav class=paginav><a class=next href=http://yangchnet.github.io/Dessert/posts/container/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%AF%87%E4%BA%8C%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1%E4%B9%8Bflannel/><span class=title>Next Page »</span><br><span>容器网络篇二：跨主机通信之Flannel</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>