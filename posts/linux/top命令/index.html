<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>top命令 | Linote</title><meta name=keywords content="Linux"><meta name=description content="在使用top命令查看系统状态时，会出现一堆参数，这些参数分别代表什么意思呢？
 第一行 首先打印了当前时间21:11:55，然后是系统已经启动了多久up 4 days, 8:45，我已经4天8小时45分钟没关机了。。
然后当前有3个用户登录3 users，load average是1.47, 1.33, 1.14
load average load average后面有三个值，分别代表过去 1 分钟，5 分钟，15 分钟在这个节点上的 load average.
Load Average 是一种 CPU 资源需求的度量。
举例来说，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的&#34;load average&#34;就是 1+9=10，这个定义对绝大部分的 Unix 系统都适用。
对于 Linux 来说，如果只考虑 CPU 的资源，Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程，这个定义也是成立的。
对于load average的理解有以下三点：
  不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目。
  计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到&#34;load average&#34;上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU 个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是&#34;load average&#34;的值。"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/linux/top%E5%91%BD%E4%BB%A4/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="top命令"><meta property="og:description" content="在使用top命令查看系统状态时，会出现一堆参数，这些参数分别代表什么意思呢？
 第一行 首先打印了当前时间21:11:55，然后是系统已经启动了多久up 4 days, 8:45，我已经4天8小时45分钟没关机了。。
然后当前有3个用户登录3 users，load average是1.47, 1.33, 1.14
load average load average后面有三个值，分别代表过去 1 分钟，5 分钟，15 分钟在这个节点上的 load average.
Load Average 是一种 CPU 资源需求的度量。
举例来说，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的&#34;load average&#34;就是 1+9=10，这个定义对绝大部分的 Unix 系统都适用。
对于 Linux 来说，如果只考虑 CPU 的资源，Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程，这个定义也是成立的。
对于load average的理解有以下三点：
  不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目。
  计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到&#34;load average&#34;上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU 个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是&#34;load average&#34;的值。"><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/linux/top%E5%91%BD%E4%BB%A4/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-07T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-07T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="top命令"><meta name=twitter:description content="在使用top命令查看系统状态时，会出现一堆参数，这些参数分别代表什么意思呢？
 第一行 首先打印了当前时间21:11:55，然后是系统已经启动了多久up 4 days, 8:45，我已经4天8小时45分钟没关机了。。
然后当前有3个用户登录3 users，load average是1.47, 1.33, 1.14
load average load average后面有三个值，分别代表过去 1 分钟，5 分钟，15 分钟在这个节点上的 load average.
Load Average 是一种 CPU 资源需求的度量。
举例来说，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的&#34;load average&#34;就是 1+9=10，这个定义对绝大部分的 Unix 系统都适用。
对于 Linux 来说，如果只考虑 CPU 的资源，Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程，这个定义也是成立的。
对于load average的理解有以下三点：
  不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目。
  计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到&#34;load average&#34;上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU 个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是&#34;load average&#34;的值。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"top命令","item":"http://yangchnet.github.io/Dessert/posts/linux/top%E5%91%BD%E4%BB%A4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"top命令","name":"top命令","description":"在使用top命令查看系统状态时，会出现一堆参数，这些参数分别代表什么意思呢？\n 第一行 首先打印了当前时间21:11:55，然后是系统已经启动了多久up 4 days, 8:45，我已经4天8小时45分钟没关机了。。\n然后当前有3个用户登录3 users，load average是1.47, 1.33, 1.14\nload average load average后面有三个值，分别代表过去 1 分钟，5 分钟，15 分钟在这个节点上的 load average.\nLoad Average 是一种 CPU 资源需求的度量。\n举例来说，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的\u0026quot;load average\u0026quot;就是 1+9=10，这个定义对绝大部分的 Unix 系统都适用。\n对于 Linux 来说，如果只考虑 CPU 的资源，Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程，这个定义也是成立的。\n对于load average的理解有以下三点：\n  不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目。\n  计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到\u0026quot;load average\u0026quot;上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU 个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是\u0026quot;load average\u0026quot;的值。","keywords":["Linux"],"articleBody":" 在使用top命令查看系统状态时，会出现一堆参数，这些参数分别代表什么意思呢？\n 第一行 首先打印了当前时间21:11:55，然后是系统已经启动了多久up 4 days, 8:45，我已经4天8小时45分钟没关机了。。\n然后当前有3个用户登录3 users，load average是1.47, 1.33, 1.14\nload average load average后面有三个值，分别代表过去 1 分钟，5 分钟，15 分钟在这个节点上的 load average.\nLoad Average 是一种 CPU 资源需求的度量。\n举例来说，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的\"load average\"就是 1+9=10，这个定义对绝大部分的 Unix 系统都适用。\n对于 Linux 来说，如果只考虑 CPU 的资源，Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程，这个定义也是成立的。\n对于load average的理解有以下三点：\n  不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目。\n  计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到\"load average\"上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU 个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是\"load average\"的值。\n  计算机上的 CPU 满负载的情况下，计算机上的 CPU 已经是满负载了，同时还有更多的进程在排队需要 CPU 资源。这时\"load average\"就不能和 CPU Usage 等同了。\n  比如对于单个 CPU 的系统，CPU Usage 最大只是有 100%，也就 1 个 CPU；而\"load average\"的值可以远远大于 1，因为\"load average\"看的是操作系统中可运行队列中进程的个数。\n要注意的是，平均负载统计了这两种情况的进程：\n  第一种是 Linux 进程调度器中可运行队列（Running Queue）一段时间（1 分钟，5 分钟，15 分钟）的进程平均数。\n  第二种是 Linux 进程调度器中休眠队列（Sleeping Queue）里的一段时间的 TASK_UNINTERRUPTIBLE 状态下的进程平均数。所以，最后的公式就是：Load Average= 可运行队列进程平均数 + 休眠队列中不可打断的进程平均数\n  因此，Load Average= 可运行队列进程平均数 + 休眠队列中不可打断的进程平均数\n第二行 第二行主要记录了当前系统中的进程数量和其状态信息。\n例如当前我的系统中有373个进程totol 373，但只有一个进程正在运行1 running，365个在sleep365 sleep，0个stoped0 stoped，7个为僵尸进程7 zombie\nzombie 状态下 子进程结束时父进程没有调用wait()/waitpid()等待子进程结束，那么就会产生僵尸进程。\n原因是子进程结束时并没有真正退出，而是留下一个僵尸进程的数据结构在系统进程表中，等待父进程清理，如果父进程已经退出则会由init进程接替父进程进行处理（收尸）。之所以要留下一个僵尸进程zombie是因为父进程可能会需要子进程的的某些结果。\n由此可见，如果父进程不作为并且又不退出，就会有大量的僵尸进程，每个僵尸进程会占用进程表的一个位置（slot），如果僵尸进程太多会导致系统无法创建新的进程，因为进程表的容量是有限的。所以当zombie这个指标太大时需要引起我们的注意。\n杀死僵尸进程的方法不是直接对其进行kill，而是去找他的父进程，对其附进程进行kill -9，毕竟，僵尸是杀不死的嘛。。\n第三行 第三行比较复杂，值比较多，先来总体看看：\n us: user 表示用户态的CPU时间比例 sy: system 表示内核态的CPU时间比例 wa: iowait 表示处于IO等待的CPU时间比例 ni: nice 表示运行低优先级进程的CPU时间比例 id: idle 表示空闲CPU时间比例 hi: hard interrupt 表示处理硬中断的CPU时间比例 si: soft interrupt 表示处理软中断的CPU时间比例 st: steal 表示当前系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间比例。  解释一下:\n对于下图，横向为时间轴，上半部分代表系统用户态，下半部分代表系统内核态，假设系统只有一个CPU\n假设一个用户程序开始运行了，那么就对应着第一个\"us\"框，“us\"是\"user\"的缩写，代表 Linux 的用户态 CPU Usage。普通用户程序代码中，只要不是调用系统调用（System Call），这些代码的指令消耗的 CPU 就都属于\"us”。\n当这个用户程序代码中调用了系统调用，比如说 read() 去读取一个文件，这时候这个用户进程就会从用户态切换到内核态。\n内核态 read() 系统调用在读到真正 disk 上的文件前，就会进行一些文件系统层的操作。那么这些代码指令的消耗就属于\"sy\"，这里就对应上面图里的第二个框。“sy\"是 “system\"的缩写，代表内核态 CPU 使用。\n接下来，这个 read() 系统调用会向 Linux 的 Block Layer 发出一个 I/O Request，触发一个真正的磁盘读取操作。\n这时候，这个进程一般会被置为 TASK_UNINTERRUPTIBLE。而 Linux 会把这段时间标示成\"wa”，对应图中的第三个框。“wa\"是\"iowait\"的缩写，代表等待 I/O 的时间，这里的 I/O 是指 Disk I/O。\n紧接着，当磁盘返回数据时，进程在内核态拿到数据，这里仍旧是内核态的 CPU 使用中的\"sy”，也就是图中的第四个框。\n然后，进程再从内核态切换回用户态，在用户态得到文件数据，这里进程又回到用户态的 CPU 使用，“us”，对应图中第五个框。\n好，这里我们假设一下，这个用户进程在读取数据之后，没事可做就休眠了。并且我们可以进一步假设，这时在这个 CPU 上也没有其他需要运行的进程了，那么系统就会进入\"id\"这个步骤，也就是第六个框。“id\"是\"idle\"的缩写，代表系统处于空闲状态。\n如果这时这台机器在网络收到一个网络数据包，网卡就会发出一个中断（interrupt）。相应地，CPU 会响应中断，然后进入中断服务程序。\n这时，CPU 就会进入\"hi”，也就是第七个框。“hi\"是\"hardware irq\"的缩写，代表 CPU 处理硬中断的开销。由于我们的中断服务处理需要关闭中断，所以这个硬中断的时间不能太长。\n但是，发生中断后的工作是必须要完成的，如果这些工作比较耗时那怎么办呢？Linux 中有一个软中断的概念（softirq），它可以完成这些耗时比较长的工作。\n你可以这样理解这个软中断，从网卡收到数据包的大部分工作，都是通过软中断来处理的。那么，CPU 就会进入到第八个框，“si”。这里\"si\"是\"softirq\"的缩写，代表 CPU 处理软中断的开销。\n这里你要注意，无论是\"hi\"还是\"si”，它们的 CPU 时间都不会计入进程的 CPU 时间。这是因为本身它们在处理的时候就不属于任何一个进程。\n除此之外，还有ni，是\"nice\"的缩写，这里表示如果进程的 nice 值是正值（1-19），代表优先级比较低的进程运行时所占用的 CPU。\n还有st，st是\"steal\"的缩写，是在虚拟机里用的一个 CPU 使用类型，表示有多少时间是被同一个宿主机上的其他虚拟机抢走的。\n第四、五行 第4、5行显示的是系统内存使用，单位KiB。totol 表示总内存，free 表示没使用过的内容，used是已经使用的内存。buff表示用于读写磁盘缓存的内存，cache表示用于读写文件缓存的内存,avail表示可用的应用内存。\nSwap： total表示能用的swap总量， free表示剩余，used表示已经使用的，avail表示可用的交换区大小。\n其他 从第6行开始，表示的是具体的进程状态：\n PID 进程ID USER 进程所有者的用户名，例如root PR进程调度优先级 NI进程nice值（优先级），越小的值代表越高的优先级 VIRT 进程使用的虚拟内存 RES 进程使用的物理内存（不包括共享内存） SHR 进程使用的共享内存 CPU 进程使用的CPU占比 MEM 进程使用的内存占比 TIME 进程启动后到现在所用的全部CPU时间 COMMAND 进程的启动命令（默认只显示二进制，top -c能够显示命令行和启动参数）  From https://www.cnblogs.com/makelu/p/11169270.html\nhttps://time.geekbang.org/column/article/311054\n","wordCount":"269","inLanguage":"en","datePublished":"2022-08-07T00:00:00Z","dateModified":"2022-08-07T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/linux/top%E5%91%BD%E4%BB%A4/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>top命令</h1><div class=post-meta><span title="2022-08-07 00:00:00 +0000 UTC">August 7, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%a1%8c aria-label=第一行>第一行</a><ul><li><a href=#load-average aria-label="load average">load average</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%a1%8c aria-label=第二行>第二行</a><ul><li><a href=#zombie-%e7%8a%b6%e6%80%81%e4%b8%8b aria-label="zombie 状态下">zombie 状态下</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e8%a1%8c aria-label=第三行>第三行</a></li><li><a href=#%e7%ac%ac%e5%9b%9b%e4%ba%94%e8%a1%8c aria-label=第四、五行>第四、五行</a></li><li><a href=#%e5%85%b6%e4%bb%96 aria-label=其他>其他</a></li><li><a href=#from aria-label=From>From</a></li></ul></div></details></div><div class=post-content><blockquote><p>在使用top命令查看系统状态时，会出现一堆参数，这些参数分别代表什么意思呢？</p></blockquote><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220807211209.png alt=20220807211209></p><h2 id=第一行>第一行<a hidden class=anchor aria-hidden=true href=#第一行>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/1.png alt=1></p><p>首先打印了当前时间<code>21:11:55</code>，然后是系统已经启动了多久<code>up 4 days, 8:45</code>，我已经4天8小时45分钟没关机了。。</p><p>然后当前有3个用户登录<code>3 users</code>，<code>load average</code>是<code>1.47, 1.33, 1.14</code></p><h3 id=load-average>load average<a hidden class=anchor aria-hidden=true href=#load-average>#</a></h3><p><code>load average</code>后面有三个值，分别代表过去 1 分钟，5 分钟，15 分钟在这个节点上的 <code>load average</code>.</p><p>Load Average 是一种 CPU 资源需求的度量。</p><p>举例来说，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的"load average"就是 1+9=10，这个定义对绝大部分的 Unix 系统都适用。</p><p>对于 Linux 来说，如果只考虑 CPU 的资源，Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程，这个定义也是成立的。</p><p>对于<code>load average</code>的理解有以下三点：</p><ol><li><p>不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目。</p></li><li><p>计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到"load average"上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU 个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是"load average"的值。</p></li><li><p>计算机上的 CPU 满负载的情况下，计算机上的 CPU 已经是满负载了，同时还有更多的进程在排队需要 CPU 资源。这时"load average"就不能和 CPU Usage 等同了。</p></li></ol><p>比如对于单个 CPU 的系统，CPU Usage 最大只是有 100%，也就 1 个 CPU；而"load average"的值可以远远大于 1，因为"load average"看的是操作系统中可运行队列中进程的个数。</p><p>要注意的是，平均负载统计了这两种情况的进程：</p><ul><li><p>第一种是 Linux 进程调度器中可运行队列（Running Queue）一段时间（1 分钟，5 分钟，15 分钟）的进程平均数。</p></li><li><p>第二种是 Linux 进程调度器中休眠队列（Sleeping Queue）里的一段时间的 TASK_UNINTERRUPTIBLE 状态下的进程平均数。所以，最后的公式就是：Load Average= 可运行队列进程平均数 + 休眠队列中不可打断的进程平均数</p></li></ul><p>因此，<code>Load Average= 可运行队列进程平均数 + 休眠队列中不可打断的进程平均数</code></p><h2 id=第二行>第二行<a hidden class=anchor aria-hidden=true href=#第二行>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220807213141.png alt=20220807213141></p><p>第二行主要记录了当前系统中的进程数量和其状态信息。</p><p>例如当前我的系统中有373个进程<code>totol 373</code>，但只有一个进程正在运行<code>1 running</code>，365个在sleep<code>365 sleep</code>，0个stoped<code>0 stoped</code>，7个为僵尸进程<code>7 zombie</code></p><h3 id=zombie-状态下>zombie 状态下<a hidden class=anchor aria-hidden=true href=#zombie-状态下>#</a></h3><p>子进程结束时父进程没有调用wait()/waitpid()等待子进程结束，那么就会产生僵尸进程。</p><p>原因是子进程结束时并没有真正退出，而是留下一个僵尸进程的数据结构在系统进程表中，等待父进程清理，如果父进程已经退出则会由init进程接替父进程进行处理（收尸）。之所以要留下一个僵尸进程<code>zombie</code>是因为父进程可能会需要子进程的的某些结果。</p><p>由此可见，如果父进程不作为并且又不退出，就会有大量的僵尸进程，每个僵尸进程会占用进程表的一个位置（slot），如果僵尸进程太多会导致系统无法创建新的进程，因为进程表的容量是有限的。所以当zombie这个指标太大时需要引起我们的注意。</p><p>杀死僵尸进程的方法不是直接对其进行kill，而是去找他的父进程，对其附进程进行<code>kill -9</code>，毕竟，僵尸是杀不死的嘛。。</p><h2 id=第三行>第三行<a hidden class=anchor aria-hidden=true href=#第三行>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220807213217.png alt=20220807213217></p><p>第三行比较复杂，值比较多，先来总体看看：</p><ul><li><code>us</code>: user 表示用户态的CPU时间比例</li><li><code>sy</code>: system 表示内核态的CPU时间比例</li><li><code>wa</code>: iowait 表示处于IO等待的CPU时间比例</li><li><code>ni</code>: nice 表示运行低优先级进程的CPU时间比例</li><li><code>id</code>: idle 表示空闲CPU时间比例</li><li><code>hi</code>: hard interrupt 表示处理硬中断的CPU时间比例</li><li><code>si</code>: soft interrupt 表示处理软中断的CPU时间比例</li><li><code>st</code>: steal 表示当前系统运行在虚拟机中的时候，被其他虚拟机占用的CPU时间比例。</li></ul><p>解释一下:</p><p>对于下图，横向为时间轴，上半部分代表系统用户态，下半部分代表系统内核态，假设系统只有一个CPU</p><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220807213529.png alt=20220807213529></p><p>假设一个用户程序开始运行了，那么就对应着第一个"us"框，&ldquo;us"是"user"的缩写，代表 Linux 的用户态 CPU Usage。普通用户程序代码中，只要不是调用系统调用（System Call），这些代码的指令消耗的 CPU 就都属于"us&rdquo;。</p><p>当这个用户程序代码中调用了系统调用，比如说 read() 去读取一个文件，这时候这个用户进程就会从用户态切换到内核态。</p><p>内核态 read() 系统调用在读到真正 disk 上的文件前，就会进行一些文件系统层的操作。那么这些代码指令的消耗就属于"sy"，这里就对应上面图里的第二个框。&ldquo;sy"是 &ldquo;system"的缩写，代表内核态 CPU 使用。</p><p>接下来，这个 read() 系统调用会向 Linux 的 Block Layer 发出一个 I/O Request，触发一个真正的磁盘读取操作。</p><p>这时候，这个进程一般会被置为 TASK_UNINTERRUPTIBLE。而 Linux 会把这段时间标示成"wa&rdquo;，对应图中的第三个框。&ldquo;wa"是"iowait"的缩写，代表等待 I/O 的时间，这里的 I/O 是指 Disk I/O。</p><p>紧接着，当磁盘返回数据时，进程在内核态拿到数据，这里仍旧是内核态的 CPU 使用中的"sy&rdquo;，也就是图中的第四个框。</p><p>然后，进程再从内核态切换回用户态，在用户态得到文件数据，这里进程又回到用户态的 CPU 使用，&ldquo;us&rdquo;，对应图中第五个框。</p><p>好，这里我们假设一下，这个用户进程在读取数据之后，没事可做就休眠了。并且我们可以进一步假设，这时在这个 CPU 上也没有其他需要运行的进程了，那么系统就会进入"id"这个步骤，也就是第六个框。&ldquo;id"是"idle"的缩写，代表系统处于空闲状态。</p><p>如果这时这台机器在网络收到一个网络数据包，网卡就会发出一个中断（interrupt）。相应地，CPU 会响应中断，然后进入中断服务程序。</p><p>这时，CPU 就会进入"hi&rdquo;，也就是第七个框。&ldquo;hi"是"hardware irq"的缩写，代表 CPU 处理硬中断的开销。由于我们的中断服务处理需要关闭中断，所以这个硬中断的时间不能太长。</p><p>但是，发生中断后的工作是必须要完成的，如果这些工作比较耗时那怎么办呢？Linux 中有一个软中断的概念（softirq），它可以完成这些耗时比较长的工作。</p><p>你可以这样理解这个软中断，从网卡收到数据包的大部分工作，都是通过软中断来处理的。那么，CPU 就会进入到第八个框，&ldquo;si&rdquo;。这里"si"是"softirq"的缩写，代表 CPU 处理软中断的开销。</p><p>这里你要注意，无论是"hi"还是"si&rdquo;，它们的 CPU 时间都不会计入进程的 CPU 时间。这是因为本身它们在处理的时候就不属于任何一个进程。</p><p>除此之外，还有<code>ni</code>，是"nice"的缩写，这里表示如果进程的 nice 值是正值（1-19），代表优先级比较低的进程运行时所占用的 CPU。</p><p>还有<code>st</code>，<code>st</code>是"steal"的缩写，是在虚拟机里用的一个 CPU 使用类型，表示有多少时间是被同一个宿主机上的其他虚拟机抢走的。</p><h2 id=第四五行>第四、五行<a hidden class=anchor aria-hidden=true href=#第四五行>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220807214515.png alt=20220807214515></p><p>第4、5行显示的是系统内存使用，单位KiB。<code>totol</code> 表示总内存，<code>free</code> 表示没使用过的内容，<code>used</code>是已经使用的内存。<code>buff</code>表示用于读写磁盘缓存的内存，<code>cache</code>表示用于读写文件缓存的内存,<code>avail</code>表示可用的应用内存。</p><p>Swap： <code>total</code>表示能用的swap总量， <code>free</code>表示剩余，<code>used</code>表示已经使用的，<code>avail</code>表示可用的交换区大小。</p><h2 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220807214900.png alt=20220807214900></p><p>从第6行开始，表示的是具体的进程状态：</p><ul><li><code>PID</code> 进程ID</li><li><code>USER</code> 进程所有者的用户名，例如root</li><li><code>PR</code>进程调度优先级</li><li><code>NI</code>进程nice值（优先级），越小的值代表越高的优先级</li><li><code>VIRT</code> 进程使用的虚拟内存</li><li><code>RES</code> 进程使用的物理内存（不包括共享内存）</li><li><code>SHR</code> 进程使用的共享内存</li><li><code>CPU</code> 进程使用的CPU占比</li><li><code>MEM</code> 进程使用的内存占比</li><li><code>TIME</code> 进程启动后到现在所用的全部CPU时间</li><li><code>COMMAND</code> 进程的启动命令（默认只显示二进制，top -c能够显示命令行和启动参数）</li></ul><h2 id=from>From<a hidden class=anchor aria-hidden=true href=#from>#</a></h2><p><a href=https://www.cnblogs.com/makelu/p/11169270.html>https://www.cnblogs.com/makelu/p/11169270.html</a></p><p><a href=https://time.geekbang.org/column/article/311054>https://time.geekbang.org/column/article/311054</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=next href=http://yangchnet.github.io/Dessert/posts/golang/%E8%B5%B0%E8%BF%9Bchan/><span class=title>Next Page »</span><br><span>走进chan</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>