<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Linote</title><meta name=keywords content><meta name=description content="Posts - Linote"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><link rel=alternate type=application/rss+xml href=http://yangchnet.github.io/Dessert/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>runtime篇三：defer</h2></header><section class=entry-content><p>本系列代码基于golang1.19(1e5987635cc8bf99e8a20d240da80bd6f0f793f7)
runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic 1. defer是什么 defer，是一种特殊的机制，在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，多个defer的执行顺序与声明顺序相反。
对于defer的使用及需要注意的地方，可参考defer用法。这里不再讨论。
在golang runtime中，defer被描述为一个结构体：
type _defer struct { started bool // 是否开始执行defer函数 heap bool // 是否分配在堆上 openDefer bool // 是否经过开放编码（open-coded）的优化 sp uintptr // 调用defer时的栈指针 stack pointer pc uintptr // 调用defer函数时的pc值 fn func() // defer关键字传入的函数， 当使用open-coded defer时可为空 _panic *_panic // defer函数中的_panic链表 link *_defer // 在goroutine中的下一个defer，可指向堆或栈 // 如果openDefer为true，则下面的字段将记录具有open-code defer的栈帧和相关的函数。 // 上面的sp将为帧的sp，pc将为defer调用的地址。 fd unsafe....</p></section><footer class=entry-footer><span title="2022-08-12 00:00:00 +0000 UTC">August 12, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to runtime篇三：defer" href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/></a></article><article class=post-entry><header class=entry-header><h2>runtime篇四：panic</h2></header><section class=entry-content><p>本系列代码基于golang1.19(1e5987635cc8bf99e8a20d240da80bd6f0f793f7)
runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic 1. panic的底层结构 panic在runtime中的底层表示是runtime._panic结构体。
type _panic struct { argp unsafe.Pointer // 指向defer调用时参数的指针 arg any // panic参数 link *_panic // 连接到更早的_panic pc uintptr // 程序计数器 sp unsafe.Pointer // 栈指针 recovered bool // 当前panic是否被recover恢复 aborted bool // 当前panic是否被中止 goexit bool // 是否调用了runtime.Goexit } 类似于_defer，panic也被组织成链表结构，多个panic通过link字段连接成一个链表。
在_panic结构体中，pc、sp、goexit三个字段是为了修复runtime.Goexit带来的问题引入的[1].
2. 调用panic 在函数中调用panic时，底层会调用runtime.gopanic，其源码如下：
func gopanic(e any) { gp := getg() // 获取当前g // ....</p></section><footer class=entry-footer><span title="2022-08-12 00:00:00 +0000 UTC">August 12, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to runtime篇四：panic" href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/></a></article><article class=post-entry><header class=entry-header><h2>top命令</h2></header><section class=entry-content><p>在使用top命令查看系统状态时，会出现一堆参数，这些参数分别代表什么意思呢？
第一行 首先打印了当前时间21:11:55，然后是系统已经启动了多久up 4 days, 8:45，我已经4天8小时45分钟没关机了。。
然后当前有3个用户登录3 users，load average是1.47, 1.33, 1.14
load average load average后面有三个值，分别代表过去 1 分钟，5 分钟，15 分钟在这个节点上的 load average.
Load Average 是一种 CPU 资源需求的度量。
举例来说，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的"load average"就是 1+9=10，这个定义对绝大部分的 Unix 系统都适用。
对于 Linux 来说，如果只考虑 CPU 的资源，Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程，这个定义也是成立的。
对于load average的理解有以下三点：
不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目。
计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到"load average"上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU 个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是"load average"的值。...</p></section><footer class=entry-footer><span title="2022-08-07 00:00:00 +0000 UTC">August 7, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to top命令" href=http://yangchnet.github.io/Dessert/posts/linux/top%E5%91%BD%E4%BB%A4/></a></article><article class=post-entry><header class=entry-header><h2>概览容器篇二：容器网络</h2></header><section class=entry-content><p>容器具有自己的Network Namespace.
eht0是这个Network Namespace里的网络接口。而宿主机上也有自己的 eth0，宿主机上的 eth0 对应着真正的物理网卡，可以和外面通讯
要让容器 Network Namespace 中的数据包最终发送到物理网卡上，需要以下两步：
将数据包从容器的 Network Namespace 发送到 Host Network Namespace 上 数据包从宿主机的eth0发送出去 要想让容器从自己的Network Namespace连接到Host Namespace，一般来说就只有两类设备接口，一是veth，另外是macvlan/ipvlan.
veth是一个虚拟的网络设备，一般是成对建立，而且这对设备是相互连接的。当每个设备在不同的 Network Namespaces 的时候，Namespace 之间就可以用这对 veth 设备来进行网络通讯了。
到这里，解决了第一步，下一步需要将数据包从宿主机的eth0发送出去。
Docker 程序在节点上安装完之后，就会自动建立了一个 docker0 的 bridge interface。所以我们只需要把第一步中建立的 veth_host 这个设备，接入到 docker0 这个 bridge 上。
容器和docker0组成了一个子网，docker0上的IP就是这个子网的网关IP。
然后docekr0通过nat或route的方式，经过eth0将数据包向外发送。
Reference https://time.geekbang.org/column/article/323325
http://icyfenix.cn/immutable-infrastructure/network/linux-vnet.html
https://morven.life/posts/networking-4-docker-sigle-host/
https://network.51cto.com/article/708901.html</p></section><footer class=entry-footer><span title="2022-08-07 00:00:00 +0000 UTC">August 7, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 概览容器篇二：容器网络" href=http://yangchnet.github.io/Dessert/posts/cloud/%E6%A6%82%E8%A7%88%E5%AE%B9%E5%99%A8%E7%AF%87%E4%BA%8C%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/></a></article><article class=post-entry><header class=entry-header><h2>runtime篇二：通道</h2></header><section class=entry-content><p>本系列代码基于golang1.19(1e5987635cc8bf99e8a20d240da80bd6f0f793f7)
runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic 1. chan的结构 一个channel长这样：
type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 // chan中元素大小 closed uint32 // 是否关闭 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters lock mutex } channel的字段中，主要可以分为三部分：...</p></section><footer class=entry-footer><span title="2022-08-05 00:00:00 +0000 UTC">August 5, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to runtime篇二：通道" href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/></a></article><article class=post-entry><header class=entry-header><h2>runtime篇一：接口</h2></header><section class=entry-content><p>本系列代码基于golang1.19(1e5987635cc8bf99e8a20d240da80bd6f0f793f7)
runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic 1. 接口的内部结构 type iface struct { tab *itab data unsafe.Pointer } 一个接口是一个iface结构体，其中包含一个itab指针和一个unsafe.Pointer。
概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。
一个itab可以表示一个接口的类型和赋给这个接口的实体类型，即为接口的动态类型，而data所指向的unsafe.Pointer则指向接口的动态值。
近距离来看itab：
type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 其中inter字段描述了接口的类型，_type字段描述了实体类型，hash字段是类型哈希，用于类型匹配，fun字段放置和接口方法对应的具体数据类型的方法地址。
再来看interfacetype
type interfacetype struct { typ _type pkgpath name mhdr []imethod } 其中typ和itab中的_type为同一个值，pkgpath则存储了接口的包名，mhdr则表示接口所定义的函数列表。...</p></section><footer class=entry-footer><span title="2022-08-04 00:00:00 +0000 UTC">August 4, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to runtime篇一：接口" href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/></a></article><article class=post-entry><header class=entry-header><h2>恋爱三分理论</h2></header><section class=entry-content><p>- 第一阶段 接受你的存在 0-1分 - 第二阶段 习惯你的存在 1-2分 - 第三阶段 依赖你的存在 2-3分 0.7以上就可以表白，2分以上可结婚</p></section><footer class=entry-footer><span title="2022-08-04 00:00:00 +0000 UTC">August 4, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 恋爱三分理论" href=http://yangchnet.github.io/Dessert/posts/%E6%9D%82%E8%AE%B0/%E6%81%8B%E7%88%B1%E4%B8%89%E5%88%86%E7%90%86%E8%AE%BA/></a></article><article class=post-entry><header class=entry-header><h2>详解TLS（译）</h2></header><section class=entry-content><p>1. TLS在哪些地方被使用 TLS(Transport Layer Security),是为计算机网络中提供安全通信的密码学协议。
HTTPS = HTTP +　TLS SMTPS = SMTPS + TLS FTPS = FTP + TLS … 2. TLS给我们带来了什么 认证 TLS检查通信双方的身份 借助于非对称加密，TLS保证我们访问的是“真网站”，不是假冒的。 加密 TLS 通过使用对称加密算法对其进行加密来保护交换的数据免受未经授权的访问。 校验 TLS 通过检查消息验证码来识别传输过程中的任何数据更改 3. TLS通信的工作的基本流程 通常，TLS包含2个过程，或者说2个协议。
Handshake Protocol 在这个阶段，客户端和服务端： 协商协议版本 选择加密算法 通过非对称加密算法验证对方身份呢 建立一个共享的对称加密密钥以应用于接下来的通信 Record Protocol 在这个阶段： 所有发出的信息都被上个阶段商定的对称密钥加密 信息被发送到对面 接收方验证信息是否受到篡改 如果未被篡改，信息将被解密 4....</p></section><footer class=entry-footer><span title="2022-07-28 00:00:00 +0000 UTC">July 28, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 详解TLS（译）" href=http://yangchnet.github.io/Dessert/posts/net/%E6%A6%82%E8%BF%B0tls/></a></article><article class=post-entry><header class=entry-header><h2>概览消息队列篇〇：为什么需要消息队列</h2></header><section class=entry-content><p>极客时间《消息队列高手课》笔记
概览消息队列篇〇：为什么需要消息队列 概览消息队列篇一：不同的mq的消息模型 概览消息队列篇二：如何确保消息不丢失 概览消息队列篇三：重复消息的处理 1. 异步处理 对于一个秒杀系统，需要解决的核心问题是，如何利用有限的服务器资源，尽可能多地处理短时间内的海量请求。
处理一个秒杀请求包含了很多步骤：如风险控制、库存锁定、生成订单、短信通知、更新通知数据等。如果没有任何优化，正常的处理流程是：App 将请求发送给网关，依次调用上述 5 个流程，然后将结果返回给 APP。
但上述5个步骤中，只需要风险控制和库存锁定这两步就可以决定秒杀是否成功，对于后续的生成订单、短信通知和更新统计数据等步骤，并不一定要在秒杀请求中处理完成。
所以当服务端完成前面 2 个步骤，确定本次请求的秒杀结果后，就可以马上给用户返回响应，然后把请求的数据放入消息队列中，由消息队列异步地进行后续的操作。
处理一个秒杀请求，从 5 个步骤减少为 2 个步骤，这样不仅响应速度更快，并且在秒杀期间，我们可以把大量的服务器资源用来处理秒杀请求。秒杀结束后再把资源用于处理后面的步骤，充分利用有限的服务器资源处理更多的秒杀请求。
可以看到，在这个场景中，消息队列被用于实现服务的异步处理。
这样做的好处是：
可以更快地返回结果； 减少等待，自然实现了步骤之间的并发，提升系统总体的性能。 2. 流量控制 在用消息队列实现了部分工作的异步处理后，我们还需要考虑如何避免过多的请求压垮我们的秒杀系统。
一个设计健壮的程序有自我保护的能力，也就是说，它应该可以在海量的请求下，还能在自身能力范围内尽可能多地处理请求，拒绝处理不了的请求并且保证自身运行正常。
我们可以使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的。
加入消息队列后，整个秒杀流程变为：
网关在收到请求后，将请求放入请求消息队列； 后端服务从请求消息队列中获取 APP 请求，完成后续秒杀处理过程，然后返回结果。 这种设计的优点是：能根据下游的处理能力自动调节流量，达到“削峰填谷”的作用。但这样做同样是有代价的：
增加了系统调用链环节，导致总体的响应时延变长。 上下游系统都要将同步调用改为异步消息，增加了系统的复杂度。 3. 服务解耦 对于一个电商系统来说，当一个新订单创建时：
支付系统需要发起支付流程； 风控系统需要审核订单的合法性； 客服系统需要给用户发短信告知用户； 经营分析系统需要更新统计数据； …… 这些订单下游的系统都需要实时获得订单数据。随着业务不断发展，这些订单下游系统不断的增加，不断变化，并且每个系统可能只需要订单数据的一个子集，负责订单服务的开发团队不得不花费很大的精力，应对不断增加变化的下游系统，不停地修改调试订单系统与这些下游系统的接口。任何一个下游系统接口变更，都需要订单模块重新进行一次上线，对于一个电商的核心服务来说，这几乎是不可接受的。
所有的电商都选择用消息队列来解决类似的系统耦合过于紧密的问题。引入消息队列后，订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。无论增加、减少下游系统或是下游系统需求如何变化，订单服务都无需做任何更改，实现了订单服务与下游服务的解耦。
其他 作为发布 / 订阅系统实现一个微服务级系统间的观察者模式； 连接流计算任务和数据； 用于将消息广播给大量接收者。 消息队列带来的一些问题 引入消息队列带来的延迟问题； 增加了系统的复杂度； 可能产生数据不一致的问题。</p></section><footer class=entry-footer><span title="2022-07-24 00:00:00 +0000 UTC">July 24, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 概览消息队列篇〇：为什么需要消息队列" href=http://yangchnet.github.io/Dessert/posts/mq/%E6%A6%82%E8%A7%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/></a></article><article class=post-entry><header class=entry-header><h2>概览消息队列篇三：重复消息的处理</h2></header><section class=entry-content><p>极客时间《消息队列高手课》笔记
概览消息队列篇〇：为什么需要消息队列 概览消息队列篇一：不同的mq的消息模型 概览消息队列篇二：如何确保消息不丢失 概览消息队列篇三：重复消息的处理 消息队列本身可以保证消息不重复吗 在 MQTT 协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：
At most once: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。 At least once: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。 Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。 这个服务质量标准不仅适用于 MQTT，对所有的消息队列都是适用的。我们现在常用的绝大部分消息队列提供的服务质量都是 At least once，包括 RocketMQ、RabbitMQ 和 Kafka 都是这样。
也就是说，消息队列很难保证消息不重复
用幂等性解决重复消息问题 一般解决重复消息的办法是，在消费端，让我们消费消息的操作具备幂等性。
一个幂等操作的特点是，其任意多次执行所产生的影响均与一次执行的影响相同。
一个幂等的方法，使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。所以，对于幂等的方法，不用担心重复执行会对系统造成任何改变。
如果我们系统消费消息的业务逻辑具备幂等性，那就不用担心消息重复的问题了，因为同一条消息，消费一次和消费多次对系统的影响是完全一样的。也就可以认为，消费多次等于消费一次。从对系统的影响结果来说：At least once + 幂等消费 = Exactly once。
常用设计幂等操作的方法
利用数据库的唯一约束实现幂等 对于一个转账操作，我们可以设置对于每一个转账单只能进行一次转账操作，这样除第一次操作外其他重复操作都会失败。
基于这个思路，不光是可以使用关系型数据库，只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如，还可以用 Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂等消费。
为更新的数据设置前置条件 如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作。
记录并检查操作 记录并检查操作，也称为“Token 机制或者 GUID（全局唯一 ID）机制”，实现的思路特别简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。
具体的实现方法是，在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。</p></section><footer class=entry-footer><span title="2022-07-24 00:00:00 +0000 UTC">July 24, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 概览消息队列篇三：重复消息的处理" href=http://yangchnet.github.io/Dessert/posts/mq/%E6%A6%82%E8%A7%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87%E4%B8%89%E9%87%8D%E5%A4%8D%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://yangchnet.github.io/Dessert/posts/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>