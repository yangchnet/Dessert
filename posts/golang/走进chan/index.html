<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>走进chan | Linote</title><meta name=keywords content="channel"><meta name=description content="1. chan的结构 一个channel长这样：
type hchan struct { qcount uint // total data in the queue 	dataqsiz uint // size of the circular queue 	buf unsafe.Pointer // points to an array of dataqsiz elements 	elemsize uint16 // chan中元素大小 	closed uint32 // 是否关闭 	elemtype *_type // element type 	sendx uint // send index 	recvx uint // receive index 	recvq waitq // list of recv waiters 	sendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分："><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/golang/%E8%B5%B0%E8%BF%9Bchan/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="走进chan"><meta property="og:description" content="1. chan的结构 一个channel长这样：
type hchan struct { qcount uint // total data in the queue 	dataqsiz uint // size of the circular queue 	buf unsafe.Pointer // points to an array of dataqsiz elements 	elemsize uint16 // chan中元素大小 	closed uint32 // 是否关闭 	elemtype *_type // element type 	sendx uint // send index 	recvx uint // receive index 	recvq waitq // list of recv waiters 	sendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分："><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/golang/%E8%B5%B0%E8%BF%9Bchan/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-05T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-05T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="走进chan"><meta name=twitter:description content="1. chan的结构 一个channel长这样：
type hchan struct { qcount uint // total data in the queue 	dataqsiz uint // size of the circular queue 	buf unsafe.Pointer // points to an array of dataqsiz elements 	elemsize uint16 // chan中元素大小 	closed uint32 // 是否关闭 	elemtype *_type // element type 	sendx uint // send index 	recvx uint // receive index 	recvq waitq // list of recv waiters 	sendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"走进chan","item":"http://yangchnet.github.io/Dessert/posts/golang/%E8%B5%B0%E8%BF%9Bchan/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"走进chan","name":"走进chan","description":"1. chan的结构 一个channel长这样：\ntype hchan struct { qcount uint // total data in the queue \tdataqsiz uint // size of the circular queue \tbuf unsafe.Pointer // points to an array of dataqsiz elements \telemsize uint16 // chan中元素大小 \tclosed uint32 // 是否关闭 \telemtype *_type // element type \tsendx uint // send index \trecvx uint // receive index \trecvq waitq // list of recv waiters \tsendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分：","keywords":["channel"],"articleBody":"1. chan的结构 一个channel长这样：\ntype hchan struct { qcount uint // total data in the queue \tdataqsiz uint // size of the circular queue \tbuf unsafe.Pointer // points to an array of dataqsiz elements \telemsize uint16 // chan中元素大小 \tclosed uint32 // 是否关闭 \telemtype *_type // element type \tsendx uint // send index \trecvx uint // receive index \trecvq waitq // list of recv waiters \tsendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分：\n第一部分是标识channel自身的一些状态和性质，如hchan.closed标识chan是否关闭，hchan.elemsize标识chan中元素的大小、hchan.elemtype标识chan中元素类型；\n第二部分是标识底层循环数组的状态的字段，如hchan.qcount标识当前数组中元素数量、hchan.dataqsiz标识循环数组的大小、hchan.buf是指向底层数组的指针、hchan.sendx标识待发送元素的下标、hchan.recvx标识待接收元素的下标；\n第三部分是存储正等待当前chan的goroutine，如hchan.recvq存储等待接收的goroutine，hchan.sendq存储等待发送的gotoutine\n最后是一个锁，保证了并发安全。\n1.1 如何构造一个chan 通过汇编可以看到，在构造chan时，调用的是runtime.makechan函数，函数如下：\ntype chantype struct { typ _type elem *_type dir uintptr } func makechan(t *chantype, size int) *hchan { elem := t.elem // ...  // 省略部分检查代码  mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem  maxAlloc-hchanSize || size 0 { panic(plainError(\"makechan: size out of range\")) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. \t// buf points into the same allocation, elemtype is persistent. \t// SudoG's are referenced from their owning thread so they can't be collected. \t// TODO(dvyukov,rlh): Rethink when collector can move allocated objects. \tvar c *hchan switch { case mem == 0: // Queue or element size is zero. \tc = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. \tc.buf = c.raceaddr() case elem.ptrdata == 0: // Elements do not contain pointers. \t// Allocate hchan and buf in one call. \tc = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. \tc = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026c.lock, lockRankHchan) if debugChan { print(\"makechan: chan=\", c, \"; elemsize=\", elem.size, \"; dataqsiz=\", size, \"\\n\") } return c } 首先对mem进行了计算，mem是chan中元素所占的空间\nruntime.makechan函数中，受先是一些检查，然后根据chan的长度和elem的类型，会有不同的构造策略：\n 如果是构造一个无缓冲chan，即参数size为0，那么默认分配hchanSize=96字节空间并强制转换为*hchan类型，96字节是一个hchan的大小。然后 如果chan的elem不包含指针，则分配hchanSize+mem空间给chan，并将hchanSize之后的所有空间分配给hchan.buf。 如果chan的elel包含指针，那么直接new一个chan，并为hchan.buf分配meme大小的空间  最后将hchan.elemsize、hchan.elemtype、hchan.dataqsiz进行赋值。\n返回一个hchan的指针，这保证了我们在对channel进行传递时不会进行复制。\n2. chan的发送与接收 chan发送时调用了runtime.chansend1:\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { // 如果chan为nil \tif !block { // 如果不可阻塞 \treturn false // 发送失败 \t} gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) // 可阻塞，goroutine挂起 \tthrow(\"unreachable\") } // 省略部分代码  if !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c) { // 不可阻塞，chan未关闭且已满，则发送失败 \treturn false } var t0 int64 if blockprofilerate  0 { t0 = cputicks() } lock(\u0026c.lock) // 加锁，并发安全  if c.closed != 0 { // 如果chan已经被关闭了 \tunlock(\u0026c.lock) // 解锁 \tpanic(plainError(\"send on closed channel\")) // 向已关闭的chan发送会panic \t} // 如果接收队列中存在goroutine，则不经过hchan.buf，而直接复制到接收端缓冲区 \tif sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send \t// directly to the receiver, bypassing the channel buffer (if any). \tsend(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true } // chan还没满 \tif c.qcount c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. \tqp := chanbuf(c, c.sendx) // 计算存放元素的内存地址 \tif raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) // 将元素复制到buf \tc.sendx++ // 待发送下标+1 \tif c.sendx == c.dataqsiz { // 循环数组 \tc.sendx = 0 } c.qcount++ // 总元素数量+1 \tunlock(\u0026c.lock) // 解锁 \treturn true // 发送成功 \t} // chan满了  if !block { // chan满了，且要求不可阻塞，则直接失败 \tunlock(\u0026c.lock) return false } // 可以阻塞  // 获取当前goroutine指针 \tgp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // 当前goroutine进入chan的待发送队列  atomic.Store8(\u0026gp.parkingOnChan, 1) // 挂起当前goroutine \tgopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) KeepAlive(ep) // 当前goroutine被唤醒了 \tif mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime  0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) if closed { // 被唤醒后发现chan关闭了 \tif c.closed == 0 { throw(\"chansend: spurious wakeup\") } panic(plainError(\"send on closed channel\")) } return true } 上述代码的主要逻辑是：\n 检查会发送失败的情况 加锁  再次检查会发送失败的情况，失败则解锁返回失败 如果有goroutine在等着接收，直接复制给它，解锁返回成功 chan的buf没满，复制到buf中，解锁返回成功 如果chan的buf满了  不可以阻塞，解锁返回失败 可以阻塞，让goroutine进入等待队列并挂起，等待唤醒      如果在发送时发现有等待接收的goroutine，会调用runtime.send将元素复制给等待的goroutine，runtime.send如下：\nfunc send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if raceenabled { if c.dataqsiz == 0 { racesync(c, sg) } else { // Pretend we go through the buffer, even though \t// we copy directly. Note that we need to increment \t// the head/tail locations only when raceenabled. \tracenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz \t} } if sg.elem != nil { sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } TODO\n","wordCount":"731","inLanguage":"en","datePublished":"2022-08-05T00:00:00Z","dateModified":"2022-08-05T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/golang/%E8%B5%B0%E8%BF%9Bchan/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>走进chan</h1><div class=post-meta><span title="2022-08-05 00:00:00 +0000 UTC">August 5, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-chan%e7%9a%84%e7%bb%93%e6%9e%84 aria-label="1. chan的结构">1. chan的结构</a><ul><li><a href=#11-%e5%a6%82%e4%bd%95%e6%9e%84%e9%80%a0%e4%b8%80%e4%b8%aachan aria-label="1.1 如何构造一个chan">1.1 如何构造一个chan</a></li></ul></li><li><a href=#2-chan%e7%9a%84%e5%8f%91%e9%80%81%e4%b8%8e%e6%8e%a5%e6%94%b6 aria-label="2. chan的发送与接收">2. chan的发送与接收</a></li></ul></div></details></div><div class=post-content><h2 id=1-chan的结构>1. chan的结构<a hidden class=anchor aria-hidden=true href=#1-chan的结构>#</a></h2><p>一个channel长这样：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>qcount</span>   <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// total data in the queue
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// size of the circular queue
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>buf</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// points to an array of dataqsiz elements
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// chan中元素大小
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>closed</span>   <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 是否关闭
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span> <span style=color:#75715e>// element type
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sendx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// send index
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>recvx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// receive index
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>recvq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// list of recv waiters
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sendq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// list of send waiters
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
}
</code></pre></div><p>channel的字段中，主要可以分为三部分：</p><p>第一部分是标识channel自身的一些状态和性质，如<code>hchan.closed</code>标识chan是否关闭，<code>hchan.elemsize</code>标识chan中元素的大小、<code>hchan.elemtype</code>标识chan中元素类型；</p><p>第二部分是标识底层循环数组的状态的字段，如<code>hchan.qcount</code>标识当前数组中元素数量、<code>hchan.dataqsiz</code>标识循环数组的大小、<code>hchan.buf</code>是指向底层数组的指针、<code>hchan.sendx</code>标识待发送元素的下标、<code>hchan.recvx</code>标识待接收元素的下标；</p><p>第三部分是存储正等待当前chan的goroutine，如<code>hchan.recvq</code>存储等待接收的goroutine，<code>hchan.sendq</code>存储等待发送的gotoutine</p><p>最后是一个锁，保证了并发安全。</p><h3 id=11-如何构造一个chan>1.1 如何构造一个chan<a hidden class=anchor aria-hidden=true href=#11-如何构造一个chan>#</a></h3><p>通过汇编可以看到，在构造chan时，调用的是<code>runtime.makechan</code>函数，函数如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>chantype</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>typ</span>  <span style=color:#a6e22e>_type</span>
	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
	<span style=color:#a6e22e>dir</span>  <span style=color:#66d9ef>uintptr</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makechan</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>chantype</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> {
	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>

	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 省略部分检查代码
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>size</span>))
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span><span style=color:#f92672>-</span><span style=color:#a6e22e>hchanSize</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#ae81ff>0</span> {
		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;makechan: size out of range&#34;</span>))
	}

	<span style=color:#75715e>// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// buf points into the same allocation, elemtype is persistent.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>
	<span style=color:#66d9ef>switch</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>mem</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
		<span style=color:#75715e>// Queue or element size is zero.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
		<span style=color:#75715e>// Race detector uses this location for synchronization.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>()
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
		<span style=color:#75715e>// Elements do not contain pointers.
</span><span style=color:#75715e></span>		<span style=color:#75715e>// Allocate hchan and buf in one call.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>mem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>c</span>), <span style=color:#a6e22e>hchanSize</span>)
	<span style=color:#66d9ef>default</span>:
		<span style=color:#75715e>// Elements contain pointers.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = new(<span style=color:#a6e22e>hchan</span>)
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
	}

	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemsize</span> = uint16(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span> = <span style=color:#a6e22e>elem</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> = uint(<span style=color:#a6e22e>size</span>)
	<span style=color:#a6e22e>lockInit</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankHchan</span>)

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>debugChan</span> {
		print(<span style=color:#e6db74>&#34;makechan: chan=&#34;</span>, <span style=color:#a6e22e>c</span>, <span style=color:#e6db74>&#34;; elemsize=&#34;</span>, <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>, <span style=color:#e6db74>&#34;; dataqsiz=&#34;</span>, <span style=color:#a6e22e>size</span>, <span style=color:#e6db74>&#34;\n&#34;</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
}
</code></pre></div><p>首先对<code>mem</code>进行了计算，<code>mem</code>是chan中元素所占的空间</p><p><code>runtime.makechan</code>函数中，受先是一些检查，然后根据chan的长度和elem的类型，会有不同的构造策略：</p><ul><li>如果是构造一个无缓冲chan，即参数size为0，那么默认分配<code>hchanSize</code>=96字节空间并强制转换为*hchan类型，96字节是一个hchan的大小。然后</li><li>如果chan的elem不包含指针，则分配<code>hchanSize+mem</code>空间给chan，并将<code>hchanSize</code>之后的所有空间分配给<code>hchan.buf</code>。</li><li>如果chan的elel包含指针，那么直接new一个chan，并为<code>hchan.buf</code>分配<code>meme</code>大小的空间</li></ul><p>最后将<code>hchan.elemsize</code>、<code>hchan.elemtype</code>、<code>hchan.dataqsiz</code>进行赋值。</p><p>返回一个<code>hchan</code>的指针，这保证了我们在对channel进行传递时不会进行复制。</p><h2 id=2-chan的发送与接收>2. chan的发送与接收<a hidden class=anchor aria-hidden=true href=#2-chan的发送与接收>#</a></h2><p>chan发送时调用了<code>runtime.chansend1</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 如果chan为nil
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> { <span style=color:#75715e>// 如果不可阻塞
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>    <span style=color:#75715e>// 发送失败
</span><span style=color:#75715e></span>		}
		<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanSendNilChan</span>, <span style=color:#a6e22e>traceEvGoStop</span>, <span style=color:#ae81ff>2</span>) <span style=color:#75715e>// 可阻塞，goroutine挂起
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
	}

    <span style=color:#75715e>// 省略部分代码
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>full</span>(<span style=color:#a6e22e>c</span>) { <span style=color:#75715e>// 不可阻塞，chan未关闭且已满，则发送失败
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
	}

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t0</span> <span style=color:#66d9ef>int64</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
	}

	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>// 加锁，并发安全
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 如果chan已经被关闭了
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>// 解锁
</span><span style=color:#75715e></span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>)) <span style=color:#75715e>// 向已关闭的chan发送会panic
</span><span style=color:#75715e></span>	}

    <span style=color:#75715e>// 如果接收队列中存在goroutine，则不经过hchan.buf，而直接复制到接收端缓冲区
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#75715e>// Found a waiting receiver. We pass the value we want to send
</span><span style=color:#75715e></span>		<span style=color:#75715e>// directly to the receiver, bypassing the channel buffer (if any).
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
	}

    <span style=color:#75715e>// chan还没满
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &lt; <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
		<span style=color:#75715e>// Space is available in the channel buffer. Enqueue the element to send.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>) <span style=color:#75715e>// 计算存放元素的内存地址
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>, <span style=color:#66d9ef>nil</span>)
		}
		<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>, <span style=color:#a6e22e>ep</span>) <span style=color:#75715e>// 将元素复制到buf
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span><span style=color:#f92672>++</span> <span style=color:#75715e>// 待发送下标+1
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> { <span style=color:#75715e>// 循环数组
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#ae81ff>0</span>
		}
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>++</span> <span style=color:#75715e>// 总元素数量+1
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>// 解锁
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span> <span style=color:#75715e>// 发送成功
</span><span style=color:#75715e></span>	}

    <span style=color:#75715e>// chan满了
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> { <span style=color:#75715e>// chan满了，且要求不可阻塞，则直接失败
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
	}

    <span style=color:#75715e>// 可以阻塞
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 获取当前goroutine指针
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
	}
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>isSelect</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>) <span style=color:#75715e>// 当前goroutine进入chan的待发送队列
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store8</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>parkingOnChan</span>, <span style=color:#ae81ff>1</span>)

    <span style=color:#75715e>// 挂起当前goroutine
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>chanparkcommit</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>waitReasonChanSend</span>, <span style=color:#a6e22e>traceEvGoBlockSend</span>, <span style=color:#ae81ff>2</span>)
	<span style=color:#a6e22e>KeepAlive</span>(<span style=color:#a6e22e>ep</span>)

	<span style=color:#75715e>// 当前goroutine被唤醒了
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
	}
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>closed</span> <span style=color:#f92672>:=</span> !<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
	}
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>closed</span> { <span style=color:#75715e>// 被唤醒后发现chan关闭了
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;chansend: spurious wakeup&#34;</span>)
		}
		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
</code></pre></div><p>上述代码的主要逻辑是：</p><ul><li>检查会发送失败的情况</li><li>加锁<ul><li>再次检查会发送失败的情况，失败则解锁返回失败</li><li>如果有goroutine在等着接收，直接复制给它，解锁返回成功</li><li>chan的buf没满，复制到buf中，解锁返回成功</li><li>如果chan的buf满了<ul><li>不可以阻塞，解锁返回失败</li><li>可以阻塞，让goroutine进入等待队列并挂起，等待唤醒</li></ul></li></ul></li></ul><p>如果在发送时发现有等待接收的goroutine，会调用<code>runtime.send</code>将元素复制给等待的goroutine，<code>runtime.send</code>如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>skip</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>racesync</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>)
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#75715e>// Pretend we go through the buffer, even though
</span><span style=color:#75715e></span>			<span style=color:#75715e>// we copy directly. Note that we need to increment
</span><span style=color:#75715e></span>			<span style=color:#75715e>// the head/tail locations only when raceenabled.
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#66d9ef>nil</span>)
			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#a6e22e>sg</span>)
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
			}
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#75715e>// c.sendx = (c.sendx+1) % c.dataqsiz
</span><span style=color:#75715e></span>		}
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>sendDirect</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>)
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
	<span style=color:#a6e22e>unlockf</span>()
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
	<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
	}
	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>skip</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
}
</code></pre></div><p>TODO</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/channel/>channel</a></li></ul><nav class=paginav><a class=next href=http://yangchnet.github.io/Dessert/posts/%E6%9D%82%E8%AE%B0/%E6%81%8B%E7%88%B1%E4%B8%89%E5%88%86%E7%90%86%E8%AE%BA/><span class=title>Next Page »</span><br><span>恋爱三分理论</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>