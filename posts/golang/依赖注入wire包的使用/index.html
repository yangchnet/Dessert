<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>依赖注入：wire包的使用 | Linote</title><meta name=keywords content="golang,依赖注入,wire"><meta name=description content="官方教程，写的很好，我就不多说了
 Let&rsquo;s learn to use Wire by example. The Wire guide provides thorough documentation of the tool&rsquo;s usage. For readers eager to see Wire applied to a larger server, the guestbook sample in Go Cloud uses Wire to initialize its components. Here we are going to build a small greeter program to understand how to use Wire. The finished product may be found in the same directory as this README."><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/golang/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5wire%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><meta property="og:title" content="依赖注入：wire包的使用"><meta property="og:description" content="官方教程，写的很好，我就不多说了
 Let&rsquo;s learn to use Wire by example. The Wire guide provides thorough documentation of the tool&rsquo;s usage. For readers eager to see Wire applied to a larger server, the guestbook sample in Go Cloud uses Wire to initialize its components. Here we are going to build a small greeter program to understand how to use Wire. The finished product may be found in the same directory as this README."><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/golang/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5wire%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-06T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-06T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="依赖注入：wire包的使用"><meta name=twitter:description content="官方教程，写的很好，我就不多说了
 Let&rsquo;s learn to use Wire by example. The Wire guide provides thorough documentation of the tool&rsquo;s usage. For readers eager to see Wire applied to a larger server, the guestbook sample in Go Cloud uses Wire to initialize its components. Here we are going to build a small greeter program to understand how to use Wire. The finished product may be found in the same directory as this README."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"依赖注入：wire包的使用","item":"http://yangchnet.github.io/Dessert/posts/golang/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5wire%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"依赖注入：wire包的使用","name":"依赖注入：wire包的使用","description":"官方教程，写的很好，我就不多说了\n Let\u0026rsquo;s learn to use Wire by example. The Wire guide provides thorough documentation of the tool\u0026rsquo;s usage. For readers eager to see Wire applied to a larger server, the guestbook sample in Go Cloud uses Wire to initialize its components. Here we are going to build a small greeter program to understand how to use Wire. The finished product may be found in the same directory as this README.","keywords":["golang","依赖注入","wire"],"articleBody":" 官方教程，写的很好，我就不多说了\n Let’s learn to use Wire by example. The Wire guide provides thorough documentation of the tool’s usage. For readers eager to see Wire applied to a larger server, the guestbook sample in Go Cloud uses Wire to initialize its components. Here we are going to build a small greeter program to understand how to use Wire. The finished product may be found in the same directory as this README.\nA First Pass of Building the Greeter Program Let’s create a small program that simulates an event with a greeter greeting guests with a particular message.\nTo start, we will create three types: 1) a message for a greeter, 2) a greeter who conveys that message, and 3) an event that starts with the greeter greeting guests. In this design, we have three struct types:\ntype Message string type Greeter struct { // ... TBD } type Event struct { // ... TBD } The Message type just wraps a string. For now, we will create a simple initializer that always returns a hard-coded message:\nfunc NewMessage() Message { return Message(\"Hi there!\") } Our Greeter will need reference to the Message. So let’s create an initializer for our Greeter as well.\nfunc NewGreeter(m Message) Greeter { return Greeter{Message: m} } type Greeter struct { Message Message // } In the initializer we assign a Message field to Greeter. Now, we can use the Message when we create a Greet method on Greeter:\nfunc (g Greeter) Greet() Message { return g.Message } Next, we need our Event to have a Greeter, so we will create an initializer for it as well.\nfunc NewEvent(g Greeter) Event { return Event{Greeter: g} } type Event struct { Greeter Greeter // } Then we add a method to start the Event:\nfunc (e Event) Start() { msg := e.Greeter.Greet() fmt.Println(msg) } The Start method holds the core of our small application: it tells the greeter to issue a greeting and then prints that message to the screen.\nNow that we have all the components of our application ready, let’s see what it takes to initialize all the components without using Wire. Our main function would look like this:\nfunc main() { message := NewMessage() greeter := NewGreeter(message) event := NewEvent(greeter) event.Start() } First we create a message, then we create a greeter with that message, and finally we create an event with that greeter. With all the initialization done, we’re ready to start our event.\nWe are using the dependency injection design principle. In practice, that means we pass in whatever each component needs. This style of design lends itself to writing easily tested code and makes it easy to swap out one dependency with another.\nUsing Wire to Generate Code One downside to dependency injection is the need for so many initialization steps. Let’s see how we can use Wire to make the process of initializing our components smoother.\nLet’s start by changing our main function to look like this:\nfunc main() { e := InitializeEvent() e.Start() } Next, in a separate file called wire.go we will define InitializeEvent. This is where things get interesting:\n// wire.go  func InitializeEvent() Event { wire.Build(NewEvent, NewGreeter, NewMessage) return Event{} } Rather than go through the trouble of initializing each component in turn and passing it into the next one, we instead have a single call to wire.Build passing in the initializers we want to use. In Wire, initializers are known as “providers,” functions which provide a particular type. We add a zero value for Event as a return value to satisfy the compiler. Note that even if we add values to Event, Wire will ignore them. In fact, the injector’s purpose is to provide information about which providers to use to construct an Event and so we will exclude it from our final binary with a build constraint at the top of the file:\n//+build wireinject  Note, a build constraint requires a blank, trailing line.\nIn Wire parlance, InitializeEvent is an “injector.” Now that we have our injector complete, we are ready to use the wire command line tool.\nInstall the tool with:\ngo get github.com/google/wire/cmd/wire Then in the same directory with the above code, simply run wire. Wire will find the InitializeEvent injector and generate a function whose body is filled out with all the necessary initialization steps. The result will be written to a file named wire_gen.go.\nLet’s take a look at what Wire did for us:\n// wire_gen.go  func InitializeEvent() Event { message := NewMessage() greeter := NewGreeter(message) event := NewEvent(greeter) return event } It looks just like what we wrote above! Now this is a simple example with just three components, so writing the initializer by hand isn’t too painful. Imagine how useful Wire is for components that are much more complex. When working with Wire, we will commit both wire.go and wire_gen.go to source control.\nMaking Changes with Wire To show a small part of how Wire handles more complex setups, let’s refactor our initializer for Event to return an error and see what happens.\nfunc NewEvent(g Greeter) (Event, error) { if g.Grumpy { return Event{}, errors.New(\"could not create event: event greeter is grumpy\") } return Event{Greeter: g}, nil } We’ll say that sometimes a Greeter might be grumpy and so we cannot create an Event. The NewGreeter initializer now looks like this:\nfunc NewGreeter(m Message) Greeter { var grumpy bool if time.Now().Unix()%2 == 0 { grumpy = true } return Greeter{Message: m, Grumpy: grumpy} } We have added a Grumpy field to Greeter struct and if the invocation time of the initializer is an even number of seconds since the Unix epoch, we will create a grumpy greeter instead of a friendly one.\nThe Greet method then becomes:\nfunc (g Greeter) Greet() Message { if g.Grumpy { return Message(\"Go away!\") } return g.Message } Now you see how a grumpy Greeter is no good for an Event. So NewEvent may fail. Our main must now take into account that InitializeEvent may in fact fail:\nfunc main() { e, err := InitializeEvent() if err != nil { fmt.Printf(\"failed to create event: %s\\n\", err) os.Exit(2) } e.Start() } We also need to update InitializeEvent to add an error type to the return value:\n// wire.go  func InitializeEvent() (Event, error) { wire.Build(NewEvent, NewGreeter, NewMessage) return Event{}, nil } With the setup complete, we are ready to invoke the wire command again. Note, that after running wire once to produce a wire_gen.go file, we may also use go generate. Having run the command, our wire_gen.go file looks like this:\n// wire_gen.go  func InitializeEvent() (Event, error) { message := NewMessage() greeter := NewGreeter(message) event, err := NewEvent(greeter) if err != nil { return Event{}, err } return event, nil } Wire has detected that the NewEvent provider may fail and has done the right thing inside the generated code: it checks the error and returns early if one is present.\nChanging the Injector Signature As another improvement, let’s look at how Wire generates code based on the signature of the injector. Presently, we have hard-coded the message inside NewMessage. In practice, it’s much nicer to allow callers to change that message however they see fit. So let’s change InitializeEvent to look like this:\nfunc InitializeEvent(phrase string) (Event, error) { wire.Build(NewEvent, NewGreeter, NewMessage) return Event{}, nil } Now InitializeEvent allows callers to pass in the phrase for a Greeter to use. We also add a phrase argument to NewMessage:\nfunc NewMessage(phrase string) Message { return Message(phrase) } After we run wire again, we will see that the tool has generated an initializer which passes the phrase value as a Message into Greeter. Neat!\n// wire_gen.go  func InitializeEvent(phrase string) (Event, error) { message := NewMessage(phrase) greeter := NewGreeter(message) event, err := NewEvent(greeter) if err != nil { return Event{}, err } return event, nil } Wire inspects the arguments to the injector, sees that we added a string to the list of arguments (e.g., phrase), and likewise sees that among all the providers, NewMessage takes a string, and so it passes phrase into NewMessage.\nCatching Mistakes with Helpful Errors Let’s also look at what happens when Wire detects mistakes in our code and see how Wire’s error messages help us correct any problems.\nFor example, when writing our injector InitializeEvent, let’s say we forget to add a provider for Greeter. Let’s see what happens:\nfunc InitializeEvent(phrase string) (Event, error) { wire.Build(NewEvent, NewMessage) // woops! We forgot to add a provider for Greeter  return Event{}, nil } Running wire, we see the following:\n# wrapping the error across lines for readability $GOPATH/src/github.com/google/wire/_tutorial/wire.go:24:1: inject InitializeEvent: no provider found for github.com/google/wire/_tutorial.Greeter (required by provider of github.com/google/wire/_tutorial.Event) wire: generate failed Wire is telling us some useful information: it cannot find a provider for Greeter. Note that the error message prints out the full path to the Greeter type. It’s also telling us the line number and injector name where the problem occurred: line 24 inside InitializeEvent. In addition, the error message tells us which provider needs a Greeter. It’s the Event type. Once we pass in a provider of Greeter, the problem will be solved.\nAlternatively, what happens if we provide one too many providers to wire.Build?\nfunc NewEventNumber() int { return 1 } func InitializeEvent(phrase string) (Event, error) { // woops! NewEventNumber is unused.  wire.Build(NewEvent, NewGreeter, NewMessage, NewEventNumber) return Event{}, nil } Wire helpfully tells us that we have an unused provider:\n$GOPATH/src/github.com/google/wire/_tutorial/wire.go:24:1: inject InitializeEvent: unused provider \"NewEventNumber\" wire: generate failed Deleting the unused provider from the call to wire.Build resolves the error.\nConclusion Let’s summarize what we have done here. First, we wrote a number of components with corresponding initializers, or providers. Next, we created an injector function, specifying which arguments it receives and which types it returns. Then, we filled in the injector function with a call to wire.Build supplying all necessary providers. Finally, we ran the wire command to generate code that wires up all the different initializers. When we added an argument to the injector and an error return value, running wire again made all the necessary updates to our generated code.\nThe example here is small, but it demonstrates some of the power of Wire, and how it takes much of the pain out of initializing code using dependency injection. Furthermore, using Wire produced code that looks much like what we would otherwise write. There are no bespoke types that commit a user to Wire. Instead it’s just generated code. We may do with it what we will. Finally, another point worth considering is how easy it is to add new dependencies to our component initialization. As long as we tell Wire how to provide (i.e., initialize) a component, we may add that component anywhere in the dependency graph and Wire will handle the rest.\nIn closing, it is worth mentioning that Wire supports a number of additional features not discussed here. Providers may be grouped in provider sets. There is support for binding interfaces, binding values, as well as support for cleanup functions. See the Advanced Features section for more.\n","wordCount":"1855","inLanguage":"en","datePublished":"2021-07-06T00:00:00Z","dateModified":"2021-07-06T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/golang/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5wire%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>依赖注入：wire包的使用</h1><div class=post-meta>July 6, 2021&nbsp;·&nbsp;9 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#a-first-pass-of-building-the-greeter-program aria-label="A First Pass of Building the Greeter Program">A First Pass of Building the Greeter Program</a></li><li><a href=#using-wire-to-generate-code aria-label="Using Wire to Generate Code">Using Wire to Generate Code</a></li><li><a href=#making-changes-with-wire aria-label="Making Changes with Wire">Making Changes with Wire</a></li><li><a href=#changing-the-injector-signature aria-label="Changing the Injector Signature">Changing the Injector Signature</a></li><li><a href=#catching-mistakes-with-helpful-errors aria-label="Catching Mistakes with Helpful Errors">Catching Mistakes with Helpful Errors</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><blockquote><p>官方教程，写的很好，我就不多说了</p></blockquote><p>Let&rsquo;s learn to use Wire by example. The <a href=https://github.com/google/wire/blob/master/docs/guide.md>Wire guide</a> provides thorough
documentation of the tool&rsquo;s usage. For readers eager to see Wire applied to a
larger server, the <a href=https://github.com/google/go-cloud/tree/master/samples/guestbook>guestbook sample in Go Cloud</a> uses Wire to
initialize its components. Here we are going to build a small greeter program to
understand how to use Wire. The finished product may be found in the same
directory as this README.</p><h2 id=a-first-pass-of-building-the-greeter-program>A First Pass of Building the Greeter Program<a hidden class=anchor aria-hidden=true href=#a-first-pass-of-building-the-greeter-program>#</a></h2><p>Let&rsquo;s create a small program that simulates an event with a greeter greeting
guests with a particular message.</p><p>To start, we will create three types: 1) a message for a greeter, 2) a greeter
who conveys that message, and 3) an event that starts with the greeter greeting
guests. In this design, we have three <code>struct</code> types:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Message</span> <span style=color:#66d9ef>string</span>

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Greeter</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#75715e>// ... TBD
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#75715e>// ... TBD
</span><span style=color:#75715e></span>}
</code></pre></div><p>The <code>Message</code> type just wraps a string. For now, we will create a simple
initializer that always returns a hard-coded message:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewMessage</span>() <span style=color:#a6e22e>Message</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Message</span>(<span style=color:#e6db74>&#34;Hi there!&#34;</span>)
}
</code></pre></div><p>Our <code>Greeter</code> will need reference to the <code>Message</code>. So let&rsquo;s create an
initializer for our <code>Greeter</code> as well.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewGreeter</span>(<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>Message</span>) <span style=color:#a6e22e>Greeter</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Greeter</span>{<span style=color:#a6e22e>Message</span>: <span style=color:#a6e22e>m</span>}
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Greeter</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>Message</span> <span style=color:#a6e22e>Message</span> <span style=color:#75715e>// &lt;- adding a Message field
</span><span style=color:#75715e></span>}
</code></pre></div><p>In the initializer we assign a <code>Message</code> field to <code>Greeter</code>. Now, we can use the
<code>Message</code> when we create a <code>Greet</code> method on <code>Greeter</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#a6e22e>Greeter</span>) <span style=color:#a6e22e>Greet</span>() <span style=color:#a6e22e>Message</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Message</span>
}
</code></pre></div><p>Next, we need our <code>Event</code> to have a <code>Greeter</code>, so we will create an initializer
for it as well.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewEvent</span>(<span style=color:#a6e22e>g</span> <span style=color:#a6e22e>Greeter</span>) <span style=color:#a6e22e>Event</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{<span style=color:#a6e22e>Greeter</span>: <span style=color:#a6e22e>g</span>}
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>Greeter</span> <span style=color:#a6e22e>Greeter</span> <span style=color:#75715e>// &lt;- adding a Greeter field
</span><span style=color:#75715e></span>}
</code></pre></div><p>Then we add a method to start the <code>Event</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>Event</span>) <span style=color:#a6e22e>Start</span>() {
    <span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Greeter</span>.<span style=color:#a6e22e>Greet</span>()
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>msg</span>)
}
</code></pre></div><p>The <code>Start</code> method holds the core of our small application: it tells the
greeter to issue a greeting and then prints that message to the screen.</p><p>Now that we have all the components of our application ready, let&rsquo;s see what it
takes to initialize all the components without using Wire. Our main function
would look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>message</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewMessage</span>()
    <span style=color:#a6e22e>greeter</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewGreeter</span>(<span style=color:#a6e22e>message</span>)
    <span style=color:#a6e22e>event</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewEvent</span>(<span style=color:#a6e22e>greeter</span>)

    <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>Start</span>()
}
</code></pre></div><p>First we create a message, then we create a greeter with that message, and
finally we create an event with that greeter. With all the initialization done,
we&rsquo;re ready to start our event.</p><p>We are using the <a href=https://stackoverflow.com/questions/130794/what-is-dependency-injection>dependency injection</a> design principle. In practice, that
means we pass in whatever each component needs. This style of design lends
itself to writing easily tested code and makes it easy to swap out one
dependency with another.</p><h2 id=using-wire-to-generate-code>Using Wire to Generate Code<a hidden class=anchor aria-hidden=true href=#using-wire-to-generate-code>#</a></h2><p>One downside to dependency injection is the need for so many initialization
steps. Let&rsquo;s see how we can use Wire to make the process of initializing our
components smoother.</p><p>Let&rsquo;s start by changing our <code>main</code> function to look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>InitializeEvent</span>()

    <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Start</span>()
}
</code></pre></div><p>Next, in a separate file called <code>wire.go</code> we will define <code>InitializeEvent</code>.
This is where things get interesting:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// wire.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeEvent</span>() <span style=color:#a6e22e>Event</span> {
    <span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>NewEvent</span>, <span style=color:#a6e22e>NewGreeter</span>, <span style=color:#a6e22e>NewMessage</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{}
}
</code></pre></div><p>Rather than go through the trouble of initializing each component in turn and
passing it into the next one, we instead have a single call to <code>wire.Build</code>
passing in the initializers we want to use. In Wire, initializers are known as
&ldquo;providers,&rdquo; functions which provide a particular type. We add a zero value for
<code>Event</code> as a return value to satisfy the compiler. Note that even if we add
values to <code>Event</code>, Wire will ignore them. In fact, the injector&rsquo;s purpose is to
provide information about which providers to use to construct an <code>Event</code> and so
we will exclude it from our final binary with a build constraint at the top of
the file:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>//+build wireinject
</span><span style=color:#75715e></span>
</code></pre></div><p>Note, a <a href=https://godoc.org/go/build#hdr-Build_Constraints>build constraint</a> requires a blank, trailing line.</p><p>In Wire parlance, <code>InitializeEvent</code> is an &ldquo;injector.&rdquo; Now that we have our
injector complete, we are ready to use the <code>wire</code> command line tool.</p><p>Install the tool with:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>go get github.com/google/wire/cmd/wire
</code></pre></div><p>Then in the same directory with the above code, simply run <code>wire</code>. Wire will
find the <code>InitializeEvent</code> injector and generate a function whose body is
filled out with all the necessary initialization steps. The result will be
written to a file named <code>wire_gen.go</code>.</p><p>Let&rsquo;s take a look at what Wire did for us:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// wire_gen.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeEvent</span>() <span style=color:#a6e22e>Event</span> {
    <span style=color:#a6e22e>message</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewMessage</span>()
    <span style=color:#a6e22e>greeter</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewGreeter</span>(<span style=color:#a6e22e>message</span>)
    <span style=color:#a6e22e>event</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewEvent</span>(<span style=color:#a6e22e>greeter</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>event</span>
}
</code></pre></div><p>It looks just like what we wrote above! Now this is a simple example with just
three components, so writing the initializer by hand isn&rsquo;t too painful. Imagine
how useful Wire is for components that are much more complex. When working with
Wire, we will commit both <code>wire.go</code> and <code>wire_gen.go</code> to source control.</p><h2 id=making-changes-with-wire>Making Changes with Wire<a hidden class=anchor aria-hidden=true href=#making-changes-with-wire>#</a></h2><p>To show a small part of how Wire handles more complex setups, let&rsquo;s refactor
our initializer for <code>Event</code> to return an error and see what happens.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewEvent</span>(<span style=color:#a6e22e>g</span> <span style=color:#a6e22e>Greeter</span>) (<span style=color:#a6e22e>Event</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Grumpy</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{}, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;could not create event: event greeter is grumpy&#34;</span>)
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{<span style=color:#a6e22e>Greeter</span>: <span style=color:#a6e22e>g</span>}, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>We&rsquo;ll say that sometimes a <code>Greeter</code> might be grumpy and so we cannot create
an <code>Event</code>. The <code>NewGreeter</code> initializer now looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewGreeter</span>(<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>Message</span>) <span style=color:#a6e22e>Greeter</span> {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>grumpy</span> <span style=color:#66d9ef>bool</span>
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>Unix</span>()<span style=color:#f92672>%</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
        <span style=color:#a6e22e>grumpy</span> = <span style=color:#66d9ef>true</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Greeter</span>{<span style=color:#a6e22e>Message</span>: <span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>Grumpy</span>: <span style=color:#a6e22e>grumpy</span>}
}
</code></pre></div><p>We have added a <code>Grumpy</code> field to <code>Greeter</code> struct and if the invocation time
of the initializer is an even number of seconds since the Unix epoch, we will
create a grumpy greeter instead of a friendly one.</p><p>The <code>Greet</code> method then becomes:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#a6e22e>Greeter</span>) <span style=color:#a6e22e>Greet</span>() <span style=color:#a6e22e>Message</span> {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Grumpy</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Message</span>(<span style=color:#e6db74>&#34;Go away!&#34;</span>)
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Message</span>
}
</code></pre></div><p>Now you see how a grumpy <code>Greeter</code> is no good for an <code>Event</code>. So <code>NewEvent</code> may
fail. Our <code>main</code> must now take into account that <code>InitializeEvent</code> may in fact
fail:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>InitializeEvent</span>()
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;failed to create event: %s\n&#34;</span>, <span style=color:#a6e22e>err</span>)
        <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>2</span>)
    }
    <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Start</span>()
}
</code></pre></div><p>We also need to update <code>InitializeEvent</code> to add an <code>error</code> type to the return value:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// wire.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeEvent</span>() (<span style=color:#a6e22e>Event</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>NewEvent</span>, <span style=color:#a6e22e>NewGreeter</span>, <span style=color:#a6e22e>NewMessage</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{}, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>With the setup complete, we are ready to invoke the <code>wire</code> command again. Note,
that after running <code>wire</code> once to produce a <code>wire_gen.go</code> file, we may also use
<code>go generate</code>. Having run the command, our <code>wire_gen.go</code> file looks like
this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// wire_gen.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeEvent</span>() (<span style=color:#a6e22e>Event</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#a6e22e>message</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewMessage</span>()
    <span style=color:#a6e22e>greeter</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewGreeter</span>(<span style=color:#a6e22e>message</span>)
    <span style=color:#a6e22e>event</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewEvent</span>(<span style=color:#a6e22e>greeter</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{}, <span style=color:#a6e22e>err</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>event</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Wire has detected that the <code>NewEvent</code> provider may fail and has done the right
thing inside the generated code: it checks the error and returns early if one
is present.</p><h2 id=changing-the-injector-signature>Changing the Injector Signature<a hidden class=anchor aria-hidden=true href=#changing-the-injector-signature>#</a></h2><p>As another improvement, let&rsquo;s look at how Wire generates code based on the
signature of the injector. Presently, we have hard-coded the message inside
<code>NewMessage</code>. In practice, it&rsquo;s much nicer to allow callers to change that
message however they see fit. So let&rsquo;s change <code>InitializeEvent</code> to look like
this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeEvent</span>(<span style=color:#a6e22e>phrase</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Event</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>NewEvent</span>, <span style=color:#a6e22e>NewGreeter</span>, <span style=color:#a6e22e>NewMessage</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{}, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Now <code>InitializeEvent</code> allows callers to pass in the <code>phrase</code> for a <code>Greeter</code> to
use. We also add a <code>phrase</code> argument to <code>NewMessage</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewMessage</span>(<span style=color:#a6e22e>phrase</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>Message</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Message</span>(<span style=color:#a6e22e>phrase</span>)
}
</code></pre></div><p>After we run <code>wire</code> again, we will see that the tool has generated an
initializer which passes the <code>phrase</code> value as a <code>Message</code> into <code>Greeter</code>.
Neat!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// wire_gen.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeEvent</span>(<span style=color:#a6e22e>phrase</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Event</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#a6e22e>message</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewMessage</span>(<span style=color:#a6e22e>phrase</span>)
    <span style=color:#a6e22e>greeter</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewGreeter</span>(<span style=color:#a6e22e>message</span>)
    <span style=color:#a6e22e>event</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewEvent</span>(<span style=color:#a6e22e>greeter</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{}, <span style=color:#a6e22e>err</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>event</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Wire inspects the arguments to the injector, sees that we added a string to the
list of arguments (e.g., <code>phrase</code>), and likewise sees that among all the
providers, <code>NewMessage</code> takes a string, and so it passes <code>phrase</code> into
<code>NewMessage</code>.</p><h2 id=catching-mistakes-with-helpful-errors>Catching Mistakes with Helpful Errors<a hidden class=anchor aria-hidden=true href=#catching-mistakes-with-helpful-errors>#</a></h2><p>Let&rsquo;s also look at what happens when Wire detects mistakes in our code and see
how Wire&rsquo;s error messages help us correct any problems.</p><p>For example, when writing our injector <code>InitializeEvent</code>, let&rsquo;s say we forget
to add a provider for <code>Greeter</code>. Let&rsquo;s see what happens:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeEvent</span>(<span style=color:#a6e22e>phrase</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Event</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>NewEvent</span>, <span style=color:#a6e22e>NewMessage</span>) <span style=color:#75715e>// woops! We forgot to add a provider for Greeter
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{}, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Running <code>wire</code>, we see the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e># wrapping the error across lines for readability</span>
$GOPATH/src/github.com/google/wire/_tutorial/wire.go:24:1:
inject InitializeEvent: no provider found <span style=color:#66d9ef>for</span> github.com/google/wire/_tutorial.Greeter
<span style=color:#f92672>(</span>required by provider of github.com/google/wire/_tutorial.Event<span style=color:#f92672>)</span>
wire: generate failed
</code></pre></div><p>Wire is telling us some useful information: it cannot find a provider for
<code>Greeter</code>. Note that the error message prints out the full path to the
<code>Greeter</code> type. It&rsquo;s also telling us the line number and injector name where
the problem occurred: line 24 inside <code>InitializeEvent</code>. In addition, the error
message tells us which provider needs a <code>Greeter</code>. It&rsquo;s the <code>Event</code> type. Once
we pass in a provider of <code>Greeter</code>, the problem will be solved.</p><p>Alternatively, what happens if we provide one too many providers to <code>wire.Build</code>?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewEventNumber</span>() <span style=color:#66d9ef>int</span>  {
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeEvent</span>(<span style=color:#a6e22e>phrase</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>Event</span>, <span style=color:#66d9ef>error</span>) {
     <span style=color:#75715e>// woops! NewEventNumber is unused.
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>NewEvent</span>, <span style=color:#a6e22e>NewGreeter</span>, <span style=color:#a6e22e>NewMessage</span>, <span style=color:#a6e22e>NewEventNumber</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Event</span>{}, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>Wire helpfully tells us that we have an unused provider:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$GOPATH/src/github.com/google/wire/_tutorial/wire.go:24:1:
inject InitializeEvent: unused provider <span style=color:#e6db74>&#34;NewEventNumber&#34;</span>
wire: generate failed
</code></pre></div><p>Deleting the unused provider from the call to <code>wire.Build</code> resolves the error.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Let&rsquo;s summarize what we have done here. First, we wrote a number of components
with corresponding initializers, or providers. Next, we created an injector
function, specifying which arguments it receives and which types it returns.
Then, we filled in the injector function with a call to <code>wire.Build</code> supplying
all necessary providers. Finally, we ran the <code>wire</code> command to generate code
that wires up all the different initializers. When we added an argument to the
injector and an error return value, running <code>wire</code> again made all the necessary
updates to our generated code.</p><p>The example here is small, but it demonstrates some of the power of Wire, and
how it takes much of the pain out of initializing code using dependency
injection. Furthermore, using Wire produced code that looks much like what we
would otherwise write. There are no bespoke types that commit a user to Wire.
Instead it&rsquo;s just generated code. We may do with it what we will. Finally,
another point worth considering is how easy it is to add new dependencies to
our component initialization. As long as we tell Wire how to provide (i.e.,
initialize) a component, we may add that component anywhere in the dependency
graph and Wire will handle the rest.</p><p>In closing, it is worth mentioning that Wire supports a number of additional
features not discussed here. Providers may be grouped in <a href=https://github.com/google/wire/blob/master/docs/guide.md#defining-providers>provider sets</a>.
There is support for <a href=https://github.com/google/wire/blob/master/docs/guide.md#binding-interfaces>binding interfaces</a>, <a href=https://github.com/google/wire/blob/master/docs/guide.md#binding-values>binding
values</a>, as well as support for <a href=https://github.com/google/wire/blob/master/docs/guide.md#cleanup-functions>cleanup functions</a>. See the
<a href=https://github.com/google/wire/blob/master/docs/guide.md#advanced-features>Advanced Features</a> section for more.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/golang/>golang</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/>依赖注入</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/wire/>wire</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8F%AF%E4%BF%A1%E5%AD%98%E8%AF%81/><span class=title>« Prev Page</span><br><span>可信存证</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/c++/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/><span class=title>Next Page »</span><br><span>堆和栈的区别</span></a></nav><div class=share-buttons><div class=bshare-custom><a title=分享到微信 class=bshare-weixin></a><a title=分享到QQ好友 class=bshare-qqim></a><a title=分享到复制网址 class=bshare-clipboard></a><a title=分享到QQ空间 class=bshare-qzone></a><a title=分享到新浪微博 class=bshare-sinaminiblog></a><a title=分享到电子邮件 class=bshare-email></a><a title=更多平台 class="bshare-more bshare-more-icon more-style-addthis"></a></div><script type=text/javascript src="http://static.bshare.cn/b/buttonLite.js#style=-1&uuid=&pophcol=2&lang=zh"></script><script type=text/javascript src=http://static.bshare.cn/b/bshareC0.js></script></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>