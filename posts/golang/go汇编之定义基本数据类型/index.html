<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go汇编之定义基本数据类型 | Linote</title><meta name=keywords content="golang,汇编"><meta name=description content="1. Go汇编基础  这里只介绍本文会用到的语法
 4个虚拟寄存器   FP: Frame pointer：伪FP寄存器对应函数的栈帧指针，一般用来访问函数的参数和返回值；golang语言中，函数的参数和返回值，函数中的局部变量，函数中调用子函数的参数和返回值都是存储在栈中的，我们把这一段栈内存称为栈帧（frame），伪FP寄存器对应栈帧的底部，但是伪FP只包括函数的参数和返回值这部分内存，其他部分由伪SP寄存器表示；注意golang中函数的返回值也是通过栈帧返回的，这也是golang函数可以有多个返回值的原因；
  PC: Program counter：指令计数器，用于分支和跳转，它是汇编的IP寄存器的别名；
  SB: Static base pointer：一般用于声明函数或者全局变量，对应代码区（text）内存段底部；可认为是内存的起源，所以符号foo(SB)就是名称foo作为内存中的一个地址。这种形式被用于命名全局函数和数据，如果将<>添加到名称中，如foo<>(SB)，则代表此标识符只在当前源文件中可见。可对名称添加偏移量，如foo+4(SB)指foo开头之后的四个字节。
  SP: Stack pointer：指向当前栈帧的局部变量的开始位置，一般用来引用函数的局部变量，这里需要注意汇编中也有一个SP寄存器，它们的区别是：1.伪SP寄存器指向栈帧（不包括函数参数和返回值部分）的底部，真SP寄存器对应栈的顶部；所以伪SP寄存器一般用于寻址函数局部变量，真SP寄存器一般用于调用子函数时，寻址子函数的参数和返回值（后面会有具体示例演示）；2.当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如(SP)、+8(SP)没有标识符前缀为真SP寄存器，而a(SP)、b+8(SP)有标识符为前缀表示伪寄存器；
  所有用户定义的符号都作为偏移量写入伪寄存器 FP（参数和局部变量）和 SB（全局变量）
常量 Go汇编语言中常量以$美元符号为前缀。常量的类型有整数常量、浮点数常量、字符常量和字符串常量等几种类型。
$1 // 十进制 $0xf4f8fcff // 十六进制 $1.5 // 浮点数 $'a' // 字符 $&#34;abcd&#34; DATA指令 DATA命令用于初始化包变量，DATA命令的语法如下：
DATA symbol+offset(SB)/width, value 其中symbol为变量在汇编语言中对应的标识符，offset是符号开始地址的偏移量，width是要初始化内存的宽度大小，value是要初始化的值。其中当前包中Go语言定义的符号symbol，在汇编代码中对应·symbol，其中·中点符号为一个特殊的unicode符号；DATA命令示例如下
DATA ·Id+0(SB)/1,$0x37 DATA ·Id+1(SB)/1,$0x25 这两条指令的含义是将全局变量Id赋值为16进制数0x2537，也就是十进制的9527； 我们也可以合并成一条指令
GLOBL 用于将符号导出，例如将全局变量导出（所谓导出就是把汇编中的全局变量导出到go代码中声明的相同变量上，否则go代码中声明的变量感知不到汇编中变量的值的变化），其语法如下：
GLOBL symbol(SB), width 其中symbol对应汇编中符号的名字，width为符号对应内存的大小；GLOBL命令示例如下： GLOBL ·Id, $8这条指令的含义是导出一个全局变量Id，其大小是8字节（byte）； 结合DATA和GLOBL指令，我们就可以初始化并导出一个全局变量.例如：
GLOBL ·Id, $8 DATA ·Id+0(SB)/8,$0x12345 2."><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/golang/go%E6%B1%87%E7%BC%96%E4%B9%8B%E5%AE%9A%E4%B9%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go汇编之定义基本数据类型"><meta property="og:description" content="1. Go汇编基础  这里只介绍本文会用到的语法
 4个虚拟寄存器   FP: Frame pointer：伪FP寄存器对应函数的栈帧指针，一般用来访问函数的参数和返回值；golang语言中，函数的参数和返回值，函数中的局部变量，函数中调用子函数的参数和返回值都是存储在栈中的，我们把这一段栈内存称为栈帧（frame），伪FP寄存器对应栈帧的底部，但是伪FP只包括函数的参数和返回值这部分内存，其他部分由伪SP寄存器表示；注意golang中函数的返回值也是通过栈帧返回的，这也是golang函数可以有多个返回值的原因；
  PC: Program counter：指令计数器，用于分支和跳转，它是汇编的IP寄存器的别名；
  SB: Static base pointer：一般用于声明函数或者全局变量，对应代码区（text）内存段底部；可认为是内存的起源，所以符号foo(SB)就是名称foo作为内存中的一个地址。这种形式被用于命名全局函数和数据，如果将<>添加到名称中，如foo<>(SB)，则代表此标识符只在当前源文件中可见。可对名称添加偏移量，如foo+4(SB)指foo开头之后的四个字节。
  SP: Stack pointer：指向当前栈帧的局部变量的开始位置，一般用来引用函数的局部变量，这里需要注意汇编中也有一个SP寄存器，它们的区别是：1.伪SP寄存器指向栈帧（不包括函数参数和返回值部分）的底部，真SP寄存器对应栈的顶部；所以伪SP寄存器一般用于寻址函数局部变量，真SP寄存器一般用于调用子函数时，寻址子函数的参数和返回值（后面会有具体示例演示）；2.当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如(SP)、+8(SP)没有标识符前缀为真SP寄存器，而a(SP)、b+8(SP)有标识符为前缀表示伪寄存器；
  所有用户定义的符号都作为偏移量写入伪寄存器 FP（参数和局部变量）和 SB（全局变量）
常量 Go汇编语言中常量以$美元符号为前缀。常量的类型有整数常量、浮点数常量、字符常量和字符串常量等几种类型。
$1 // 十进制 $0xf4f8fcff // 十六进制 $1.5 // 浮点数 $'a' // 字符 $&#34;abcd&#34; DATA指令 DATA命令用于初始化包变量，DATA命令的语法如下：
DATA symbol+offset(SB)/width, value 其中symbol为变量在汇编语言中对应的标识符，offset是符号开始地址的偏移量，width是要初始化内存的宽度大小，value是要初始化的值。其中当前包中Go语言定义的符号symbol，在汇编代码中对应·symbol，其中·中点符号为一个特殊的unicode符号；DATA命令示例如下
DATA ·Id+0(SB)/1,$0x37 DATA ·Id+1(SB)/1,$0x25 这两条指令的含义是将全局变量Id赋值为16进制数0x2537，也就是十进制的9527； 我们也可以合并成一条指令
GLOBL 用于将符号导出，例如将全局变量导出（所谓导出就是把汇编中的全局变量导出到go代码中声明的相同变量上，否则go代码中声明的变量感知不到汇编中变量的值的变化），其语法如下：
GLOBL symbol(SB), width 其中symbol对应汇编中符号的名字，width为符号对应内存的大小；GLOBL命令示例如下： GLOBL ·Id, $8这条指令的含义是导出一个全局变量Id，其大小是8字节（byte）； 结合DATA和GLOBL指令，我们就可以初始化并导出一个全局变量.例如：
GLOBL ·Id, $8 DATA ·Id+0(SB)/8,$0x12345 2."><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/golang/go%E6%B1%87%E7%BC%96%E4%B9%8B%E5%AE%9A%E4%B9%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-10T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-10T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="Go汇编之定义基本数据类型"><meta name=twitter:description content="1. Go汇编基础  这里只介绍本文会用到的语法
 4个虚拟寄存器   FP: Frame pointer：伪FP寄存器对应函数的栈帧指针，一般用来访问函数的参数和返回值；golang语言中，函数的参数和返回值，函数中的局部变量，函数中调用子函数的参数和返回值都是存储在栈中的，我们把这一段栈内存称为栈帧（frame），伪FP寄存器对应栈帧的底部，但是伪FP只包括函数的参数和返回值这部分内存，其他部分由伪SP寄存器表示；注意golang中函数的返回值也是通过栈帧返回的，这也是golang函数可以有多个返回值的原因；
  PC: Program counter：指令计数器，用于分支和跳转，它是汇编的IP寄存器的别名；
  SB: Static base pointer：一般用于声明函数或者全局变量，对应代码区（text）内存段底部；可认为是内存的起源，所以符号foo(SB)就是名称foo作为内存中的一个地址。这种形式被用于命名全局函数和数据，如果将<>添加到名称中，如foo<>(SB)，则代表此标识符只在当前源文件中可见。可对名称添加偏移量，如foo+4(SB)指foo开头之后的四个字节。
  SP: Stack pointer：指向当前栈帧的局部变量的开始位置，一般用来引用函数的局部变量，这里需要注意汇编中也有一个SP寄存器，它们的区别是：1.伪SP寄存器指向栈帧（不包括函数参数和返回值部分）的底部，真SP寄存器对应栈的顶部；所以伪SP寄存器一般用于寻址函数局部变量，真SP寄存器一般用于调用子函数时，寻址子函数的参数和返回值（后面会有具体示例演示）；2.当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如(SP)、+8(SP)没有标识符前缀为真SP寄存器，而a(SP)、b+8(SP)有标识符为前缀表示伪寄存器；
  所有用户定义的符号都作为偏移量写入伪寄存器 FP（参数和局部变量）和 SB（全局变量）
常量 Go汇编语言中常量以$美元符号为前缀。常量的类型有整数常量、浮点数常量、字符常量和字符串常量等几种类型。
$1 // 十进制 $0xf4f8fcff // 十六进制 $1.5 // 浮点数 $'a' // 字符 $&#34;abcd&#34; DATA指令 DATA命令用于初始化包变量，DATA命令的语法如下：
DATA symbol+offset(SB)/width, value 其中symbol为变量在汇编语言中对应的标识符，offset是符号开始地址的偏移量，width是要初始化内存的宽度大小，value是要初始化的值。其中当前包中Go语言定义的符号symbol，在汇编代码中对应·symbol，其中·中点符号为一个特殊的unicode符号；DATA命令示例如下
DATA ·Id+0(SB)/1,$0x37 DATA ·Id+1(SB)/1,$0x25 这两条指令的含义是将全局变量Id赋值为16进制数0x2537，也就是十进制的9527； 我们也可以合并成一条指令
GLOBL 用于将符号导出，例如将全局变量导出（所谓导出就是把汇编中的全局变量导出到go代码中声明的相同变量上，否则go代码中声明的变量感知不到汇编中变量的值的变化），其语法如下：
GLOBL symbol(SB), width 其中symbol对应汇编中符号的名字，width为符号对应内存的大小；GLOBL命令示例如下： GLOBL ·Id, $8这条指令的含义是导出一个全局变量Id，其大小是8字节（byte）； 结合DATA和GLOBL指令，我们就可以初始化并导出一个全局变量.例如：
GLOBL ·Id, $8 DATA ·Id+0(SB)/8,$0x12345 2."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"Go汇编之定义基本数据类型","item":"http://yangchnet.github.io/Dessert/posts/golang/go%E6%B1%87%E7%BC%96%E4%B9%8B%E5%AE%9A%E4%B9%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go汇编之定义基本数据类型","name":"Go汇编之定义基本数据类型","description":"1. Go汇编基础  这里只介绍本文会用到的语法\n 4个虚拟寄存器   FP: Frame pointer：伪FP寄存器对应函数的栈帧指针，一般用来访问函数的参数和返回值；golang语言中，函数的参数和返回值，函数中的局部变量，函数中调用子函数的参数和返回值都是存储在栈中的，我们把这一段栈内存称为栈帧（frame），伪FP寄存器对应栈帧的底部，但是伪FP只包括函数的参数和返回值这部分内存，其他部分由伪SP寄存器表示；注意golang中函数的返回值也是通过栈帧返回的，这也是golang函数可以有多个返回值的原因；\n  PC: Program counter：指令计数器，用于分支和跳转，它是汇编的IP寄存器的别名；\n  SB: Static base pointer：一般用于声明函数或者全局变量，对应代码区（text）内存段底部；可认为是内存的起源，所以符号foo(SB)就是名称foo作为内存中的一个地址。这种形式被用于命名全局函数和数据，如果将\u0026lt;\u0026gt;添加到名称中，如foo\u0026lt;\u0026gt;(SB)，则代表此标识符只在当前源文件中可见。可对名称添加偏移量，如foo+4(SB)指foo开头之后的四个字节。\n  SP: Stack pointer：指向当前栈帧的局部变量的开始位置，一般用来引用函数的局部变量，这里需要注意汇编中也有一个SP寄存器，它们的区别是：1.伪SP寄存器指向栈帧（不包括函数参数和返回值部分）的底部，真SP寄存器对应栈的顶部；所以伪SP寄存器一般用于寻址函数局部变量，真SP寄存器一般用于调用子函数时，寻址子函数的参数和返回值（后面会有具体示例演示）；2.当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如(SP)、+8(SP)没有标识符前缀为真SP寄存器，而a(SP)、b+8(SP)有标识符为前缀表示伪寄存器；\n  所有用户定义的符号都作为偏移量写入伪寄存器 FP（参数和局部变量）和 SB（全局变量）\n常量 Go汇编语言中常量以$美元符号为前缀。常量的类型有整数常量、浮点数常量、字符常量和字符串常量等几种类型。\n$1 // 十进制 $0xf4f8fcff // 十六进制 $1.5 // 浮点数 $'a' // 字符 $\u0026quot;abcd\u0026quot; DATA指令 DATA命令用于初始化包变量，DATA命令的语法如下：\nDATA symbol+offset(SB)/width, value 其中symbol为变量在汇编语言中对应的标识符，offset是符号开始地址的偏移量，width是要初始化内存的宽度大小，value是要初始化的值。其中当前包中Go语言定义的符号symbol，在汇编代码中对应·symbol，其中·中点符号为一个特殊的unicode符号；DATA命令示例如下\nDATA ·Id+0(SB)/1,$0x37 DATA ·Id+1(SB)/1,$0x25 这两条指令的含义是将全局变量Id赋值为16进制数0x2537，也就是十进制的9527； 我们也可以合并成一条指令\nGLOBL 用于将符号导出，例如将全局变量导出（所谓导出就是把汇编中的全局变量导出到go代码中声明的相同变量上，否则go代码中声明的变量感知不到汇编中变量的值的变化），其语法如下：\nGLOBL symbol(SB), width 其中symbol对应汇编中符号的名字，width为符号对应内存的大小；GLOBL命令示例如下： GLOBL ·Id, $8这条指令的含义是导出一个全局变量Id，其大小是8字节（byte）； 结合DATA和GLOBL指令，我们就可以初始化并导出一个全局变量.例如：\nGLOBL ·Id, $8 DATA ·Id+0(SB)/8,$0x12345 2.","keywords":["golang","汇编"],"articleBody":"1. Go汇编基础  这里只介绍本文会用到的语法\n 4个虚拟寄存器   FP: Frame pointer：伪FP寄存器对应函数的栈帧指针，一般用来访问函数的参数和返回值；golang语言中，函数的参数和返回值，函数中的局部变量，函数中调用子函数的参数和返回值都是存储在栈中的，我们把这一段栈内存称为栈帧（frame），伪FP寄存器对应栈帧的底部，但是伪FP只包括函数的参数和返回值这部分内存，其他部分由伪SP寄存器表示；注意golang中函数的返回值也是通过栈帧返回的，这也是golang函数可以有多个返回值的原因；\n  PC: Program counter：指令计数器，用于分支和跳转，它是汇编的IP寄存器的别名；\n  SB: Static base pointer：一般用于声明函数或者全局变量，对应代码区（text）内存段底部；可认为是内存的起源，所以符号foo(SB)就是名称foo作为内存中的一个地址。这种形式被用于命名全局函数和数据，如果将添加到名称中，如foo(SB)，则代表此标识符只在当前源文件中可见。可对名称添加偏移量，如foo+4(SB)指foo开头之后的四个字节。\n  SP: Stack pointer：指向当前栈帧的局部变量的开始位置，一般用来引用函数的局部变量，这里需要注意汇编中也有一个SP寄存器，它们的区别是：1.伪SP寄存器指向栈帧（不包括函数参数和返回值部分）的底部，真SP寄存器对应栈的顶部；所以伪SP寄存器一般用于寻址函数局部变量，真SP寄存器一般用于调用子函数时，寻址子函数的参数和返回值（后面会有具体示例演示）；2.当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如(SP)、+8(SP)没有标识符前缀为真SP寄存器，而a(SP)、b+8(SP)有标识符为前缀表示伪寄存器；\n  所有用户定义的符号都作为偏移量写入伪寄存器 FP（参数和局部变量）和 SB（全局变量）\n常量 Go汇编语言中常量以$美元符号为前缀。常量的类型有整数常量、浮点数常量、字符常量和字符串常量等几种类型。\n$1 // 十进制 $0xf4f8fcff // 十六进制 $1.5 // 浮点数 $'a' // 字符 $\"abcd\" DATA指令 DATA命令用于初始化包变量，DATA命令的语法如下：\nDATA symbol+offset(SB)/width, value 其中symbol为变量在汇编语言中对应的标识符，offset是符号开始地址的偏移量，width是要初始化内存的宽度大小，value是要初始化的值。其中当前包中Go语言定义的符号symbol，在汇编代码中对应·symbol，其中·中点符号为一个特殊的unicode符号；DATA命令示例如下\nDATA ·Id+0(SB)/1,$0x37 DATA ·Id+1(SB)/1,$0x25 这两条指令的含义是将全局变量Id赋值为16进制数0x2537，也就是十进制的9527； 我们也可以合并成一条指令\nGLOBL 用于将符号导出，例如将全局变量导出（所谓导出就是把汇编中的全局变量导出到go代码中声明的相同变量上，否则go代码中声明的变量感知不到汇编中变量的值的变化），其语法如下：\nGLOBL symbol(SB), width 其中symbol对应汇编中符号的名字，width为符号对应内存的大小；GLOBL命令示例如下： GLOBL ·Id, $8这条指令的含义是导出一个全局变量Id，其大小是8字节（byte）； 结合DATA和GLOBL指令，我们就可以初始化并导出一个全局变量.例如：\nGLOBL ·Id, $8 DATA ·Id+0(SB)/8,$0x12345 2. 基本数据类型 建立如下文件结构：\n├── main.go ├── go.mod └── pkg ├── pkg_amd64.s └── pkg.go int 文件内容如下:\n// pkg/pkg_amd64.s #include \"textflag.h\" // 使用NOPTR标志时必须导入此文件，此文件位置在：$GOROOT/src/runtime/textflag.h // var MyInt int = 1234 GLOBL ·MyInt(SB),NOPTR,$8 // 导出MyInt,NOPTR表明不包含指针 DATA ·MyInt+0(SB)/8,$1234 // 定义了一个8字节的数据，值为1234 // pkg/pkg.go  package pkg var MyInt int // main.go  package main import ( \"simple-go/pkg\" ) func main() { println(MyInt) } 运行main.go可得到MyInt的值为1234\nfloat // pkg/pkg_amd64.s #include \"textflag.h\" GLOBL ·MyFloat64(SB),NOPTR,$8 DATA ·MyFloat64+0(SB)/8,$0.01 // pkg.go  var MyFloat64 float64 string 首先需要了解一下字符串的内部标识\n// $GOROOT/src/runtime/string.go type stringStruct struct { str unsafe.Pointer len int } 因此，我们需要首先定义字符数据，再将字符串的str指向这个字符数据\n// pkg/pkg_amd64.s GLOBL NameData(SB),NOPTR,$8 DATA NameData(SB)/8,$\"abc\" // 定义一个非导出的数据NameData(SB),size为8字节 GLOBL ·MyStr0(SB),NOPTR,$16 DATA ·MyStr0+0(SB)/8,$NameData(SB) // MyStr的前8个字节内容为NameData(SB) DATA ·MyStr0+8(SB)/8,$3 // 后8个字节为3,代表字符串长度 // pkg/pkg.go  var MyString string bool // pkg/pkg_amd64.s GLOBL ·MyBool(SB),NOPTR,$1 DATA ·MyBool+0(SB)/1,$1 // pkg/pkg.go  var MyBool bool *int // 首先定义一个int变量 GLOBL IntData(SB),NOPTR,$8 DATA IntData(SB)/8,$9876 // 将指针指向int变量 GLOBL ·MyIntPtr(SB),NOPTR,$8 DATA ·MyIntPtr+0(SB)/8,$IntData(SB) var MyIntPtr *int 3. 复合数据类型 数组 // pkg/pkg_amd64.s // array [2]int = {12, 34} GLOBL ·MyArray(SB),NOPTR,$16 DATA ·MyArray+0(SB)/8,$12 DATA ·MyArray+8(SB)/8,$34 // pkg/pkg.go  var MyArray [2]int 切片 首先需要了解切片的内部结构\n// $GOROOT/src/runtime/slice.go type slice struct { array unsafe.Pointer len int cap int } 切片是截取数组的一部分得来的，因此要先定义一个数组，然后将切片的array指针指向这个数组的某个偏移\n// pkg/pkg_amd64.s // 定义三个string临时变量，作为切片元素 GLOBL str0(SB),NOPTR,$40 DATA str0(SB)/40,$\"Thoughts in the Still of the Night\" GLOBL str1(SB),NOPTR,$40 DATA str1(SB)/40,$\"A pool of moonlight before the bed\" GLOBL str2(SB),NOPTR,$8 DATA str2(SB)/8,$\"libai\" // 定义一个[3]string的数组，元素就是上面的三个string变量 GLOBL strarray(SB),NOPTR,$48 DATA strarray+0(SB)/8,$str0(SB) DATA strarray+8(SB)/8,$34 DATA strarray+16(SB)/8,$str1(SB) DATA strarray+24(SB)/8,$34 DATA strarray+32(SB)/8,$str2(SB) DATA strarray+40(SB)/8,$5 // var MySlice []string GLOBL ·MySlice(SB),NOPTR,$24 // 上面[3]string数组的首地址用来初始化切片的Data字段 DATA ·MySlice+0(SB)/8,$strarray(SB) DATA ·MySlice+8(SB)/8,$3 DATA ·MySlice+16(SB)/8,$4 上面的切片是截取了全部的数组元素，如果想要从第二个开始截取，可增加偏移：\nDATA ·MySlice+0(SB)/8,$strarray+16(SB) map/chan map/channel等类型并没有公开的内部结构，它们只是一种未知类型的指针，无法直接初始化。在汇编代码中我们只能为类似变量定义并进行0值初始化：\nvar m map[string]int var ch chan int GLOBL ·m(SB),$8 // var m map[string]int DATA ·m+0(SB)/8,$0 GLOBL ·ch(SB),$8 // var ch chan int DATA ·ch+0(SB)/8,$0 References Golang学习笔记-汇编\nmap的实现原理\nchan\nA Quick Guide to Go’s Assembler\nGo语言高级编程\n","wordCount":"333","inLanguage":"en","datePublished":"2022-06-10T00:00:00Z","dateModified":"2022-06-10T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/golang/go%E6%B1%87%E7%BC%96%E4%B9%8B%E5%AE%9A%E4%B9%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>Go汇编之定义基本数据类型</h1><div class=post-meta><span title="2022-06-10 00:00:00 +0000 UTC">June 10, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-go%e6%b1%87%e7%bc%96%e5%9f%ba%e7%a1%80 aria-label="1. Go汇编基础">1. Go汇编基础</a><ul><ul><li><a href=#4%e4%b8%aa%e8%99%9a%e6%8b%9f%e5%af%84%e5%ad%98%e5%99%a8 aria-label=4个虚拟寄存器>4个虚拟寄存器</a></li><li><a href=#%e5%b8%b8%e9%87%8f aria-label=常量>常量</a></li><li><a href=#data%e6%8c%87%e4%bb%a4 aria-label=DATA指令>DATA指令</a></li><li><a href=#globl aria-label=GLOBL>GLOBL</a></li></ul></ul></li><li><a href=#2-%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label="2. 基本数据类型">2. 基本数据类型</a><ul><ul><li><a href=#int aria-label=int>int</a></li><li><a href=#float aria-label=float>float</a></li><li><a href=#string aria-label=string>string</a></li><li><a href=#bool aria-label=bool>bool</a></li><li><a href=#int-1 aria-label=*int>*int</a></li></ul></ul></li><li><a href=#3-%e5%a4%8d%e5%90%88%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label="3. 复合数据类型">3. 复合数据类型</a><ul><ul><li><a href=#%e6%95%b0%e7%bb%84 aria-label=数组>数组</a></li><li><a href=#%e5%88%87%e7%89%87 aria-label=切片>切片</a></li><li><a href=#mapchan aria-label=map/chan>map/chan</a></li></ul></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><h2 id=1-go汇编基础>1. Go汇编基础<a hidden class=anchor aria-hidden=true href=#1-go汇编基础>#</a></h2><blockquote><p>这里只介绍本文会用到的语法</p></blockquote><h4 id=4个虚拟寄存器>4个虚拟寄存器<a hidden class=anchor aria-hidden=true href=#4个虚拟寄存器>#</a></h4><ul><li><p>FP: Frame pointer：伪FP寄存器对应函数的栈帧指针，一般用来访问函数的参数和返回值；golang语言中，函数的参数和返回值，函数中的局部变量，函数中调用子函数的参数和返回值都是存储在栈中的，我们把这一段栈内存称为栈帧（frame），伪FP寄存器对应栈帧的底部，但是伪FP只包括函数的参数和返回值这部分内存，其他部分由伪SP寄存器表示；注意golang中函数的返回值也是通过栈帧返回的，这也是golang函数可以有多个返回值的原因；</p></li><li><p>PC: Program counter：指令计数器，用于分支和跳转，它是汇编的IP寄存器的别名；</p></li><li><p>SB: Static base pointer：一般用于声明函数或者全局变量，对应代码区（text）内存段底部；可认为是内存的起源，所以符号<code>foo(SB)</code>就是名称<code>foo</code>作为内存中的一个地址。这种形式被用于命名全局函数和数据，如果将<code>&lt;></code>添加到名称中，如<code>foo&lt;>(SB)</code>，则代表此标识符只在当前源文件中可见。可对名称添加偏移量，如<code>foo+4(SB)</code>指foo开头之后的四个字节。</p></li><li><p>SP: Stack pointer：指向当前栈帧的局部变量的开始位置，一般用来引用函数的局部变量，这里需要注意汇编中也有一个SP寄存器，它们的区别是：1.伪SP寄存器指向栈帧（不包括函数参数和返回值部分）的底部，真SP寄存器对应栈的顶部；所以伪SP寄存器一般用于寻址函数局部变量，真SP寄存器一般用于调用子函数时，寻址子函数的参数和返回值（后面会有具体示例演示）；2.当需要区分伪寄存器和真寄存器的时候只需要记住一点：伪寄存器一般需要一个标识符和偏移量为前缀，如果没有标识符前缀则是真寄存器。比如(SP)、+8(SP)没有标识符前缀为真SP寄存器，而a(SP)、b+8(SP)有标识符为前缀表示伪寄存器；</p></li></ul><p>所有用户定义的符号都作为偏移量写入伪寄存器 FP（参数和局部变量）和 SB（全局变量）</p><h4 id=常量>常量<a hidden class=anchor aria-hidden=true href=#常量>#</a></h4><p>Go汇编语言中常量以$美元符号为前缀。常量的类型有整数常量、浮点数常量、字符常量和字符串常量等几种类型。</p><pre><code>$1           // 十进制
$0xf4f8fcff  // 十六进制
$1.5         // 浮点数
$'a'         // 字符
$&quot;abcd&quot;
</code></pre><h4 id=data指令>DATA指令<a hidden class=anchor aria-hidden=true href=#data指令>#</a></h4><p>DATA命令用于初始化包变量，DATA命令的语法如下：</p><pre><code>DATA symbol+offset(SB)/width, value
</code></pre><p>其中symbol为变量在汇编语言中对应的标识符，offset是符号开始地址的偏移量，width是要初始化内存的宽度大小，value是要初始化的值。其中当前包中Go语言定义的符号symbol，在汇编代码中对应·symbol，其中·中点符号为一个特殊的unicode符号；DATA命令示例如下</p><pre><code>DATA ·Id+0(SB)/1,$0x37
DATA ·Id+1(SB)/1,$0x25
</code></pre><p>这两条指令的含义是将全局变量Id赋值为16进制数0x2537，也就是十进制的9527；
我们也可以合并成一条指令</p><h4 id=globl>GLOBL<a hidden class=anchor aria-hidden=true href=#globl>#</a></h4><p>用于将符号导出，例如将全局变量导出（所谓导出就是把汇编中的全局变量导出到go代码中声明的相同变量上，否则go代码中声明的变量感知不到汇编中变量的值的变化），其语法如下：</p><pre><code>GLOBL symbol(SB), width
</code></pre><p>其中symbol对应汇编中符号的名字，width为符号对应内存的大小；GLOBL命令示例如下：
GLOBL ·Id, $8这条指令的含义是导出一个全局变量Id，其大小是8字节（byte）；
结合DATA和GLOBL指令，我们就可以初始化并导出一个全局变量.例如：</p><pre><code>GLOBL ·Id, $8
DATA ·Id+0(SB)/8,$0x12345
</code></pre><h2 id=2-基本数据类型>2. 基本数据类型<a hidden class=anchor aria-hidden=true href=#2-基本数据类型>#</a></h2><p>建立如下文件结构：</p><pre><code>├── main.go
├── go.mod
└── pkg
    ├── pkg_amd64.s
    └── pkg.go
</code></pre><h4 id=int>int<a hidden class=anchor aria-hidden=true href=#int>#</a></h4><p>文件内容如下:</p><pre><code>// pkg/pkg_amd64.s

#include &quot;textflag.h&quot; // 使用NOPTR标志时必须导入此文件，此文件位置在：$GOROOT/src/runtime/textflag.h
// var MyInt int = 1234
GLOBL ·MyInt(SB),NOPTR,$8 // 导出MyInt,NOPTR表明不包含指针
DATA ·MyInt+0(SB)/8,$1234 // 定义了一个8字节的数据，值为1234
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// pkg/pkg.go
</span><span style=color:#75715e></span>
<span style=color:#f92672>package</span> <span style=color:#a6e22e>pkg</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>MyInt</span> <span style=color:#66d9ef>int</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// main.go
</span><span style=color:#75715e></span>
<span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
    <span style=color:#e6db74>&#34;simple-go/pkg&#34;</span>
)


<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    println(<span style=color:#a6e22e>MyInt</span>)
}
</code></pre></div><p>运行main.go可得到MyInt的值为1234</p><h4 id=float>float<a hidden class=anchor aria-hidden=true href=#float>#</a></h4><pre><code>// pkg/pkg_amd64.s

#include &quot;textflag.h&quot;
GLOBL ·MyFloat64(SB),NOPTR,$8
DATA ·MyFloat64+0(SB)/8,$0.01
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// pkg.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>MyFloat64</span> <span style=color:#66d9ef>float64</span>
</code></pre></div><h4 id=string>string<a hidden class=anchor aria-hidden=true href=#string>#</a></h4><p>首先需要了解一下字符串的内部标识</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// $GOROOT/src/runtime/string.go
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stringStruct</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
    <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>
}
</code></pre></div><p>因此，我们需要首先定义字符数据，再将字符串的str指向这个字符数据</p><pre><code>// pkg/pkg_amd64.s

GLOBL NameData&lt;&gt;(SB),NOPTR,$8
DATA  NameData&lt;&gt;(SB)/8,$&quot;abc&quot; // 定义一个非导出的数据NameData&lt;&gt;(SB),size为8字节

GLOBL ·MyStr0(SB),NOPTR,$16
DATA  ·MyStr0+0(SB)/8,$NameData&lt;&gt;(SB) // MyStr的前8个字节内容为NameData&lt;&gt;(SB)
DATA  ·MyStr0+8(SB)/8,$3 // 后8个字节为3,代表字符串长度
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// pkg/pkg.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>MyString</span> <span style=color:#66d9ef>string</span>
</code></pre></div><h4 id=bool>bool<a hidden class=anchor aria-hidden=true href=#bool>#</a></h4><pre><code>// pkg/pkg_amd64.s

GLOBL ·MyBool(SB),NOPTR,$1
DATA ·MyBool+0(SB)/1,$1
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// pkg/pkg.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>MyBool</span> <span style=color:#66d9ef>bool</span>
</code></pre></div><h4 id=int-1>*int<a hidden class=anchor aria-hidden=true href=#int-1>#</a></h4><pre><code>// 首先定义一个int变量
GLOBL IntData&lt;&gt;(SB),NOPTR,$8
DATA IntData&lt;&gt;(SB)/8,$9876

// 将指针指向int变量
GLOBL ·MyIntPtr(SB),NOPTR,$8
DATA ·MyIntPtr+0(SB)/8,$IntData&lt;&gt;(SB)
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>MyIntPtr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>
</code></pre></div><h2 id=3-复合数据类型>3. 复合数据类型<a hidden class=anchor aria-hidden=true href=#3-复合数据类型>#</a></h2><h4 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h4><pre><code>// pkg/pkg_amd64.s

// array [2]int = {12, 34}
GLOBL ·MyArray(SB),NOPTR,$16
DATA  ·MyArray+0(SB)/8,$12
DATA ·MyArray+8(SB)/8,$34
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// pkg/pkg.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>MyArray</span> [<span style=color:#ae81ff>2</span>]<span style=color:#66d9ef>int</span>
</code></pre></div><h4 id=切片>切片<a hidden class=anchor aria-hidden=true href=#切片>#</a></h4><p>首先需要了解切片的内部结构</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// $GOROOT/src/runtime/slice.go
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slice</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>array</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
    <span style=color:#a6e22e>len</span>   <span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>cap</span>   <span style=color:#66d9ef>int</span>
}
</code></pre></div><p>切片是截取数组的一部分得来的，因此要先定义一个数组，然后将切片的<code>array</code>指针指向这个数组的某个偏移</p><pre><code>// pkg/pkg_amd64.s

// 定义三个string临时变量，作为切片元素
GLOBL str0&lt;&gt;(SB),NOPTR,$40
DATA  str0&lt;&gt;(SB)/40,$&quot;Thoughts in the Still of the Night&quot;

GLOBL str1&lt;&gt;(SB),NOPTR,$40
DATA  str1&lt;&gt;(SB)/40,$&quot;A pool of moonlight before the bed&quot;

GLOBL str2&lt;&gt;(SB),NOPTR,$8
DATA  str2&lt;&gt;(SB)/8,$&quot;libai&quot;

// 定义一个[3]string的数组，元素就是上面的三个string变量
GLOBL strarray&lt;&gt;(SB),NOPTR,$48
DATA  strarray&lt;&gt;+0(SB)/8,$str0&lt;&gt;(SB)
DATA  strarray&lt;&gt;+8(SB)/8,$34
DATA  strarray&lt;&gt;+16(SB)/8,$str1&lt;&gt;(SB)
DATA  strarray&lt;&gt;+24(SB)/8,$34
DATA  strarray&lt;&gt;+32(SB)/8,$str2&lt;&gt;(SB)
DATA  strarray&lt;&gt;+40(SB)/8,$5

// var MySlice []string
GLOBL ·MySlice(SB),NOPTR,$24
// 上面[3]string数组的首地址用来初始化切片的Data字段
DATA  ·MySlice+0(SB)/8,$strarray&lt;&gt;(SB)
DATA  ·MySlice+8(SB)/8,$3
DATA  ·MySlice+16(SB)/8,$4
</code></pre><p>上面的切片是截取了全部的数组元素，如果想要从第二个开始截取，可增加偏移：</p><pre><code>DATA  ·MySlice+0(SB)/8,$strarray&lt;&gt;+16(SB)
</code></pre><h4 id=mapchan>map/chan<a hidden class=anchor aria-hidden=true href=#mapchan>#</a></h4><p>map/channel等类型并没有公开的内部结构，它们只是一种未知类型的指针，无法直接初始化。在汇编代码中我们只能为类似变量定义并进行0值初始化：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ch</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>
</code></pre></div><pre><code>GLOBL ·m(SB),$8  // var m map[string]int
DATA  ·m+0(SB)/8,$0

GLOBL ·ch(SB),$8 // var ch chan int
DATA  ·ch+0(SB)/8,$0
</code></pre><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://segmentfault.com/a/1190000041159550>Golang学习笔记-汇编</a></p><p><a href=https://golang.design/go-questions/map/principal/>map的实现原理</a></p><p><a href=https://golang.design/go-questions/channel/csp/>chan</a></p><p><a href=https://go.dev/doc/asm>A Quick Guide to Go&rsquo;s Assembler</a></p><p><a href=https://chai2010.cn/advanced-go-programming-book>Go语言高级编程</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/golang/>golang</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/%E6%B1%87%E7%BC%96/>汇编</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/mq/%E6%A6%82%E8%A7%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AF%87%E4%B8%80%E4%B8%8D%E5%90%8C%E7%9A%84mq%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B/><span class=title>« Prev Page</span><br><span>概览消息队列篇一：不同的mq的消息模型</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/linux/cgroupv2/><span class=title>Next Page »</span><br><span>CgroupV2</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>