<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>runtime篇一：接口 | Linote</title><meta name=keywords content="golang,runtime"><meta name=description content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. 接口的内部结构 type iface struct { tab *itab data unsafe.Pointer } 一个接口是一个iface结构体，其中包含一个itab指针和一个unsafe.Pointer。
概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。
一个itab可以表示一个接口的类型和赋给这个接口的实体类型，即为接口的动态类型，而data所指向的unsafe.Pointer则指向接口的动态值。
近距离来看itab：
type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. 	_ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 其中inter字段描述了接口的类型，_type字段描述了实体类型，hash字段是类型哈希，用于类型匹配，fun字段放置和接口方法对应的具体数据类型的方法地址。
再来看interfacetype
type interfacetype struct { typ _type pkgpath name mhdr []imethod } 其中typ和itab中的_type为同一个值，pkgpath则存储了接口的包名，mhdr则表示接口所定义的函数列表。"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="runtime篇一：接口"><meta property="og:description" content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. 接口的内部结构 type iface struct { tab *itab data unsafe.Pointer } 一个接口是一个iface结构体，其中包含一个itab指针和一个unsafe.Pointer。
概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。
一个itab可以表示一个接口的类型和赋给这个接口的实体类型，即为接口的动态类型，而data所指向的unsafe.Pointer则指向接口的动态值。
近距离来看itab：
type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. 	_ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 其中inter字段描述了接口的类型，_type字段描述了实体类型，hash字段是类型哈希，用于类型匹配，fun字段放置和接口方法对应的具体数据类型的方法地址。
再来看interfacetype
type interfacetype struct { typ _type pkgpath name mhdr []imethod } 其中typ和itab中的_type为同一个值，pkgpath则存储了接口的包名，mhdr则表示接口所定义的函数列表。"><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-04T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-04T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="runtime篇一：接口"><meta name=twitter:description content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. 接口的内部结构 type iface struct { tab *itab data unsafe.Pointer } 一个接口是一个iface结构体，其中包含一个itab指针和一个unsafe.Pointer。
概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。
一个itab可以表示一个接口的类型和赋给这个接口的实体类型，即为接口的动态类型，而data所指向的unsafe.Pointer则指向接口的动态值。
近距离来看itab：
type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. 	_ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 其中inter字段描述了接口的类型，_type字段描述了实体类型，hash字段是类型哈希，用于类型匹配，fun字段放置和接口方法对应的具体数据类型的方法地址。
再来看interfacetype
type interfacetype struct { typ _type pkgpath name mhdr []imethod } 其中typ和itab中的_type为同一个值，pkgpath则存储了接口的包名，mhdr则表示接口所定义的函数列表。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"runtime篇一：接口","item":"http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"runtime篇一：接口","name":"runtime篇一：接口","description":"本系列代码基于golang1.19\n  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. 接口的内部结构 type iface struct { tab *itab data unsafe.Pointer } 一个接口是一个iface结构体，其中包含一个itab指针和一个unsafe.Pointer。\n概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。\n一个itab可以表示一个接口的类型和赋给这个接口的实体类型，即为接口的动态类型，而data所指向的unsafe.Pointer则指向接口的动态值。\n近距离来看itab：\ntype itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. \t_ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 其中inter字段描述了接口的类型，_type字段描述了实体类型，hash字段是类型哈希，用于类型匹配，fun字段放置和接口方法对应的具体数据类型的方法地址。\n再来看interfacetype\ntype interfacetype struct { typ _type pkgpath name mhdr []imethod } 其中typ和itab中的_type为同一个值，pkgpath则存储了接口的包名，mhdr则表示接口所定义的函数列表。","keywords":["golang","runtime"],"articleBody":" 本系列代码基于golang1.19\n  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. 接口的内部结构 type iface struct { tab *itab data unsafe.Pointer } 一个接口是一个iface结构体，其中包含一个itab指针和一个unsafe.Pointer。\n概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。\n一个itab可以表示一个接口的类型和赋给这个接口的实体类型，即为接口的动态类型，而data所指向的unsafe.Pointer则指向接口的动态值。\n近距离来看itab：\ntype itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches. \t_ [4]byte fun [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter. } 其中inter字段描述了接口的类型，_type字段描述了实体类型，hash字段是类型哈希，用于类型匹配，fun字段放置和接口方法对应的具体数据类型的方法地址。\n再来看interfacetype\ntype interfacetype struct { typ _type pkgpath name mhdr []imethod } 其中typ和itab中的_type为同一个值，pkgpath则存储了接口的包名，mhdr则表示接口所定义的函数列表。\n这样来看，一个接口主要有两个部分构成：第一是对于接口本身的描述，包括接口的包名iface.itab.inter.pkgpath、接口的函数列表iface.itab.inter.mhdr，接口的hash值iface.itab.hash。第二部分是对于实现接口的实体的描述，包括实体的类型iface.itab._type，实体的值iface.data。\n可以将itab的值输出看看：\ntype iface struct { tab *itab data unsafe.Pointer } type itab struct { inter *interfacetype _type uintptr hash uint32 _ [4]byte myfunc [1]uintptr } type interfacetype struct { mytype uintptr pkgpath string mhdr []uintptr } type Person interface { Walk() Say(words []string) string } type Student struct { name string age int } func (s Student) Walk() { return } func (s Student) Say(words []string) string { return strings.Join(words, \" \") } func main() { var p = Person(Student{ name: \"lichang\", age: 18, }) // 查看iface的结构 \tp_iface := *(*iface)(unsafe.Pointer(\u0026p)) fmt.Println(p_iface.tab) // 查看接口的动态值 \ts := (*Student)(unsafe.Pointer(p_iface.data)) fmt.Println(*s) } 输出：\n\u0026{0x489a80 4773888 3558907866 [0 0 0 0] [4234176]} {lichang 18} 而对于一个空接口来说，其并不是一个iface，而是一个eface:\ntype eface struct { _type *_type data unsafe.Pointer } 一个空接口，其没有函数列表，用于描述空接口的结构体只有两个字段，一是_type，表示实体类型，二是data，指向动态值。\n2. 接口的类型转换 2.1 结构体到接口类型的转换 对于如下代码：\ntype Person interface { Walk() Say(words []string) string } type Student struct { name string age int } func (s Student) Walk() { return } func (s Student) Say(words []string) string { return strings.Join(words, \" \") } func main() { var p = Person(Student{ name: \"lichang\", age: 18, }) fmt.Println(p) } 通过查看汇编代码可知，其在进行Student-Person的转换时，调用了runtime.convT，来看一下这个函数：\nfunc convT(t *_type, v unsafe.Pointer) unsafe.Pointer { // ... 部分条件检查  x := mallocgc(t.size, t, true) typedmemmove(t, x, v) return x } func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer func typedmemmove(typ *_type, dst, src unsafe.Pointer) convT函数接收一个*_type：t, 一个unsafe.Pointer：v，将类型为t的v指向的值转换为一个可以作为iface结构体第二个字段的值。\n真正工作的只有两行，第一行分配一个类型为t的新的内存空间，并为其赋零值，第二行将v指向的值复制到x，最后返回。\n对于如下代码：\nvar _ Person = (*Student)(nil) 可以检查Student是否实现了Person接口，其底层同样是调用的runtime.convT()，如果Student未实现Person接口，则在typedmemmove会发生panic\n主要汇编代码如下：\n0x0027 00039 (main.go:28) LEAQ go.string.\"lichang\"(SB), CX\t# 将字符串从内存装载到CX中 0x002e 00046 (main.go:28) MOVQ CX, \"\"..autotmp_6+56(SP)\t# CX中的值被mov到\"\"..autotmp_6+56(SP) 0x0033 00051 (main.go:28) MOVQ $7, \"\"..autotmp_6+64(SP)\t# 字面量7被mov到\"\"..autotmp_6+64(SP)，这里可能是要做内存对齐 0x003c 00060 (main.go:29) MOVQ $18, \"\"..autotmp_6+72(SP)\t# 字面量18被mov到\"\"..autotmp_6+72(SP) 0x0045 00069 (main.go:27) LEAQ type.\"\".Student(SB), AX\t# 组装好的Student被装载到AX 0x004c 00076 (main.go:27) LEAQ \"\"..autotmp_6+56(SP), BX\t# \"\"..autotmp_6+56(SP)被装载到BX 0x0051 00081 (main.go:27) PCDATA $1, $0 0x0051 00081 (main.go:27) CALL runtime.convT(SB)\t# 调用runtime.convT构造itab 0x0056 00086 (main.go:32) MOVUPS X15, \"\"..autotmp_11+40(SP) 0x005c 00092 (main.go:32) MOVQ go.itab.\"\".Student,\"\".Person+8(SB), CX # 构造好的itab被装载到CX 0x0063 00099 (main.go:32) MOVQ CX, \"\"..autotmp_11+40(SP)\t# CX中的值，即itab被mov到\"\"..autotmp_11+40(SP) 0x0068 00104 (main.go:32) MOVQ AX, \"\"..autotmp_11+48(SP)\t# AX中的值，即Student字面量被装载到\"\"..autotmp_11+48(SP) 2.2 接口类型之间的转换 type Person interface { Walk() Say(words []string) string } type Walker interface { Walk() } type Student struct { name string age int } func (s Student) Walk() { return } func (s Student) Say(words []string) string { return strings.Join(words, \" \") } func main() { var p = Person(Student{ name: \"lichang\", age: 18, }) var w Walker = p fmt.Println(w) } 编译后查看汇编代码可知，在进行Person接口到Student接口的转换时调用了runtime.convI2I:\nfunc convI2I(dst *interfacetype, src *itab) *itab { if src == nil { return nil } if src.inter == dst { return src } return getitab(dst, src._type, false) } runtime.convI2I函数将src itab中的inter转换到dst类型，并返回一个新的itab，首先检查src不为空，然后判断src的inter是否与dst相等，最后调用了runtime.getitab\n来看runtime.getitab\nfunc getitab(inter *interfacetype, typ *_type, canfail bool) *itab { // ...  var m *itab // 首先会从已经存在的表中查找，如果找到了可以直接结束，否则进行下一步。  // 这里使用原子操作保证在这之前对itabTable的写操作结束。 \tt := (*itabTableType)(atomic.Loadp(unsafe.Pointer(\u0026itabTable))) if m = t.find(inter, typ); m != nil { goto finish } // 如果没找到，加锁继续找 \tlock(\u0026itabLock) if m = itabTable.find(inter, typ); m != nil { unlock(\u0026itabLock) goto finish } // 还没找到，搞个新的 \tm = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*goarch.PtrSize, 0, \u0026memstats.other_sys)) m.inter = inter m._type = typ m.hash = 0 m.init() itabAdd(m) unlock(\u0026itabLock) finish: if m.fun[0] != 0 { return m } if canfail { return nil } panic(\u0026TypeAssertionError{concrete: typ, asserted: \u0026inter.typ, missingMethod: m.init()}) } 这里一开始在构造itab时并没有直接构造，而是去一个runtime.itabTableType结构体中去查找这个itab是否存在，runtime.itabTableType的定义如下：\ntype itabTableType struct { size uintptr // length of entries array. Always a power of 2. \tcount uintptr // current number of filled entries. \tentries [itabInitSize]*itab // really [size] large } 用于查找itab的函数如下：\nfunc (t *itabTableType) find(inter *interfacetype, typ *_type) *itab { // Implemented using quadratic probing. \t// Probe sequence is h(i) = h0 + i*(i+1)/2 mod 2^k. \t// We're guaranteed to hit all table entries using this probe sequence. \tmask := t.size - 1 h := itabHashFunc(inter, typ) \u0026 mask for i := uintptr(1); ; i++ { p := (**itab)(add(unsafe.Pointer(\u0026t.entries), h*goarch.PtrSize)) // Use atomic read here so if we see m != nil, we also see \t// the initializations of the fields of m. \t// m := *p \tm := (*itab)(atomic.Loadp(unsafe.Pointer(p))) if m == nil { return nil } if m.inter == inter \u0026\u0026 m._type == typ { return m } h += i h \u0026= mask } } 在完成这些步骤之后，一个新的itab就构造完成了，而由于在进行转换时实现接口的实体并没有变化，只是接口类型发生了变化，因此我们只需要将iface.itab重新赋值为我们需要的itab即可。\n2.3 空接口的转换 func main() { var x int = 1 var ix interface{} = x fmt.Println(ix) } 这里调用的是runtime.convT64(SB)函数：\nfunc convT64(val uint64) (x unsafe.Pointer) { if val staticuint64s)) { x = unsafe.Pointer(\u0026staticuint64s[val]) } else { x = mallocgc(8, uint64Type, false) *(*uint64)(x) = val } return } 这里首先检查其值是否小于len(staticuint64s)，如果是的话，就不需要再去进行内存分配，而是直接到数组中取，算是进行了一步优化。否则调用mallocgc为其分配一个新的内存空间，然后将其底层值赋值为val。\n这里如果是将一个字符串转换为空接口类型，则调用的是runtime.convTstring:\nfunc convTstring(val string) (x unsafe.Pointer) { if val == \"\" { x = unsafe.Pointer(\u0026zeroVal[0]) } else { x = mallocgc(unsafe.Sizeof(val), stringType, true) *(*string)(x) = val } return } 逻辑相差不大。\n在runtime包中，对于某些特殊的类型做了优化，可直接调用相应的函数进行实体类型到空接口类型的转化，这些被调用的函数有：\nfunc convT16(val uint16) unsafe.Pointer func convT32(val uint32) unsafe.Pointer func convT64(val uint64) unsafe.Pointer func convTstring(val string) unsafe.Pointer func convTslice(val []uint8) unsafe.Pointer 3. 类型断言 3.1 空接口断言 对如下golang代码进行编译：\ntype User struct { name string } func main() { var x interface{} = \u0026User{name: \"lichang\"} i, ok := x.(int) if !ok { return } else { fmt.Println(i) } } 使用如下命令编译\ngo tool compile -S -N -l main.go # -N禁止优化，-l禁止内联 # 构造接口 0x0026 00038 (main.go:11) MOVUPS X15, \"\"..autotmp_8+96(SP) 0x002c 00044 (main.go:11) LEAQ \"\"..autotmp_8+96(SP), CX 0x0031 00049 (main.go:11) MOVQ CX, \"\"..autotmp_7+48(SP) 0x0036 00054 (main.go:11) TESTB AL, (CX) 0x0038 00056 (main.go:11) MOVQ $7, \"\"..autotmp_8+104(SP) 0x0041 00065 (main.go:11) LEAQ go.string.\"lichang\"(SB), DX 0x0048 00072 (main.go:11) MOVQ DX, \"\"..autotmp_8+96(SP) 0x004d 00077 (main.go:11) MOVQ CX, \"\"..autotmp_3+56(SP) 0x0052 00082 (main.go:11) LEAQ type.*\"\".User(SB), DX 0x0059 00089 (main.go:11) MOVQ DX, \"\".x+80(SP) # \"\".x+80(SP)是eface._type 0x005e 00094 (main.go:11) MOVQ CX, \"\".x+88(SP)\t# \"\".x+88(SP)是eface.data # 接口断言 0x0063 00099 (main.go:13) MOVQ \"\".x+80(SP), CX\t# 将eface._type移动到CX 0x0068 00104 (main.go:13) MOVQ \"\".x+88(SP), DX\t# 将eface._data移动到DX 0x006d 00109 (main.go:13) LEAQ type.int(SB), BX\t# 加载int的_type到BX 0x0074 00116 (main.go:13) CMPQ CX, BX\t# 对比CX与BX，即eface._type与int._type 0x0077 00119 (main.go:13) JEQ 123\t# 如果_type对比成功，则跳转到123 0x0079 00121 (main.go:13) JMP 133\t# 对比不成功，跳转133 0x007b 00123 (main.go:13) MOVQ (DX), CX\t# 将eface.data暂存到CX 0x007e 00126 (main.go:13) MOVL $1, AX 0x0083 00131 (main.go:13) JMP 139 0x0085 00133 (main.go:13) XORL CX, CX\t# 类型断言失败，清空寄存器 0x0087 00135 (main.go:13) XORL AX, AX\t# 清空AX寄存器 0x0089 00137 (main.go:13) JMP 139 0x008b 00139 (main.go:13) MOVQ CX, \"\"..autotmp_4+40(SP) 0x0090 00144 (main.go:13) MOVB AL, \"\"..autotmp_5+31(SP) 0x0094 00148 (main.go:13) MOVQ \"\"..autotmp_4+40(SP), CX 0x0099 00153 (main.go:13) MOVQ CX, \"\".i+32(SP)\t# 断言结果保存在\"\".i+32(SP) 0x009e 00158 (main.go:13) MOVBLZX \"\"..autotmp_5+31(SP), CX 0x00a3 00163 (main.go:13) MOVB CL, \"\".ok+30(SP)\t# ok保存在\"\".ok+30(SP) 从以上汇编代码可以看出，空接口在进行类型断言时，会将eface._type取出与断言类型的_type进行对比，如果对比成功，则将其eface.data取出使用，否则断言失败。\n3.2 非空接口断言 3.2.1 断言为接口 对如下代码进行编译：\ntype Person interface { Walk() Say(words []string) string } type Walker interface { Walk() } type Student struct { name string age int } func (s Student) Walk() { return } func (s Student) Say(words []string) string { return strings.Join(words, \" \") } func main() { var p = Person(Student{ name: \"lichang\", age: 18, }) w, ok := p.(Walker) if !ok { return } else { fmt.Println(w) } } go tool compile -S -N -l main.go 可得部分汇编代码如下：\n# iface构建 0x0026 00038 (main.go:32) MOVQ $0, \"\"..autotmp_3+176(SP) 0x0032 00050 (main.go:31) MOVUPS X15, \"\"..autotmp_3+184(SP) 0x003b 00059 (main.go:32) LEAQ go.string.\"lichang\"(SB), CX 0x0042 00066 (main.go:32) MOVQ CX, \"\"..autotmp_3+176(SP) 0x004a 00074 (main.go:32) MOVQ $7, \"\"..autotmp_3+184(SP) 0x0056 00086 (main.go:33) MOVQ $18, \"\"..autotmp_3+192(SP) 0x0062 00098 (main.go:31) LEAQ type.\"\".Student(SB), AX 0x0069 00105 (main.go:31) LEAQ \"\"..autotmp_3+176(SP), BX 0x0071 00113 (main.go:31) PCDATA $1, $0 0x0071 00113 (main.go:31) CALL runtime.convT(SB) 0x0076 00118 (main.go:31) MOVQ AX, \"\"..autotmp_7+56(SP) 0x007b 00123 (main.go:31) LEAQ go.itab.\"\".Student,\"\".Person(SB), CX 0x0082 00130 (main.go:31) MOVQ CX, \"\".p+88(SP)\t# iface.itab在\"\".p+88(SP)处 0x0087 00135 (main.go:31) MOVQ AX, \"\".p+96(SP)\t# iface.data在\"\".p+96(SP)处 # 类型断言 0x008c 00140 (main.go:36) MOVUPS X15, \"\"..autotmp_4+120(SP) 0x0092 00146 (main.go:36) MOVQ \"\".p+88(SP), BX\t# iface.itab被转移到BX 0x0097 00151 (main.go:36) MOVQ \"\".p+96(SP), CX\t# iface.data被转移到CX 0x009c 00156 (main.go:36) LEAQ type.\"\".Walker(SB), AX\t# Walker._type被加载到AX 0x00a3 00163 (main.go:36) CALL runtime.assertI2I2(SB)\t# 调用runtime.assertI2I2 0x00a8 00168 (main.go:36) MOVQ AX, \"\"..autotmp_4+120(SP)\t# runtime.assertI2I2的返回值存储在\"\"..autotmp_4+120(SP) 0x00ad 00173 (main.go:36) MOVQ BX, \"\"..autotmp_4+128(SP) 0x00b5 00181 (main.go:36) TESTQ AX, AX 0x00b8 00184 (main.go:36) SETNE \"\"..autotmp_5+47(SP) 0x00bd 00189 (main.go:36) MOVQ \"\"..autotmp_4+128(SP), CX 0x00c5 00197 (main.go:36) MOVQ \"\"..autotmp_4+120(SP), DX 0x00ca 00202 (main.go:36) MOVQ DX, \"\".w+72(SP)\t# 断言接口的itab在\"\".w+72(SP) 0x00cf 00207 (main.go:36) MOVQ CX, \"\".w+80(SP)\t# 断言接口的data在\"\".w+80(SP) 0x00d4 00212 (main.go:36) MOVBLZX \"\"..autotmp_5+47(SP), CX 0x00d9 00217 (main.go:36) MOVB CL, \"\".ok+46(SP)\t# ok被存储在\"\".ok+46(SP) runtime.assertI2I2函数如下：\nfunc assertI2I2(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { return } if tab.inter != inter { tab = getitab(inter, tab._type, true) if tab == nil { return } } r.tab = tab r.data = i.data return } 该函数接受一个一个interfacetype和一个iface，检查iface.itab.inter是否与传入的interfacetype相同，若相同，则直接将原来的iface复制一个新的返回，否则构建一个具有传入的interfacetype的新的itab，并赋值给新的iface;iface.data直接复制到新的iface。\n3.2.2 断言为实体对象 对如下代码进行编译：\ntype Person interface { Walk() Say(words []string) string } type Student struct { name string age int } func (s Student) Walk() { return } func (s Student) Say(words []string) string { return strings.Join(words, \" \") } func main() { var p = Person(Student{ name: \"lichang\", age: 18, }) w, ok := p.(Student) if !ok { return } else { fmt.Println(w) } } go tool compile -S -N -l main.go 有关类型断言的汇编代码如下：\n# 接口构造 0x0035 00053 (main.go:27) MOVUPS X15, \"\"..autotmp_8+224(SP) 0x003e 00062 (main.go:28) LEAQ go.string.\"lichang\"(SB), CX 0x0045 00069 (main.go:28) MOVQ CX, \"\"..autotmp_8+216(SP) 0x004d 00077 (main.go:28) MOVQ $7, \"\"..autotmp_8+224(SP) 0x0059 00089 (main.go:29) MOVQ $18, \"\"..autotmp_8+232(SP) 0x0065 00101 (main.go:27) MOVQ CX, \"\"..autotmp_12+240(SP) 0x006d 00109 (main.go:27) MOVQ $7, \"\"..autotmp_12+248(SP) 0x0079 00121 (main.go:27) MOVQ $18, \"\"..autotmp_12+256(SP) 0x0085 00133 (main.go:27) LEAQ go.itab.\"\".Student,\"\".Person(SB), CX 0x008c 00140 (main.go:27) MOVQ CX, \"\".p+88(SP)\t# iface.itab 0x0091 00145 (main.go:27) LEAQ \"\"..autotmp_12+240(SP), CX 0x0099 00153 (main.go:27) MOVQ CX, \"\".p+96(SP)\t# iface.data # 类型断言 0x009e 00158 (main.go:32) MOVQ $0, \"\"..autotmp_8+216(SP) 0x00aa 00170 (main.go:32) MOVUPS X15, \"\"..autotmp_8+224(SP) 0x00b3 00179 (main.go:32) MOVQ \"\".p+96(SP), CX\t# iface.data被装载到CX 0x00b8 00184 (main.go:32) MOVQ \"\".p+88(SP), DX\t# iface.itab被装载到DX 0x00bd 00189 (main.go:32) LEAQ go.itab.\"\".Student,\"\".Person(SB), SI # 重新构造一个itab，存储在SI 0x00c4 00196 (main.go:32) CMPQ DX, SI # 对比新构造的itab和老的itab 0x00c7 00199 (main.go:32) JEQ 203 0x00c9 00201 (main.go:32) JMP 221 0x00cb 00203 (main.go:32) MOVQ (CX), DX\t# CX(iface.data)指向的值0-7个字节mov到DX 0x00ce 00206 (main.go:32) MOVQ 8(CX), SI\t# 第8-15个字节mov到SI 0x00d2 00210 (main.go:32) MOVQ 16(CX), CX\t# 第16-24个字节mov到CX 0x00d6 00214 (main.go:32) MOVL $1, AX 0x00db 00219 (main.go:32) JMP 231 0x00dd 00221 (main.go:32) XORL SI, SI\t# 断言失败执行 0x00df 00223 (main.go:32) XORL CX, CX 0x00e1 00225 (main.go:32) XORL AX, AX 0x00e3 00227 (main.go:32) XORL DX, DX 0x00e5 00229 (main.go:32) JMP 231 0x00e7 00231 (main.go:32) MOVQ DX, \"\"..autotmp_8+216(SP) 0x00ef 00239 (main.go:32) MOVQ SI, \"\"..autotmp_8+224(SP) 0x00f7 00247 (main.go:32) MOVQ CX, \"\"..autotmp_8+232(SP) 0x00ff 00255 (main.go:32) MOVB AL, \"\"..autotmp_9+47(SP) 0x0103 00259 (main.go:32) MOVQ \"\"..autotmp_8+216(SP), CX 0x010b 00267 (main.go:32) MOVQ \"\"..autotmp_8+224(SP), DX 0x0113 00275 (main.go:32) MOVQ \"\"..autotmp_8+232(SP), SI 0x011b 00283 (main.go:32) MOVQ CX, \"\".s+168(SP)\t# 构造Student结构体 0x0123 00291 (main.go:32) MOVQ DX, \"\".s+176(SP) 0x012b 00299 (main.go:32) MOVQ SI, \"\".s+184(SP) 0x0133 00307 (main.go:32) MOVBLZX \"\"..autotmp_9+47(SP), CX 0x0138 00312 (main.go:32) MOVB CL, \"\".ok+46(SP)\t# ok存储在\"\".ok+46(SP) 在进行接口到实体对象的断言时，编译器会尝试构建一个断言对象对应的itab，然后和原接口的itab进行对比，如果相同，则断言可成功，否则失败。\n断言成功后，将iface.data解析，重新组装成断言对象。断言失败则清空寄存器，返回一个断言对象的零值\nReferences Go Questions\ninterface的类型断言是如何实现\n","wordCount":"1743","inLanguage":"en","datePublished":"2022-08-04T00:00:00Z","dateModified":"2022-08-04T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>runtime篇一：接口</h1><div class=post-meta><span title="2022-08-04 00:00:00 +0000 UTC">August 4, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%86%85%e9%83%a8%e7%bb%93%e6%9e%84 aria-label="1. 接口的内部结构">1. 接口的内部结构</a></li><li><a href=#2-%e6%8e%a5%e5%8f%a3%e7%9a%84%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label="2. 接口的类型转换">2. 接口的类型转换</a><ul><li><a href=#21-%e7%bb%93%e6%9e%84%e4%bd%93%e5%88%b0%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label="2.1 结构体到接口类型的转换">2.1 结构体到接口类型的转换</a></li><li><a href=#22-%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label="2.2 接口类型之间的转换">2.2 接口类型之间的转换</a></li><li><a href=#23-%e7%a9%ba%e6%8e%a5%e5%8f%a3%e7%9a%84%e8%bd%ac%e6%8d%a2 aria-label="2.3 空接口的转换">2.3 空接口的转换</a></li></ul></li><li><a href=#3-%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80 aria-label="3. 类型断言">3. 类型断言</a><ul><li><a href=#31-%e7%a9%ba%e6%8e%a5%e5%8f%a3%e6%96%ad%e8%a8%80 aria-label="3.1 空接口断言">3.1 空接口断言</a></li><li><a href=#32-%e9%9d%9e%e7%a9%ba%e6%8e%a5%e5%8f%a3%e6%96%ad%e8%a8%80 aria-label="3.2 非空接口断言">3.2 非空接口断言</a><ul><li><a href=#321-%e6%96%ad%e8%a8%80%e4%b8%ba%e6%8e%a5%e5%8f%a3 aria-label="3.2.1 断言为接口">3.2.1 断言为接口</a></li><li><a href=#322-%e6%96%ad%e8%a8%80%e4%b8%ba%e5%ae%9e%e4%bd%93%e5%af%b9%e8%b1%a1 aria-label="3.2.2 断言为实体对象">3.2.2 断言为实体对象</a></li></ul></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><blockquote><p>本系列代码基于<a href=https://github.com/golang/go/tree/1e5987635cc8bf99e8a20d240da80bd6f0f793f7>golang1.19</a></p></blockquote><ul><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/>runtime篇一：接口</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/>runtime篇二：通道</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/>runtime篇三：defer</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/>runtime篇四：panic</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%94slice/>runtime篇五：slice</a></li></ul><h2 id=1-接口的内部结构>1. 接口的内部结构<a hidden class=anchor aria-hidden=true href=#1-接口的内部结构>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>iface</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>tab</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span>
	<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
}
</code></pre></div><p>一个接口是一个<code>iface</code>结构体，其中包含一个<code>itab</code>指针和一个<code>unsafe.Pointer</code>。</p><p>概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。</p><p>一个<code>itab</code>可以表示一个接口的类型和赋给这个接口的实体类型，即为接口的动态类型，而<code>data</code>所指向的<code>unsafe.Pointer</code>则指向接口的动态值。</p><p>近距离来看<code>itab</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>itab</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>inter</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>interfacetype</span>
	<span style=color:#a6e22e>_type</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
	<span style=color:#a6e22e>hash</span>  <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// copy of _type.hash. Used for type switches.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>_</span>     [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>
	<span style=color:#a6e22e>fun</span>   [<span style=color:#ae81ff>1</span>]<span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// variable sized. fun[0]==0 means _type does not implement inter.
</span><span style=color:#75715e></span>}
</code></pre></div><p>其中<code>inter</code>字段描述了接口的类型，<code>_type</code>字段描述了实体类型，<code>hash</code>字段是类型哈希，用于类型匹配，<code>fun</code>字段放置和接口方法对应的具体数据类型的方法地址。</p><p>再来看<code>interfacetype</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>interfacetype</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>typ</span>     <span style=color:#a6e22e>_type</span>
	<span style=color:#a6e22e>pkgpath</span> <span style=color:#a6e22e>name</span>
	<span style=color:#a6e22e>mhdr</span>    []<span style=color:#a6e22e>imethod</span>
}
</code></pre></div><p>其中<code>typ</code>和<code>itab</code>中的<code>_type</code>为同一个值，<code>pkgpath</code>则存储了接口的包名，<code>mhdr</code>则表示接口所定义的函数列表。</p><p>这样来看，一个接口主要有两个部分构成：第一是对于接口本身的描述，包括接口的包名<code>iface.itab.inter.pkgpath</code>、接口的函数列表<code>iface.itab.inter.mhdr</code>，接口的hash值<code>iface.itab.hash</code>。第二部分是对于实现接口的实体的描述，包括实体的类型<code>iface.itab._type</code>，实体的值<code>iface.data</code>。</p><p>可以将itab的值输出看看：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>iface</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>tab</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span>
	<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>itab</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>inter</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>interfacetype</span>
	<span style=color:#a6e22e>_type</span>  <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>hash</span>   <span style=color:#66d9ef>uint32</span>
	<span style=color:#a6e22e>_</span>      [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>
	<span style=color:#a6e22e>myfunc</span> [<span style=color:#ae81ff>1</span>]<span style=color:#66d9ef>uintptr</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>interfacetype</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>mytype</span>  <span style=color:#66d9ef>uintptr</span>
	<span style=color:#a6e22e>pkgpath</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>mhdr</span>    []<span style=color:#66d9ef>uintptr</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Walk</span>()
	<span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>age</span>  <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Walk</span>() {
	<span style=color:#66d9ef>return</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>words</span>, <span style=color:#e6db74>&#34; &#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>Person</span>(<span style=color:#a6e22e>Student</span>{
		<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lichang&#34;</span>,
		<span style=color:#a6e22e>age</span>:  <span style=color:#ae81ff>18</span>,
	})

	<span style=color:#75715e>// 查看iface的结构
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>p_iface</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>iface</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>))
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>p_iface</span>.<span style=color:#a6e22e>tab</span>)

	<span style=color:#75715e>// 查看接口的动态值
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>Student</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p_iface</span>.<span style=color:#a6e22e>data</span>))
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>s</span>)
}
</code></pre></div><p>输出：</p><pre><code>&amp;{0x489a80 4773888 3558907866 [0 0 0 0] [4234176]}
{lichang 18}
</code></pre><p>而对于一个空接口来说，其并不是一个<code>iface</code>，而是一个<code>eface</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>eface</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>_type</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
	<span style=color:#a6e22e>data</span>  <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
}
</code></pre></div><p>一个空接口，其没有函数列表，用于描述空接口的结构体只有两个字段，一是<code>_type</code>，表示实体类型，二是<code>data</code>，指向动态值。</p><h2 id=2-接口的类型转换>2. 接口的类型转换<a hidden class=anchor aria-hidden=true href=#2-接口的类型转换>#</a></h2><h3 id=21-结构体到接口类型的转换>2.1 结构体到接口类型的转换<a hidden class=anchor aria-hidden=true href=#21-结构体到接口类型的转换>#</a></h3><p>对于如下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Walk</span>()
	<span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>age</span>  <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Walk</span>() {
	<span style=color:#66d9ef>return</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>words</span>, <span style=color:#e6db74>&#34; &#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>Person</span>(<span style=color:#a6e22e>Student</span>{
		<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lichang&#34;</span>,
		<span style=color:#a6e22e>age</span>:  <span style=color:#ae81ff>18</span>,
	})

	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>p</span>)
}
</code></pre></div><p>通过查看汇编代码可知，其在进行<code>Student</code>-><code>Person</code>的转换时，调用了<code>runtime.convT</code>，来看一下这个函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convT</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>v</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
	<span style=color:#75715e>// ... 部分条件检查
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>size</span>, <span style=color:#a6e22e>t</span>, <span style=color:#66d9ef>true</span>)
	<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>v</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>needzero</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>src</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)
</code></pre></div><p><code>convT</code>函数接收一个<code>*_type</code>：t, 一个<code>unsafe.Pointer</code>：v，将类型为t的v指向的值转换为一个可以作为iface结构体第二个字段的值。</p><p>真正工作的只有两行，第一行分配一个类型为t的新的内存空间，并为其赋零值，第二行将v指向的值复制到x，最后返回。</p><p>对于如下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_</span> <span style=color:#a6e22e>Person</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>Student</span>)(<span style=color:#66d9ef>nil</span>)
</code></pre></div><p>可以检查Student是否实现了Person接口，其底层同样是调用的<code>runtime.convT()</code>，如果Student未实现Person接口，则在typedmemmove会发生panic</p><p>主要汇编代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=color:#ae81ff>0x0027</span> <span style=color:#ae81ff>00039</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>28</span>)       LEAQ    go.string.<span style=color:#e6db74>&#34;lichang&#34;</span>(SB), CX		<span style=color:#75715e># 将字符串从内存装载到CX中</span>
<span style=color:#ae81ff>0x002e</span> <span style=color:#ae81ff>00046</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>28</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_6<span style=color:#ae81ff>+56</span>(SP)		<span style=color:#75715e># CX中的值被mov到&#34;&#34;..autotmp_6+56(SP)</span>
<span style=color:#ae81ff>0x0033</span> <span style=color:#ae81ff>00051</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>28</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>7</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_6<span style=color:#ae81ff>+64</span>(SP)		<span style=color:#75715e># 字面量7被mov到&#34;&#34;..autotmp_6+64(SP)，这里可能是要做内存对齐</span>
<span style=color:#ae81ff>0x003c</span> <span style=color:#ae81ff>00060</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>29</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>18</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_6<span style=color:#ae81ff>+72</span>(SP)		<span style=color:#75715e># 字面量18被mov到&#34;&#34;..autotmp_6+72(SP)</span>
<span style=color:#ae81ff>0x0045</span> <span style=color:#ae81ff>00069</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       LEAQ    type.<span style=color:#e6db74>&#34;&#34;</span><span style=color:#a6e22e>.Student</span>(SB), AX			<span style=color:#75715e># 组装好的Student被装载到AX</span>
<span style=color:#ae81ff>0x004c</span> <span style=color:#ae81ff>00076</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       LEAQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_6<span style=color:#ae81ff>+56</span>(SP), BX		<span style=color:#75715e># &#34;&#34;..autotmp_6+56(SP)被装载到BX</span>
<span style=color:#ae81ff>0x0051</span> <span style=color:#ae81ff>00081</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       PCDATA  <span style=color:#f92672>$</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>$</span><span style=color:#ae81ff>0</span>
<span style=color:#ae81ff>0x0051</span> <span style=color:#ae81ff>00081</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       CALL    <span style=color:#a6e22e>runtime.convT</span>(SB)				<span style=color:#75715e># 调用runtime.convT构造itab</span>
<span style=color:#ae81ff>0x0056</span> <span style=color:#ae81ff>00086</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVUPS  X15, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_11<span style=color:#ae81ff>+40</span>(SP)
<span style=color:#ae81ff>0x005c</span> <span style=color:#ae81ff>00092</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    go.itab.<span style=color:#e6db74>&#34;&#34;</span>.Student,<span style=color:#e6db74>&#34;&#34;</span>.Person<span style=color:#ae81ff>+8</span>(SB), CX <span style=color:#75715e># 构造好的itab被装载到CX</span>
<span style=color:#ae81ff>0x0063</span> <span style=color:#ae81ff>00099</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_11<span style=color:#ae81ff>+40</span>(SP)		<span style=color:#75715e># CX中的值，即itab被mov到&#34;&#34;..autotmp_11+40(SP)</span>
<span style=color:#ae81ff>0x0068</span> <span style=color:#ae81ff>00104</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    AX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_11<span style=color:#ae81ff>+48</span>(SP)		<span style=color:#75715e># AX中的值，即Student字面量被装载到&#34;&#34;..autotmp_11+48(SP)</span>
</code></pre></div><h3 id=22-接口类型之间的转换>2.2 接口类型之间的转换<a hidden class=anchor aria-hidden=true href=#22-接口类型之间的转换>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Walk</span>()
	<span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Walker</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Walk</span>()
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>age</span>  <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Walk</span>() {
	<span style=color:#66d9ef>return</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>words</span>, <span style=color:#e6db74>&#34; &#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>Person</span>(<span style=color:#a6e22e>Student</span>{
		<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lichang&#34;</span>,
		<span style=color:#a6e22e>age</span>:  <span style=color:#ae81ff>18</span>,
	})

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>w</span> <span style=color:#a6e22e>Walker</span> = <span style=color:#a6e22e>p</span>

	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>w</span>)
}
</code></pre></div><p>编译后查看汇编代码可知，在进行<code>Person</code>接口到<code>Student</code>接口的转换时调用了<code>runtime.convI2I</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convI2I</span>(<span style=color:#a6e22e>dst</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>interfacetype</span>, <span style=color:#a6e22e>src</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>src</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>src</span>.<span style=color:#a6e22e>inter</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>dst</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>src</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>getitab</span>(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>src</span>.<span style=color:#a6e22e>_type</span>, <span style=color:#66d9ef>false</span>)
}
</code></pre></div><p><code>runtime.convI2I</code>函数将src itab中的inter转换到dst类型，并返回一个新的itab，首先检查src不为空，然后判断src的inter是否与dst相等，最后调用了<code>runtime.getitab</code></p><p>来看<code>runtime.getitab</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getitab</span>(<span style=color:#a6e22e>inter</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>interfacetype</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>canfail</span> <span style=color:#66d9ef>bool</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span> {
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span>

    <span style=color:#75715e>// 首先会从已经存在的表中查找，如果找到了可以直接结束，否则进行下一步。
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 这里使用原子操作保证在这之前对itabTable的写操作结束。
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>itabTableType</span>)(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Loadp</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>itabTable</span>)))
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span> = <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>find</span>(<span style=color:#a6e22e>inter</span>, <span style=color:#a6e22e>typ</span>); <span style=color:#a6e22e>m</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>finish</span>
	}

	<span style=color:#75715e>// 如果没找到，加锁继续找
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>itabLock</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span> = <span style=color:#a6e22e>itabTable</span>.<span style=color:#a6e22e>find</span>(<span style=color:#a6e22e>inter</span>, <span style=color:#a6e22e>typ</span>); <span style=color:#a6e22e>m</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>itabLock</span>)
		<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>finish</span>
	}

    <span style=color:#75715e>// 还没找到，搞个新的
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>m</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span>)(<span style=color:#a6e22e>persistentalloc</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>itab</span>{})<span style=color:#f92672>+</span>uintptr(len(<span style=color:#a6e22e>inter</span>.<span style=color:#a6e22e>mhdr</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>*</span><span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>memstats</span>.<span style=color:#a6e22e>other_sys</span>))
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>inter</span> = <span style=color:#a6e22e>inter</span>
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>_type</span> = <span style=color:#a6e22e>typ</span>
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>hash</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>init</span>()
	<span style=color:#a6e22e>itabAdd</span>(<span style=color:#a6e22e>m</span>)
	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>itabLock</span>)
<span style=color:#a6e22e>finish</span>:
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>fun</span>[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>canfail</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
	}

	panic(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TypeAssertionError</span>{<span style=color:#a6e22e>concrete</span>: <span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>asserted</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>inter</span>.<span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>missingMethod</span>: <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>init</span>()})
}
</code></pre></div><p>这里一开始在构造<code>itab</code>时并没有直接构造，而是去一个<code>runtime.itabTableType</code>结构体中去查找这个<code>itab</code>是否存在，<code>runtime.itabTableType</code>的定义如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>itabTableType</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>size</span>    <span style=color:#66d9ef>uintptr</span>             <span style=color:#75715e>// length of entries array. Always a power of 2.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>count</span>   <span style=color:#66d9ef>uintptr</span>             <span style=color:#75715e>// current number of filled entries.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>entries</span> [<span style=color:#a6e22e>itabInitSize</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span> <span style=color:#75715e>// really [size] large
</span><span style=color:#75715e></span>}
</code></pre></div><p>用于查找<code>itab</code>的函数如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>itabTableType</span>) <span style=color:#a6e22e>find</span>(<span style=color:#a6e22e>inter</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>interfacetype</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span> {
	<span style=color:#75715e>// Implemented using quadratic probing.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// Probe sequence is h(i) = h0 + i*(i+1)/2 mod 2^k.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// We&#39;re guaranteed to hit all table entries using this probe sequence.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>mask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>itabHashFunc</span>(<span style=color:#a6e22e>inter</span>, <span style=color:#a6e22e>typ</span>) <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>mask</span>
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>1</span>); ; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>**</span><span style=color:#a6e22e>itab</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>entries</span>), <span style=color:#a6e22e>h</span><span style=color:#f92672>*</span><span style=color:#a6e22e>goarch</span>.<span style=color:#a6e22e>PtrSize</span>))
		<span style=color:#75715e>// Use atomic read here so if we see m != nil, we also see
</span><span style=color:#75715e></span>		<span style=color:#75715e>// the initializations of the fields of m.
</span><span style=color:#75715e></span>		<span style=color:#75715e>// m := *p
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span>)(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Loadp</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p</span>)))
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>inter</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>inter</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>_type</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>typ</span> {
			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m</span>
		}
		<span style=color:#a6e22e>h</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>i</span>
		<span style=color:#a6e22e>h</span> <span style=color:#f92672>&amp;=</span> <span style=color:#a6e22e>mask</span>
	}
}
</code></pre></div><p>在完成这些步骤之后，一个新的<code>itab</code>就构造完成了，而由于在进行转换时实现接口的实体并没有变化，只是接口类型发生了变化，因此我们只需要将<code>iface.itab</code>重新赋值为我们需要的<code>itab</code>即可。</p><h3 id=23-空接口的转换>2.3 空接口的转换<a hidden class=anchor aria-hidden=true href=#23-空接口的转换>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span> = <span style=color:#ae81ff>1</span>

        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ix</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#a6e22e>x</span>

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ix</span>)
}
</code></pre></div><p>这里调用的是<code>runtime.convT64(SB)</code>函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convT64</span>(<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>x</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> &lt; uint64(len(<span style=color:#a6e22e>staticuint64s</span>)) {
		<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>staticuint64s</span>[<span style=color:#a6e22e>val</span>])
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>uint64Type</span>, <span style=color:#66d9ef>false</span>)
		<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>)(<span style=color:#a6e22e>x</span>) = <span style=color:#a6e22e>val</span>
	}
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>这里首先检查其值是否小于<code>len(staticuint64s)</code>，如果是的话，就不需要再去进行内存分配，而是直接到数组中取，算是进行了一步优化。否则调用<code>mallocgc</code>为其分配一个新的内存空间，然后将其底层值赋值为val。</p><p>这里如果是将一个字符串转换为空接口类型，则调用的是<code>runtime.convTstring</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convTstring</span>(<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>x</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
		<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>zeroVal</span>[<span style=color:#ae81ff>0</span>])
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>x</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>val</span>), <span style=color:#a6e22e>stringType</span>, <span style=color:#66d9ef>true</span>)
		<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>string</span>)(<span style=color:#a6e22e>x</span>) = <span style=color:#a6e22e>val</span>
	}
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>逻辑相差不大。</p><p>在runtime包中，对于某些特殊的类型做了优化，可直接调用相应的函数进行实体类型到空接口类型的转化，这些被调用的函数有：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convT16</span>(<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uint16</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convT32</span>(<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uint32</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convT64</span>(<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convTstring</span>(<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convTslice</span>(<span style=color:#a6e22e>val</span> []<span style=color:#66d9ef>uint8</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</code></pre></div><h2 id=3-类型断言>3. 类型断言<a hidden class=anchor aria-hidden=true href=#3-类型断言>#</a></h2><h3 id=31-空接口断言>3.1 空接口断言<a hidden class=anchor aria-hidden=true href=#31-空接口断言>#</a></h3><p>对如下golang代码进行编译：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>User</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{} = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>User</span>{<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lichang&#34;</span>}

	<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>.(<span style=color:#66d9ef>int</span>)

	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
		<span style=color:#66d9ef>return</span>
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
	}
}
</code></pre></div><p>使用如下命令编译</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>go tool compile -S -N -l  main.go <span style=color:#75715e># -N禁止优化，-l禁止内联</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=color:#75715e># 构造接口</span>
<span style=color:#ae81ff>0x0026</span> <span style=color:#ae81ff>00038</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       MOVUPS  X15, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+96</span>(SP)
<span style=color:#ae81ff>0x002c</span> <span style=color:#ae81ff>00044</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       LEAQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+96</span>(SP), CX
<span style=color:#ae81ff>0x0031</span> <span style=color:#ae81ff>00049</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_7<span style=color:#ae81ff>+48</span>(SP)
<span style=color:#ae81ff>0x0036</span> <span style=color:#ae81ff>00054</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       TESTB   AL, (CX)
<span style=color:#ae81ff>0x0038</span> <span style=color:#ae81ff>00056</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>7</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+104</span>(SP)
<span style=color:#ae81ff>0x0041</span> <span style=color:#ae81ff>00065</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       LEAQ    go.string.<span style=color:#e6db74>&#34;lichang&#34;</span>(SB), DX
<span style=color:#ae81ff>0x0048</span> <span style=color:#ae81ff>00072</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       MOVQ    DX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+96</span>(SP)
<span style=color:#ae81ff>0x004d</span> <span style=color:#ae81ff>00077</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_3<span style=color:#ae81ff>+56</span>(SP)
<span style=color:#ae81ff>0x0052</span> <span style=color:#ae81ff>00082</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       LEAQ    type.<span style=color:#f92672>*</span><span style=color:#e6db74>&#34;&#34;</span><span style=color:#a6e22e>.User</span>(SB), DX
<span style=color:#ae81ff>0x0059</span> <span style=color:#ae81ff>00089</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       MOVQ    DX, <span style=color:#e6db74>&#34;&#34;</span>.x<span style=color:#ae81ff>+80</span>(SP) 	<span style=color:#75715e># &#34;&#34;.x+80(SP)是eface._type</span>
<span style=color:#ae81ff>0x005e</span> <span style=color:#ae81ff>00094</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>11</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>.x<span style=color:#ae81ff>+88</span>(SP)		<span style=color:#75715e># &#34;&#34;.x+88(SP)是eface.data</span>

<span style=color:#75715e># 接口断言</span>
<span style=color:#ae81ff>0x0063</span> <span style=color:#ae81ff>00099</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>.x<span style=color:#ae81ff>+80</span>(SP), CX		<span style=color:#75715e># 将eface._type移动到CX</span>
<span style=color:#ae81ff>0x0068</span> <span style=color:#ae81ff>00104</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>.x<span style=color:#ae81ff>+88</span>(SP), DX		<span style=color:#75715e># 将eface._data移动到DX</span>
<span style=color:#ae81ff>0x006d</span> <span style=color:#ae81ff>00109</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       LEAQ    <span style=color:#a6e22e>type.int</span>(SB), BX	<span style=color:#75715e># 加载int的_type到BX</span>
<span style=color:#ae81ff>0x0074</span> <span style=color:#ae81ff>00116</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       CMPQ    CX, BX				<span style=color:#75715e># 对比CX与BX，即eface._type与int._type</span>
<span style=color:#ae81ff>0x0077</span> <span style=color:#ae81ff>00119</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       JEQ     <span style=color:#ae81ff>123</span>					<span style=color:#75715e># 如果_type对比成功，则跳转到123</span>
<span style=color:#ae81ff>0x0079</span> <span style=color:#ae81ff>00121</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       JMP     <span style=color:#ae81ff>133</span>					<span style=color:#75715e># 对比不成功，跳转133</span>
<span style=color:#ae81ff>0x007b</span> <span style=color:#ae81ff>00123</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       <span style=color:#a6e22e>MOVQ    </span>(DX), CX			<span style=color:#75715e># 将eface.data暂存到CX</span>
<span style=color:#ae81ff>0x007e</span> <span style=color:#ae81ff>00126</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVL    <span style=color:#f92672>$</span><span style=color:#ae81ff>1</span>, AX
<span style=color:#ae81ff>0x0083</span> <span style=color:#ae81ff>00131</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       JMP     <span style=color:#ae81ff>139</span>
<span style=color:#ae81ff>0x0085</span> <span style=color:#ae81ff>00133</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       XORL    CX, CX				<span style=color:#75715e># 类型断言失败，清空寄存器</span>
<span style=color:#ae81ff>0x0087</span> <span style=color:#ae81ff>00135</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       XORL    AX, AX				<span style=color:#75715e># 清空AX寄存器</span>
<span style=color:#ae81ff>0x0089</span> <span style=color:#ae81ff>00137</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       JMP     <span style=color:#ae81ff>139</span>
<span style=color:#ae81ff>0x008b</span> <span style=color:#ae81ff>00139</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_4<span style=color:#ae81ff>+40</span>(SP)
<span style=color:#ae81ff>0x0090</span> <span style=color:#ae81ff>00144</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVB    AL, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_5<span style=color:#ae81ff>+31</span>(SP)
<span style=color:#ae81ff>0x0094</span> <span style=color:#ae81ff>00148</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_4<span style=color:#ae81ff>+40</span>(SP), CX
<span style=color:#ae81ff>0x0099</span> <span style=color:#ae81ff>00153</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>.i<span style=color:#ae81ff>+32</span>(SP)		<span style=color:#75715e># 断言结果保存在&#34;&#34;.i+32(SP)</span>
<span style=color:#ae81ff>0x009e</span> <span style=color:#ae81ff>00158</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVBLZX <span style=color:#e6db74>&#34;&#34;</span>..autotmp_5<span style=color:#ae81ff>+31</span>(SP), CX
<span style=color:#ae81ff>0x00a3</span> <span style=color:#ae81ff>00163</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>13</span>)       MOVB    CL, <span style=color:#e6db74>&#34;&#34;</span>.ok<span style=color:#ae81ff>+30</span>(SP)	<span style=color:#75715e># ok保存在&#34;&#34;.ok+30(SP)</span>
</code></pre></div><p>从以上汇编代码可以看出，空接口在进行类型断言时，会将<code>eface._type</code>取出与断言类型的<code>_type</code>进行对比，如果对比成功，则将其<code>eface.data</code>取出使用，否则断言失败。</p><h3 id=32-非空接口断言>3.2 非空接口断言<a hidden class=anchor aria-hidden=true href=#32-非空接口断言>#</a></h3><h4 id=321-断言为接口>3.2.1 断言为接口<a hidden class=anchor aria-hidden=true href=#321-断言为接口>#</a></h4><p>对如下代码进行编译：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Walk</span>()
	<span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Walker</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Walk</span>()
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>age</span>  <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Walk</span>() {
	<span style=color:#66d9ef>return</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>words</span>, <span style=color:#e6db74>&#34; &#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>Person</span>(<span style=color:#a6e22e>Student</span>{
		<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lichang&#34;</span>,
		<span style=color:#a6e22e>age</span>:  <span style=color:#ae81ff>18</span>,
	})

	<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.(<span style=color:#a6e22e>Walker</span>)

	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
		<span style=color:#66d9ef>return</span>
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>w</span>)
	}
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>go tool compile -S -N -l  main.go
</code></pre></div><p>可得部分汇编代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=color:#75715e># iface构建</span>
<span style=color:#ae81ff>0x0026</span> <span style=color:#ae81ff>00038</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_3<span style=color:#ae81ff>+176</span>(SP)
<span style=color:#ae81ff>0x0032</span> <span style=color:#ae81ff>00050</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       MOVUPS  X15, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_3<span style=color:#ae81ff>+184</span>(SP)
<span style=color:#ae81ff>0x003b</span> <span style=color:#ae81ff>00059</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       LEAQ    go.string.<span style=color:#e6db74>&#34;lichang&#34;</span>(SB), CX
<span style=color:#ae81ff>0x0042</span> <span style=color:#ae81ff>00066</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_3<span style=color:#ae81ff>+176</span>(SP)
<span style=color:#ae81ff>0x004a</span> <span style=color:#ae81ff>00074</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>7</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_3<span style=color:#ae81ff>+184</span>(SP)
<span style=color:#ae81ff>0x0056</span> <span style=color:#ae81ff>00086</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>33</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>18</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_3<span style=color:#ae81ff>+192</span>(SP)
<span style=color:#ae81ff>0x0062</span> <span style=color:#ae81ff>00098</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       LEAQ    type.<span style=color:#e6db74>&#34;&#34;</span><span style=color:#a6e22e>.Student</span>(SB), AX
<span style=color:#ae81ff>0x0069</span> <span style=color:#ae81ff>00105</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       LEAQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_3<span style=color:#ae81ff>+176</span>(SP), BX
<span style=color:#ae81ff>0x0071</span> <span style=color:#ae81ff>00113</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       PCDATA  <span style=color:#f92672>$</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>$</span><span style=color:#ae81ff>0</span>
<span style=color:#ae81ff>0x0071</span> <span style=color:#ae81ff>00113</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       CALL    <span style=color:#a6e22e>runtime.convT</span>(SB)
<span style=color:#ae81ff>0x0076</span> <span style=color:#ae81ff>00118</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       MOVQ    AX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_7<span style=color:#ae81ff>+56</span>(SP)
<span style=color:#ae81ff>0x007b</span> <span style=color:#ae81ff>00123</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       LEAQ    go.itab.<span style=color:#e6db74>&#34;&#34;</span>.Student,<span style=color:#e6db74>&#34;&#34;</span><span style=color:#a6e22e>.Person</span>(SB), CX
<span style=color:#ae81ff>0x0082</span> <span style=color:#ae81ff>00130</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>.p<span style=color:#ae81ff>+88</span>(SP)			<span style=color:#75715e># iface.itab在&#34;&#34;.p+88(SP)处</span>
<span style=color:#ae81ff>0x0087</span> <span style=color:#ae81ff>00135</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>31</span>)       MOVQ    AX, <span style=color:#e6db74>&#34;&#34;</span>.p<span style=color:#ae81ff>+96</span>(SP)			<span style=color:#75715e># iface.data在&#34;&#34;.p+96(SP)处</span>

<span style=color:#75715e># 类型断言</span>
<span style=color:#ae81ff>0x008c</span> <span style=color:#ae81ff>00140</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVUPS  X15, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_4<span style=color:#ae81ff>+120</span>(SP)
<span style=color:#ae81ff>0x0092</span> <span style=color:#ae81ff>00146</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>.p<span style=color:#ae81ff>+88</span>(SP), BX			<span style=color:#75715e># iface.itab被转移到BX</span>
<span style=color:#ae81ff>0x0097</span> <span style=color:#ae81ff>00151</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>.p<span style=color:#ae81ff>+96</span>(SP), CX			<span style=color:#75715e># iface.data被转移到CX</span>
<span style=color:#ae81ff>0x009c</span> <span style=color:#ae81ff>00156</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       LEAQ    type.<span style=color:#e6db74>&#34;&#34;</span><span style=color:#a6e22e>.Walker</span>(SB), AX	<span style=color:#75715e># Walker._type被加载到AX</span>
<span style=color:#ae81ff>0x00a3</span> <span style=color:#ae81ff>00163</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       CALL    <span style=color:#a6e22e>runtime.assertI2I2</span>(SB)	<span style=color:#75715e># 调用runtime.assertI2I2</span>
<span style=color:#ae81ff>0x00a8</span> <span style=color:#ae81ff>00168</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVQ    AX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_4<span style=color:#ae81ff>+120</span>(SP)	<span style=color:#75715e># runtime.assertI2I2的返回值存储在&#34;&#34;..autotmp_4+120(SP)</span>
<span style=color:#ae81ff>0x00ad</span> <span style=color:#ae81ff>00173</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVQ    BX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_4<span style=color:#ae81ff>+128</span>(SP)
<span style=color:#ae81ff>0x00b5</span> <span style=color:#ae81ff>00181</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       TESTQ   AX, AX
<span style=color:#ae81ff>0x00b8</span> <span style=color:#ae81ff>00184</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       SETNE   <span style=color:#e6db74>&#34;&#34;</span>..autotmp_5<span style=color:#ae81ff>+47</span>(SP)
<span style=color:#ae81ff>0x00bd</span> <span style=color:#ae81ff>00189</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_4<span style=color:#ae81ff>+128</span>(SP), CX
<span style=color:#ae81ff>0x00c5</span> <span style=color:#ae81ff>00197</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_4<span style=color:#ae81ff>+120</span>(SP), DX
<span style=color:#ae81ff>0x00ca</span> <span style=color:#ae81ff>00202</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVQ    DX, <span style=color:#e6db74>&#34;&#34;</span>.w<span style=color:#ae81ff>+72</span>(SP)			<span style=color:#75715e># 断言接口的itab在&#34;&#34;.w+72(SP)</span>
<span style=color:#ae81ff>0x00cf</span> <span style=color:#ae81ff>00207</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>.w<span style=color:#ae81ff>+80</span>(SP)			<span style=color:#75715e># 断言接口的data在&#34;&#34;.w+80(SP)</span>
<span style=color:#ae81ff>0x00d4</span> <span style=color:#ae81ff>00212</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVBLZX <span style=color:#e6db74>&#34;&#34;</span>..autotmp_5<span style=color:#ae81ff>+47</span>(SP), CX
<span style=color:#ae81ff>0x00d9</span> <span style=color:#ae81ff>00217</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>36</span>)       MOVB    CL, <span style=color:#e6db74>&#34;&#34;</span>.ok<span style=color:#ae81ff>+46</span>(SP)		<span style=color:#75715e># ok被存储在&#34;&#34;.ok+46(SP)</span>
</code></pre></div><p><code>runtime.assertI2I2</code>函数如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>assertI2I2</span>(<span style=color:#a6e22e>inter</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>interfacetype</span>, <span style=color:#a6e22e>i</span> <span style=color:#a6e22e>iface</span>) (<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>iface</span>) {
	<span style=color:#a6e22e>tab</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>tab</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tab</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span>
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>inter</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>inter</span> {
		<span style=color:#a6e22e>tab</span> = <span style=color:#a6e22e>getitab</span>(<span style=color:#a6e22e>inter</span>, <span style=color:#a6e22e>tab</span>.<span style=color:#a6e22e>_type</span>, <span style=color:#66d9ef>true</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tab</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span>
		}
	}
	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>tab</span> = <span style=color:#a6e22e>tab</span>
	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>data</span> = <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>data</span>
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><p>该函数接受一个一个<code>interfacetype</code>和一个<code>iface</code>，检查<code>iface.itab.inter</code>是否与传入的<code>interfacetype</code>相同，若相同，则直接将原来的<code>iface</code>复制一个新的返回，否则构建一个具有传入的<code>interfacetype</code>的新的<code>itab</code>，并赋值给新的<code>iface</code>;<code>iface.data</code>直接复制到新的<code>iface</code>。</p><h4 id=322-断言为实体对象>3.2.2 断言为实体对象<a hidden class=anchor aria-hidden=true href=#322-断言为实体对象>#</a></h4><p>对如下代码进行编译：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Person</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>Walk</span>()
	<span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Student</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
	<span style=color:#a6e22e>age</span>  <span style=color:#66d9ef>int</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Walk</span>() {
	<span style=color:#66d9ef>return</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Student</span>) <span style=color:#a6e22e>Say</span>(<span style=color:#a6e22e>words</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Join</span>(<span style=color:#a6e22e>words</span>, <span style=color:#e6db74>&#34; &#34;</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>Person</span>(<span style=color:#a6e22e>Student</span>{
		<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;lichang&#34;</span>,
		<span style=color:#a6e22e>age</span>:  <span style=color:#ae81ff>18</span>,
	})

	<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.(<span style=color:#a6e22e>Student</span>)

	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
		<span style=color:#66d9ef>return</span>
	} <span style=color:#66d9ef>else</span> {
		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>w</span>)
	}
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>go tool compile -S -N -l  main.go
</code></pre></div><p>有关类型断言的汇编代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=color:#75715e># 接口构造</span>
<span style=color:#ae81ff>0x0035</span> <span style=color:#ae81ff>00053</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       MOVUPS  X15, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+224</span>(SP)
<span style=color:#ae81ff>0x003e</span> <span style=color:#ae81ff>00062</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>28</span>)       LEAQ    go.string.<span style=color:#e6db74>&#34;lichang&#34;</span>(SB), CX
<span style=color:#ae81ff>0x0045</span> <span style=color:#ae81ff>00069</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>28</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+216</span>(SP)
<span style=color:#ae81ff>0x004d</span> <span style=color:#ae81ff>00077</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>28</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>7</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+224</span>(SP)
<span style=color:#ae81ff>0x0059</span> <span style=color:#ae81ff>00089</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>29</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>18</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+232</span>(SP)
<span style=color:#ae81ff>0x0065</span> <span style=color:#ae81ff>00101</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_12<span style=color:#ae81ff>+240</span>(SP)
<span style=color:#ae81ff>0x006d</span> <span style=color:#ae81ff>00109</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>7</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_12<span style=color:#ae81ff>+248</span>(SP)
<span style=color:#ae81ff>0x0079</span> <span style=color:#ae81ff>00121</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>18</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_12<span style=color:#ae81ff>+256</span>(SP)
<span style=color:#ae81ff>0x0085</span> <span style=color:#ae81ff>00133</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       LEAQ    go.itab.<span style=color:#e6db74>&#34;&#34;</span>.Student,<span style=color:#e6db74>&#34;&#34;</span><span style=color:#a6e22e>.Person</span>(SB), CX
<span style=color:#ae81ff>0x008c</span> <span style=color:#ae81ff>00140</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>.p<span style=color:#ae81ff>+88</span>(SP)						<span style=color:#75715e># iface.itab</span>
<span style=color:#ae81ff>0x0091</span> <span style=color:#ae81ff>00145</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       LEAQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_12<span style=color:#ae81ff>+240</span>(SP), CX
<span style=color:#ae81ff>0x0099</span> <span style=color:#ae81ff>00153</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>27</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>.p<span style=color:#ae81ff>+96</span>(SP)						<span style=color:#75715e># iface.data</span>

<span style=color:#75715e># 类型断言</span>
<span style=color:#ae81ff>0x009e</span> <span style=color:#ae81ff>00158</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+216</span>(SP)
<span style=color:#ae81ff>0x00aa</span> <span style=color:#ae81ff>00170</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVUPS  X15, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+224</span>(SP)
<span style=color:#ae81ff>0x00b3</span> <span style=color:#ae81ff>00179</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>.p<span style=color:#ae81ff>+96</span>(SP), CX						<span style=color:#75715e># iface.data被装载到CX</span>
<span style=color:#ae81ff>0x00b8</span> <span style=color:#ae81ff>00184</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>.p<span style=color:#ae81ff>+88</span>(SP), DX						<span style=color:#75715e># iface.itab被装载到DX</span>
<span style=color:#ae81ff>0x00bd</span> <span style=color:#ae81ff>00189</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       LEAQ    go.itab.<span style=color:#e6db74>&#34;&#34;</span>.Student,<span style=color:#e6db74>&#34;&#34;</span><span style=color:#a6e22e>.Person</span>(SB), SI <span style=color:#75715e># 重新构造一个itab，存储在SI</span>
<span style=color:#ae81ff>0x00c4</span> <span style=color:#ae81ff>00196</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       CMPQ    DX, SI 								<span style=color:#75715e># 对比新构造的itab和老的itab</span>
<span style=color:#ae81ff>0x00c7</span> <span style=color:#ae81ff>00199</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       JEQ     <span style=color:#ae81ff>203</span>
<span style=color:#ae81ff>0x00c9</span> <span style=color:#ae81ff>00201</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       JMP     <span style=color:#ae81ff>221</span>
<span style=color:#ae81ff>0x00cb</span> <span style=color:#ae81ff>00203</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       <span style=color:#a6e22e>MOVQ    </span>(CX), DX							<span style=color:#75715e># CX(iface.data)指向的值0-7个字节mov到DX</span>
<span style=color:#ae81ff>0x00ce</span> <span style=color:#ae81ff>00206</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#ae81ff>8</span>(CX), SI							<span style=color:#75715e># 第8-15个字节mov到SI</span>
<span style=color:#ae81ff>0x00d2</span> <span style=color:#ae81ff>00210</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#ae81ff>16</span>(CX), CX							<span style=color:#75715e># 第16-24个字节mov到CX</span>
<span style=color:#ae81ff>0x00d6</span> <span style=color:#ae81ff>00214</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVL    <span style=color:#f92672>$</span><span style=color:#ae81ff>1</span>, AX
<span style=color:#ae81ff>0x00db</span> <span style=color:#ae81ff>00219</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       JMP     <span style=color:#ae81ff>231</span>
<span style=color:#ae81ff>0x00dd</span> <span style=color:#ae81ff>00221</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       XORL    SI, SI								<span style=color:#75715e># 断言失败执行</span>
<span style=color:#ae81ff>0x00df</span> <span style=color:#ae81ff>00223</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       XORL    CX, CX
<span style=color:#ae81ff>0x00e1</span> <span style=color:#ae81ff>00225</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       XORL    AX, AX
<span style=color:#ae81ff>0x00e3</span> <span style=color:#ae81ff>00227</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       XORL    DX, DX
<span style=color:#ae81ff>0x00e5</span> <span style=color:#ae81ff>00229</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       JMP     <span style=color:#ae81ff>231</span>
<span style=color:#ae81ff>0x00e7</span> <span style=color:#ae81ff>00231</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    DX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+216</span>(SP)
<span style=color:#ae81ff>0x00ef</span> <span style=color:#ae81ff>00239</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    SI, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+224</span>(SP)
<span style=color:#ae81ff>0x00f7</span> <span style=color:#ae81ff>00247</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+232</span>(SP)
<span style=color:#ae81ff>0x00ff</span> <span style=color:#ae81ff>00255</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVB    AL, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_9<span style=color:#ae81ff>+47</span>(SP)
<span style=color:#ae81ff>0x0103</span> <span style=color:#ae81ff>00259</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+216</span>(SP), CX
<span style=color:#ae81ff>0x010b</span> <span style=color:#ae81ff>00267</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+224</span>(SP), DX
<span style=color:#ae81ff>0x0113</span> <span style=color:#ae81ff>00275</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_8<span style=color:#ae81ff>+232</span>(SP), SI
<span style=color:#ae81ff>0x011b</span> <span style=color:#ae81ff>00283</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>.s<span style=color:#ae81ff>+168</span>(SP)					<span style=color:#75715e># 构造Student结构体</span>
<span style=color:#ae81ff>0x0123</span> <span style=color:#ae81ff>00291</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    DX, <span style=color:#e6db74>&#34;&#34;</span>.s<span style=color:#ae81ff>+176</span>(SP)
<span style=color:#ae81ff>0x012b</span> <span style=color:#ae81ff>00299</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVQ    SI, <span style=color:#e6db74>&#34;&#34;</span>.s<span style=color:#ae81ff>+184</span>(SP)
<span style=color:#ae81ff>0x0133</span> <span style=color:#ae81ff>00307</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVBLZX <span style=color:#e6db74>&#34;&#34;</span>..autotmp_9<span style=color:#ae81ff>+47</span>(SP), CX
<span style=color:#ae81ff>0x0138</span> <span style=color:#ae81ff>00312</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>32</span>)       MOVB    CL, <span style=color:#e6db74>&#34;&#34;</span>.ok<span style=color:#ae81ff>+46</span>(SP)					<span style=color:#75715e># ok存储在&#34;&#34;.ok+46(SP)</span>
</code></pre></div><p>在进行接口到实体对象的断言时，编译器会尝试构建一个断言对象对应的itab，然后和原接口的itab进行对比，如果相同，则断言可成功，否则失败。</p><p>断言成功后，将<code>iface.data</code>解析，重新组装成断言对象。断言失败则清空寄存器，返回一个断言对象的零值</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://golang.design/go-questions/interface/assert/>Go Questions</a></p><p><a href=https://segmentfault.com/a/1190000039894161>interface的类型断言是如何实现</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/golang/>golang</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/runtime/>runtime</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/><span class=title>« Prev Page</span><br><span>runtime篇二：通道</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/net/%E6%A6%82%E8%BF%B0tls/><span class=title>Next Page »</span><br><span>详解TLS（译）</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>