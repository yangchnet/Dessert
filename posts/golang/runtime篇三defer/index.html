<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>runtime篇三：defer | Linote</title><meta name=keywords content="golang,runtime"><meta name=description content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. defer是什么 defer，是一种特殊的机制，在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，多个defer的执行顺序与声明顺序相反。
对于defer的使用及需要注意的地方，可参考defer用法。这里不再讨论。
在golang runtime中，defer被描述为一个结构体：
type _defer struct { started bool // 是否开始执行defer函数 	heap bool // 是否分配在堆上  openDefer bool // 是否经过开放编码（open-coded）的优化 	sp uintptr // 调用defer时的栈指针 stack pointer 	pc uintptr // 调用defer函数时的pc值 	fn func() // defer关键字传入的函数， 当使用open-coded defer时可为空 	_panic *_panic // defer函数中的_panic链表 	link *_defer // 在goroutine中的下一个defer，可指向堆或栈  // 如果openDefer为true，则下面的字段将记录具有open-code defer的栈帧和相关的函数。  // 上面的sp将为帧的sp，pc将为defer调用的地址。 	fd unsafe."><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="runtime篇三：defer"><meta property="og:description" content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. defer是什么 defer，是一种特殊的机制，在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，多个defer的执行顺序与声明顺序相反。
对于defer的使用及需要注意的地方，可参考defer用法。这里不再讨论。
在golang runtime中，defer被描述为一个结构体：
type _defer struct { started bool // 是否开始执行defer函数 	heap bool // 是否分配在堆上  openDefer bool // 是否经过开放编码（open-coded）的优化 	sp uintptr // 调用defer时的栈指针 stack pointer 	pc uintptr // 调用defer函数时的pc值 	fn func() // defer关键字传入的函数， 当使用open-coded defer时可为空 	_panic *_panic // defer函数中的_panic链表 	link *_defer // 在goroutine中的下一个defer，可指向堆或栈  // 如果openDefer为true，则下面的字段将记录具有open-code defer的栈帧和相关的函数。  // 上面的sp将为帧的sp，pc将为defer调用的地址。 	fd unsafe."><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-12T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-12T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="runtime篇三：defer"><meta name=twitter:description content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. defer是什么 defer，是一种特殊的机制，在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，多个defer的执行顺序与声明顺序相反。
对于defer的使用及需要注意的地方，可参考defer用法。这里不再讨论。
在golang runtime中，defer被描述为一个结构体：
type _defer struct { started bool // 是否开始执行defer函数 	heap bool // 是否分配在堆上  openDefer bool // 是否经过开放编码（open-coded）的优化 	sp uintptr // 调用defer时的栈指针 stack pointer 	pc uintptr // 调用defer函数时的pc值 	fn func() // defer关键字传入的函数， 当使用open-coded defer时可为空 	_panic *_panic // defer函数中的_panic链表 	link *_defer // 在goroutine中的下一个defer，可指向堆或栈  // 如果openDefer为true，则下面的字段将记录具有open-code defer的栈帧和相关的函数。  // 上面的sp将为帧的sp，pc将为defer调用的地址。 	fd unsafe."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"runtime篇三：defer","item":"http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"runtime篇三：defer","name":"runtime篇三：defer","description":"本系列代码基于golang1.19\n  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. defer是什么 defer，是一种特殊的机制，在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，多个defer的执行顺序与声明顺序相反。\n对于defer的使用及需要注意的地方，可参考defer用法。这里不再讨论。\n在golang runtime中，defer被描述为一个结构体：\ntype _defer struct { started bool // 是否开始执行defer函数 \theap bool // 是否分配在堆上  openDefer bool // 是否经过开放编码（open-coded）的优化 \tsp uintptr // 调用defer时的栈指针 stack pointer \tpc uintptr // 调用defer函数时的pc值 \tfn func() // defer关键字传入的函数， 当使用open-coded defer时可为空 \t_panic *_panic // defer函数中的_panic链表 \tlink *_defer // 在goroutine中的下一个defer，可指向堆或栈  // 如果openDefer为true，则下面的字段将记录具有open-code defer的栈帧和相关的函数。  // 上面的sp将为帧的sp，pc将为defer调用的地址。 \tfd unsafe.","keywords":["golang","runtime"],"articleBody":" 本系列代码基于golang1.19\n  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. defer是什么 defer，是一种特殊的机制，在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，多个defer的执行顺序与声明顺序相反。\n对于defer的使用及需要注意的地方，可参考defer用法。这里不再讨论。\n在golang runtime中，defer被描述为一个结构体：\ntype _defer struct { started bool // 是否开始执行defer函数 \theap bool // 是否分配在堆上  openDefer bool // 是否经过开放编码（open-coded）的优化 \tsp uintptr // 调用defer时的栈指针 stack pointer \tpc uintptr // 调用defer函数时的pc值 \tfn func() // defer关键字传入的函数， 当使用open-coded defer时可为空 \t_panic *_panic // defer函数中的_panic链表 \tlink *_defer // 在goroutine中的下一个defer，可指向堆或栈  // 如果openDefer为true，则下面的字段将记录具有open-code defer的栈帧和相关的函数。  // 上面的sp将为帧的sp，pc将为defer调用的地址。 \tfd unsafe.Pointer // funcdata for the function associated with the frame \tvarp uintptr // value of varp for the stack frame  framepc uintptr // 当前栈帧的pc } 一个_defer结构体是defer调用的一环，一个函数中的多个defer被组织为链表的形式。defer有的分配在栈上，有的分配在堆上，但逻辑上他们都是属于栈的，因此在进行访问不需要加写屏障。\n可以看到， _defer中保存了很多字段，主要可分为三类，一是指示defer自身状态的标志位，如started,heap等；二是保存defer上下文，如sp, pc等；三是有关开放编码的一些字段。\n1.1 open-coded defer 在_defer中，有一个字段openDefer指示是否这个defer经过开放编码的优化，那么，什么是open code defer?\n对于一个defer函数来说，将其放入defer链表调用与直接调用是存在性能差异的，例如直接调用的耗时可能在6ns左右，而从defer链表中调用的耗时在35ns左右[1]，其中的主要原因在于，将函数放入defer链表或将其取出执行时，需要对上下文环境做保存和重做。因此，在go1.14中对其进行了优化，对于满足一定条件的defer，会进行open-coded优化。\n例如，对于如下代码：\ndefer f1(a) if cond { defer f2(b) } body... 将被编译为：\n// 设置标识位 deferBits |= 10 tmpF1 = f1 tmpA = a if cond { deferBits |= 11 tmpF2 = f2 tmpB = b } body... exit: // 在退出时检查标记位，以判断某个defer函数是否需要被执行 if deferBits \u0026 11 != 0 { deferBits \u0026^= 11 tmpF2(tmpB) } if deferBits \u0026 10 != 0 { deferBits \u0026^= 10 tmpF1(tmpA) } 这里不再将defer简单的放入defer链表了事，而是将其添加到了函数的底部，并通过标志位进行检查。\n1.2 newdefer // 每个p维护一个defer池  // Allocate a Defer, usually using per-P pool. // Each defer must be released with freedefer. The defer is not // added to any defer chain yet. func newdefer() *_defer { var d *_defer mp := acquirem() // 获取当前g的m, m.locks++ \tpp := mp.p.ptr() // m上的p \tif len(pp.deferpool) == 0 \u0026\u0026 sched.deferpool != nil { // p的deferpool为空，但sched的deferpool不为空 \tlock(\u0026sched.deferlock) // 加锁 \tfor len(pp.deferpool) pp.deferpool)/2 \u0026\u0026 sched.deferpool != nil { // p的deferpool长度小于其容量的一半，且sched的deferpool不为空 \td := sched.deferpool // 从sched.deferpool取出一个_defer结构体 \tsched.deferpool = d.link // 将取出的_defer的下一个_defer重新链接到sched.deferpool \td.link = nil // 断链 \tpp.deferpool = append(pp.deferpool, d) // 取出的这个_defer加入到p的deferpool中 \t} unlock(\u0026sched.deferlock) // 解锁 \t} if n := len(pp.deferpool); n  0 { // 从p的deferpool中取出一个_defer \td = pp.deferpool[n-1] pp.deferpool[n-1] = nil pp.deferpool = pp.deferpool[:n-1] } releasem(mp) // m.locks-- \tmp, pp = nil, nil if d == nil { // 如果从sched的deferpool和p的deferpool中都没有取到现成的_defer，只要新构建一个 \t// Allocate new defer. \td = new(_defer) } d.heap = true // 默认defer分配在堆上 \treturn d } 从newdefer函数中中可以看出，sched和p上均有deferpool，里面均保存了若干空的_defer对象以便复用，在想要创建一个新的_defer时，如果p的deferpool为空，会尝试从sched的deferpool中去取，然后放在p的deferpool中。如果两个地方都没有空_defer对象，那就只要新建一个了，而新建的这个_defer对象，默认分配在堆上。\n既然在newdefer时会从sched.deferpool中取，那么在释放_defer，响应的应该也会将用过的空_defer放入sched或p的deferpool中去。\n1.3 freedefer func freedefer(d *_defer) { d.link = nil // 断链 \t// After this point we can copy the stack.  if d._panic != nil { freedeferpanic() } if d.fn != nil { freedeferfn() } if !d.heap { // _defer不在堆上，不需要单独进行释放 \treturn } mp := acquirem() // 获取当前g的m \tpp := mp.p.ptr() // 获取m的p \tif len(pp.deferpool) == cap(pp.deferpool) { // p的deferpool满了 \t// Transfer half of local cache to the central cache. \t// 将一半的_defer从p.deferpool移动到sched.deferpool中 \tvar first, last *_defer // 这个循环取p.deferpool中的一半_defer组成一个链表，first、last分别为其第一、最后一个元素 \tfor len(pp.deferpool)  cap(pp.deferpool)/2 { n := len(pp.deferpool) d := pp.deferpool[n-1] // d是p.deferpool中的最后一个_defer \tpp.deferpool[n-1] = nil pp.deferpool = pp.deferpool[:n-1] // p.deferpool长度-1 \tif first == nil { first = d } else { last.link = d } last = d } lock(\u0026sched.deferlock) // 加锁 \tlast.link = sched.deferpool // 头插 \tsched.deferpool = first unlock(\u0026sched.deferlock) // 释放锁 \t} *d = _defer{} // 清空内部字段  pp.deferpool = append(pp.deferpool, d) // 直接放入p.deferpool  releasem(mp) mp, pp = nil, nil } 当一个_defer要被释放时，会尝试将其放入当前g所属p的deferpool中去，如果p的deferpool满了，则将p的deferpool中的一半元素放到sched的deferpool中，然后再将_defer放到p.deferpool\n2. 调用defer 从_defer的结构我们可以看到，_defer可能会分配到栈上，也可能会分配在堆上。\n2.1 栈上分配 对于大部分场景来说，在不开启open-coded defer的情况下会使用栈上分配。\n对于如下代码：\npackage main import \"fmt\" func main() { defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) defer func() { fmt.Println(4) }() } 对其进行编译:\ngo tool compile -S -N main.go # -N参数禁止编译时优化，如果不加-N，会使用open-coded defer ... 0x01e2 00482 (main.go:9) LEAQ \"\".main.func1·f(SB), CX 0x01e9 00489 (main.go:9) MOVQ CX, \"\"..autotmp_12+112(SP) 0x01ee 00494 (main.go:9) LEAQ \"\"..autotmp_12+88(SP), AX 0x01f3 00499 (main.go:9) CALL runtime.deferprocStack(SB) ... 0x01e2处，将\"\".main.func1·f(SB)函数加载到CX，接下来将CX中的内容放置在\"\"..autotmp_12+112(SP)。下一步将\"\"..autotmp_12+88(SP)作为runtime.deferprocStack的参数。\n这里可以简单分析一下，从\"\"..autotmp_12+88(SP)到\"\"..autotmp_12+112(SP)，这中间有24个字节的宽度，而_defer的前几个字段如下：\ntype _defer struct { started bool // 1字节 \theap bool // 1字节  openDefer bool // 1字节 \tsp uintptr // 8字节 \tpc uintptr // 8字节 \tfn func() // defer关键字传入的函数， 当使用open-coded defer时可为空 \t... } 在fn之前共有1+1+1+8+8=19个字节的宽度，但实际上在进行内存分配时，在3个bool型字段后，需要添加5字节进行内存对齐，因此从_defer的开始地址到fn的地址，这中间的宽度就变成了1+1+1+5+8+8=24。\n因此我们可以知道这几行汇编的前三行，是将函数赋值到_defer的fn字段上。\n知道了这些，我们再来看runtime.deferprocStack`：\nfunc deferprocStack(d *_defer) { gp := getg() // 获取当前g \tif gp.m.curg != gp { // go code on the system stack can't defer \tthrow(\"defer on system stack\") } // fn已被赋值过，其他的字段在这里赋值 \td.started = false d.heap = false d.openDefer = false d.sp = getcallersp() d.pc = getcallerpc() d.framepc = 0 d.varp = 0 *(*uintptr)(unsafe.Pointer(\u0026d._panic)) = 0 *(*uintptr)(unsafe.Pointer(\u0026d.fd)) = 0 *(*uintptr)(unsafe.Pointer(\u0026d.link)) = uintptr(unsafe.Pointer(gp._defer)) *(*uintptr)(unsafe.Pointer(\u0026gp._defer)) = uintptr(unsafe.Pointer(d)) return0() } 将_defer分配在栈上，并将其放入g的defer链表中。\n2.2 堆上分配 堆上分配是默认的兜底方案。\n编译如下代码：\npackage main import \"fmt\" func main() { for i := 0; i 10; i++ { defer func(i int) { fmt.Println(i) }(i) } } go tool compile -S -N main.go 可看到其调用了runtime.deferproc:\nfunc deferproc(fn func()) { gp := getg() // 获取g \tif gp.m.curg != gp { // go code on the system stack can't defer \tthrow(\"defer on system stack\") } d := newdefer() // 获取一个_defer \tif d._panic != nil { throw(\"deferproc: d.panic != nil after newdefer\") } d.link = gp._defer // 将_defer以头插法插入到g的_defer链表中 \tgp._defer = d d.fn = fn // 设置_defer函数 \td.pc = getcallerpc() // 保存上下文环境 \td.sp = getcallersp() return0() } 相对于栈上分配，在堆上分配设计到newdefer的调用，而通过上文的分析我们可知，在调用newdefer时，会涉及到sched、p以及对m的加锁，因此性能上不如栈上分配。且，栈上分配不需要写屏障。\n3. 执行defer package main import \"fmt\" func main() { defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) defer func() { fmt.Println(4) }() } 查看以上代码的汇编代码时，可看到：\n0x0200 00512 (main.go:12) CALL runtime.deferreturn(SB) 0x0205 00517 (main.go:12) MOVQ 440(SP), BP 0x020d 00525 (main.go:12) ADDQ $448, SP 0x0214 00532 (main.go:12) RET 0x0215 00533 (main.go:9) CALL runtime.deferreturn(SB) 0x021a 00538 (main.go:9) MOVQ 440(SP), BP 0x0222 00546 (main.go:9) ADDQ $448, SP 0x0229 00553 (main.go:9) RET 0x022a 00554 (main.go:8) CALL runtime.deferreturn(SB) 0x022f 00559 (main.go:8) MOVQ 440(SP), BP 0x0237 00567 (main.go:8) ADDQ $448, SP 0x023e 00574 (main.go:8) RET 0x023f 00575 (main.go:8) NOP 0x0240 00576 (main.go:7) CALL runtime.deferreturn(SB) 0x0245 00581 (main.go:7) MOVQ 440(SP), BP 0x024d 00589 (main.go:7) ADDQ $448, SP 0x0254 00596 (main.go:7) RET 0x0255 00597 (main.go:6) CALL runtime.deferreturn(SB) 可以看到会defer的调用是按照其定义的顺序反向调用的。\n在调用了defer的函数中，编译器会自动在函数尾部插入对runtime.deferreturn的调用。\nfunc deferreturn() { gp := getg() // 获取当前g \tfor { d := gp._defer // defer链表的第一个defer，也是最后一个被定义的defer \tif d == nil { return } sp := getcallersp() if d.sp != sp { return } if d.openDefer { // 如果开启了open-coded defer \tdone := runOpenDeferFrame(gp, d) if !done { throw(\"unfinished open-coded defers in deferreturn\") } gp._defer = d.link //// 删除链表的第一个元素 \tfreedefer(d) // If this frame uses open defers, then this \t// must be the only defer record for the \t// frame, so we can just return. \treturn } fn := d.fn // 取出defer函数 \td.fn = nil gp._defer = d.link // 删除链表的第一个元素 \tfreedefer(d) // 释放_defer \tfn() // 调用defer函数 \t} } 4. defer的三种处理机制 经过以上的分析，我们可以总结一下，defer的三种处理机制：\n open-coded defer 栈上分配的defer 堆上分配的defer  其执行效率为：open-coded defer  栈上分配的defer  堆上分配的defer\n4.1 处理机制的选择   在defer语句出现在了循环语句里，或者无法执行更高阶的编译器优化时，亦或者同一个函数中使用了过多的defer时，会使用堆上分配[2]  满足以下三种情况时[3]，会使用open-coded defer\n 没有禁用编译器优化，即没有设置 -gcflags “-N”； 函数内 defer 的数量不超过 8 个，且返回语句与延迟语句个数的乘积不超过 15； defer 不是在循环语句中。    其他大部分情况下，会使用栈上分配\n  END\nReferences https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md\nhttps://cloud.tencent.com/developer/article/1596802\nhttps://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#535-%e5%bc%80%e6%94%be%e7%bc%96%e7%a0%81\nhttps://juejin.cn/post/6844904078569373710\nhttps://xargin.com/go-1-13-defer-change/\nhttps://juejin.cn/post/6975686540601245709\nhttps://zhuanlan.zhihu.com/p/401339057\n","wordCount":"991","inLanguage":"en","datePublished":"2022-08-12T00:00:00Z","dateModified":"2022-08-12T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>runtime篇三：defer</h1><div class=post-meta><span title="2022-08-12 00:00:00 +0000 UTC">August 12, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-defer%e6%98%af%e4%bb%80%e4%b9%88 aria-label="1. defer是什么">1. defer是什么</a><ul><li><a href=#11-open-coded-defer aria-label="1.1 open-coded defer">1.1 open-coded defer</a></li><li><a href=#12-newdefer aria-label="1.2 newdefer">1.2 newdefer</a></li><li><a href=#13-freedefer aria-label="1.3 freedefer">1.3 freedefer</a></li></ul></li><li><a href=#2-%e8%b0%83%e7%94%a8defer aria-label="2. 调用defer">2. 调用defer</a><ul><li><a href=#21-%e6%a0%88%e4%b8%8a%e5%88%86%e9%85%8d aria-label="2.1 栈上分配">2.1 栈上分配</a></li><li><a href=#22-%e5%a0%86%e4%b8%8a%e5%88%86%e9%85%8d aria-label="2.2 堆上分配">2.2 堆上分配</a></li></ul></li><li><a href=#3-%e6%89%a7%e8%a1%8cdefer aria-label="3. 执行defer">3. 执行defer</a></li><li><a href=#4-defer%e7%9a%84%e4%b8%89%e7%a7%8d%e5%a4%84%e7%90%86%e6%9c%ba%e5%88%b6 aria-label="4. defer的三种处理机制">4. defer的三种处理机制</a><ul><li><a href=#41-%e5%a4%84%e7%90%86%e6%9c%ba%e5%88%b6%e7%9a%84%e9%80%89%e6%8b%a9 aria-label="4.1 处理机制的选择">4.1 处理机制的选择</a></li></ul></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><blockquote><p>本系列代码基于<a href=https://github.com/golang/go/tree/1e5987635cc8bf99e8a20d240da80bd6f0f793f7>golang1.19</a></p></blockquote><ul><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/>runtime篇一：接口</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/>runtime篇二：通道</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/>runtime篇三：defer</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/>runtime篇四：panic</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%94slice/>runtime篇五：slice</a></li></ul><h2 id=1-defer是什么>1. defer是什么<a hidden class=anchor aria-hidden=true href=#1-defer是什么>#</a></h2><p><code>defer</code>，是一种特殊的机制，在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，多个defer的执行顺序与声明顺序相反。</p><p>对于defer的使用及需要注意的地方，可参考<a href=https://yangchnet.github.io/Dessert/posts/golang/defer%E7%94%A8%E6%B3%95/>defer用法</a>。这里不再讨论。</p><p>在golang runtime中，defer被描述为一个结构体：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_defer</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>started</span> <span style=color:#66d9ef>bool</span>      <span style=color:#75715e>// 是否开始执行defer函数
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>heap</span>    <span style=color:#66d9ef>bool</span>      <span style=color:#75715e>// 是否分配在堆上
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>openDefer</span> <span style=color:#66d9ef>bool</span>    <span style=color:#75715e>// 是否经过开放编码（open-coded）的优化
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sp</span>        <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 调用defer时的栈指针 stack pointer
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>pc</span>        <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 调用defer函数时的pc值
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fn</span>        <span style=color:#66d9ef>func</span>()  <span style=color:#75715e>// defer关键字传入的函数， 当使用open-coded defer时可为空
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>_panic</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span> <span style=color:#75715e>// defer函数中的_panic链表
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>link</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// 在goroutine中的下一个defer，可指向堆或栈
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 如果openDefer为true，则下面的字段将记录具有open-code defer的栈帧和相关的函数。
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 上面的sp将为帧的sp，pc将为defer调用的地址。
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fd</span>   <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// funcdata for the function associated with the frame
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>varp</span> <span style=color:#66d9ef>uintptr</span>        <span style=color:#75715e>// value of varp for the stack frame
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>framepc</span> <span style=color:#66d9ef>uintptr</span>     <span style=color:#75715e>// 当前栈帧的pc
</span><span style=color:#75715e></span>}
</code></pre></div><p>一个<code>_defer</code>结构体是defer调用的一环，一个函数中的多个defer被组织为链表的形式。defer有的分配在栈上，有的分配在堆上，但逻辑上他们都是属于栈的，因此在进行访问不需要加写屏障。</p><p>可以看到， <code>_defer</code>中保存了很多字段，主要可分为三类，一是指示defer自身状态的标志位，如<code>started</code>,<code>heap</code>等；二是保存defer上下文，如<code>sp</code>, <code>pc</code>等；三是有关开放编码的一些字段。</p><h3 id=11-open-coded-defer>1.1 open-coded defer<a hidden class=anchor aria-hidden=true href=#11-open-coded-defer>#</a></h3><p>在<code>_defer</code>中，有一个字段<code>openDefer</code>指示是否这个defer经过开放编码的优化，那么，什么是<code>open code defer</code>?</p><p>对于一个defer函数来说，将其放入defer链表调用与直接调用是存在性能差异的，例如直接调用的耗时可能在6ns左右，而从defer链表中调用的耗时在35ns左右<a href=https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md>[1]</a>，其中的主要原因在于，将函数放入defer链表或将其取出执行时，需要对上下文环境做保存和重做。因此，在go1.14中对其进行了优化，对于满足一定条件的defer，会进行open-coded优化。</p><p>例如，对于如下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f1</span>(<span style=color:#a6e22e>a</span>)
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cond</span> {
 <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f2</span>(<span style=color:#a6e22e>b</span>)
}
<span style=color:#a6e22e>body</span><span style=color:#f92672>...</span>
</code></pre></div><p>将被编译为：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 设置标识位
</span><span style=color:#75715e></span><span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>0</span>
<span style=color:#a6e22e>tmpF1</span> = <span style=color:#a6e22e>f1</span>
<span style=color:#a6e22e>tmpA</span> = <span style=color:#a6e22e>a</span>
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cond</span> {
 <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>
 <span style=color:#a6e22e>tmpF2</span> = <span style=color:#a6e22e>f2</span>
 <span style=color:#a6e22e>tmpB</span> = <span style=color:#a6e22e>b</span>
}
<span style=color:#a6e22e>body</span><span style=color:#f92672>...</span>
<span style=color:#a6e22e>exit</span>:
<span style=color:#75715e>// 在退出时检查标记位，以判断某个defer函数是否需要被执行
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
 <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>
 <span style=color:#a6e22e>tmpF2</span>(<span style=color:#a6e22e>tmpB</span>)
}
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
 <span style=color:#a6e22e>deferBits</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>0</span>
 <span style=color:#a6e22e>tmpF1</span>(<span style=color:#a6e22e>tmpA</span>)
}
</code></pre></div><p>这里不再将defer简单的放入defer链表了事，而是将其添加到了函数的底部，并通过标志位进行检查。</p><h3 id=12-newdefer>1.2 newdefer<a hidden class=anchor aria-hidden=true href=#12-newdefer>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// 每个p维护一个defer池
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Allocate a Defer, usually using per-P pool.
</span><span style=color:#75715e>// Each defer must be released with freedefer.  The defer is not
</span><span style=color:#75715e>// added to any defer chain yet.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newdefer</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>
	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquirem</span>() <span style=color:#75715e>// 获取当前g的m, m.locks++
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>() <span style=color:#75715e>// m上的p
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// p的deferpool为空，但sched的deferpool不为空
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferlock</span>) <span style=color:#75715e>// 加锁
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>) &lt; cap(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// p的deferpool长度小于其容量的一半，且sched的deferpool不为空
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span> <span style=color:#75715e>// 从sched.deferpool取出一个_defer结构体
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span> <span style=color:#75715e>// 将取出的_defer的下一个_defer重新链接到sched.deferpool
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span> = <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// 断链
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span> = append(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>, <span style=color:#a6e22e>d</span>) <span style=color:#75715e>// 取出的这个_defer加入到p的deferpool中
</span><span style=color:#75715e></span>		}
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferlock</span>) <span style=color:#75715e>// 解锁
</span><span style=color:#75715e></span>	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>); <span style=color:#a6e22e>n</span> &gt; <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 从p的deferpool中取出一个_defer
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>d</span> = <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
		<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span> = <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[:<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
	}
	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>) <span style=color:#75715e>// m.locks--
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>mp</span>, <span style=color:#a6e22e>pp</span> = <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 如果从sched的deferpool和p的deferpool中都没有取到现成的_defer，只要新构建一个
</span><span style=color:#75715e></span>		<span style=color:#75715e>// Allocate new defer.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>d</span> = new(<span style=color:#a6e22e>_defer</span>)
	}
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>heap</span> = <span style=color:#66d9ef>true</span> <span style=color:#75715e>// 默认defer分配在堆上
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>d</span>
}
</code></pre></div><p>从newdefer函数中中可以看出，<code>sched</code>和<code>p</code>上均有deferpool，里面均保存了若干空的<code>_defer</code>对象以便复用，在想要创建一个新的<code>_defer</code>时，如果<code>p</code>的deferpool为空，会尝试从<code>sched</code>的deferpool中去取，然后放在<code>p</code>的deferpool中。如果两个地方都没有空<code>_defer</code>对象，那就只要新建一个了，而新建的这个<code>_defer</code>对象，默认分配在堆上。</p><p>既然在newdefer时会从<code>sched.deferpool</code>中取，那么在释放<code>_defer</code>，响应的应该也会将用过的空<code>_defer</code>放入<code>sched</code>或<code>p</code>的deferpool中去。</p><h3 id=13-freedefer>1.3 freedefer<a hidden class=anchor aria-hidden=true href=#13-freedefer>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>) {
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span> = <span style=color:#66d9ef>nil</span> <span style=color:#75715e>// 断链
</span><span style=color:#75715e></span>	<span style=color:#75715e>// After this point we can copy the stack.
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>freedeferpanic</span>()
	}
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>freedeferfn</span>()
	}
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>heap</span> { <span style=color:#75715e>// _defer不在堆上，不需要单独进行释放
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span>
	}

	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquirem</span>() <span style=color:#75715e>// 获取当前g的m
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>() <span style=color:#75715e>// 获取m的p
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>) <span style=color:#f92672>==</span> cap(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>) { <span style=color:#75715e>// p的deferpool满了
</span><span style=color:#75715e></span>		<span style=color:#75715e>// Transfer half of local cache to the central cache.
</span><span style=color:#75715e></span>		<span style=color:#75715e>// 将一半的_defer从p.deferpool移动到sched.deferpool中
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>first</span>, <span style=color:#a6e22e>last</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>
		<span style=color:#75715e>// 这个循环取p.deferpool中的一半_defer组成一个链表，first、last分别为其第一、最后一个元素
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>for</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>) &gt; cap(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> {
			<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>)
			<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#75715e>// d是p.deferpool中的最后一个_defer
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#66d9ef>nil</span>
			<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span> = <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>[:<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#75715e>// p.deferpool长度-1
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>first</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>first</span> = <span style=color:#a6e22e>d</span>
			} <span style=color:#66d9ef>else</span> {
				<span style=color:#a6e22e>last</span>.<span style=color:#a6e22e>link</span> = <span style=color:#a6e22e>d</span>
			}
			<span style=color:#a6e22e>last</span> = <span style=color:#a6e22e>d</span>
		}
		<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferlock</span>) <span style=color:#75715e>// 加锁
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>last</span>.<span style=color:#a6e22e>link</span> = <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span> <span style=color:#75715e>// 头插
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferpool</span> = <span style=color:#a6e22e>first</span>
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>deferlock</span>) <span style=color:#75715e>// 释放锁
</span><span style=color:#75715e></span>	}


	<span style=color:#f92672>*</span><span style=color:#a6e22e>d</span> = <span style=color:#a6e22e>_defer</span>{} <span style=color:#75715e>// 清空内部字段
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span> = append(<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>deferpool</span>, <span style=color:#a6e22e>d</span>) <span style=color:#75715e>// 直接放入p.deferpool
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)
	<span style=color:#a6e22e>mp</span>, <span style=color:#a6e22e>pp</span> = <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>当一个<code>_defer</code>要被释放时，会尝试将其放入当前<code>g</code>所属<code>p</code>的deferpool中去，如果<code>p</code>的deferpool满了，则将<code>p</code>的deferpool中的一半元素放到<code>sched</code>的deferpool中，然后再将<code>_defer</code>放到<code>p.deferpool</code></p><h2 id=2-调用defer>2. 调用defer<a hidden class=anchor aria-hidden=true href=#2-调用defer>#</a></h2><p>从<code>_defer</code>的结构我们可以看到，<code>_defer</code>可能会分配到栈上，也可能会分配在堆上。</p><h3 id=21-栈上分配>2.1 栈上分配<a hidden class=anchor aria-hidden=true href=#21-栈上分配>#</a></h3><p>对于大部分场景来说，在不开启<code>open-coded defer</code>的情况下会使用栈上分配。</p><p>对于如下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#ae81ff>1</span>)
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#ae81ff>2</span>)
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#ae81ff>3</span>)
        <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
                <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#ae81ff>4</span>)
        }()
}
</code></pre></div><p>对其进行编译:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>go tool compile -S -N main.go  <span style=color:#75715e># -N参数禁止编译时优化，如果不加-N，会使用open-coded defer</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=color:#66d9ef>...</span>
<span style=color:#ae81ff>0x01e2</span> <span style=color:#ae81ff>00482</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>9</span>)        LEAQ    <span style=color:#e6db74>&#34;&#34;</span>.main.func1·<span style=color:#a6e22e>f</span>(SB), CX
<span style=color:#ae81ff>0x01e9</span> <span style=color:#ae81ff>00489</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>9</span>)        MOVQ    CX, <span style=color:#e6db74>&#34;&#34;</span>..autotmp_12<span style=color:#ae81ff>+112</span>(SP)
<span style=color:#ae81ff>0x01ee</span> <span style=color:#ae81ff>00494</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>9</span>)        LEAQ    <span style=color:#e6db74>&#34;&#34;</span>..autotmp_12<span style=color:#ae81ff>+88</span>(SP), AX
<span style=color:#ae81ff>0x01f3</span> <span style=color:#ae81ff>00499</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>9</span>)        CALL    <span style=color:#a6e22e>runtime.deferprocStack</span>(SB)
<span style=color:#66d9ef>...</span>
</code></pre></div><p>0x01e2处，将<code>"".main.func1·f(SB)</code>函数加载到CX，接下来将CX中的内容放置在<code>""..autotmp_12+112(SP)</code>。下一步将<code>""..autotmp_12+88(SP)</code>作为<code>runtime.deferprocStack</code>的参数。</p><p>这里可以简单分析一下，从<code>""..autotmp_12+88(SP)</code>到<code>""..autotmp_12+112(SP)</code>，这中间有24个字节的宽度，而<code>_defer</code>的前几个字段如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_defer</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>started</span> <span style=color:#66d9ef>bool</span>      <span style=color:#75715e>// 1字节
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>heap</span>    <span style=color:#66d9ef>bool</span>      <span style=color:#75715e>// 1字节
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>openDefer</span> <span style=color:#66d9ef>bool</span>    <span style=color:#75715e>// 1字节
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sp</span>        <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 8字节
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>pc</span>        <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 8字节
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>fn</span>        <span style=color:#66d9ef>func</span>()  <span style=color:#75715e>// defer关键字传入的函数， 当使用open-coded defer时可为空
</span><span style=color:#75715e></span>	<span style=color:#f92672>...</span>
}
</code></pre></div><p>在fn之前共有1+1+1+8+8=19个字节的宽度，但实际上在进行内存分配时，在3个bool型字段后，需要添加5字节进行内存对齐，因此从<code>_defer</code>的开始地址到fn的地址，这中间的宽度就变成了1+1+1+5+8+8=24。</p><p>因此我们可以知道这几行汇编的前三行，是将函数赋值到<code>_defer</code>的fn字段上。</p><p>知道了这些，我们再来看runtime.deferprocStack`：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferprocStack</span>(<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>) {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>() <span style=color:#75715e>// 获取当前g
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span> {
		<span style=color:#75715e>// go code on the system stack can&#39;t defer
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;defer on system stack&#34;</span>)
	}

	<span style=color:#75715e>// fn已被赋值过，其他的字段在这里赋值
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>started</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>heap</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>openDefer</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>getcallersp</span>()
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>pc</span> = <span style=color:#a6e22e>getcallerpc</span>()
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>framepc</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>varp</span> = <span style=color:#ae81ff>0</span>

	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span>)) = <span style=color:#ae81ff>0</span>
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fd</span>)) = <span style=color:#ae81ff>0</span>
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>)) = uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>))
	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>)) = uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>))

	<span style=color:#a6e22e>return0</span>()
}
</code></pre></div><p>将<code>_defer</code>分配在栈上，并将其放入<code>g</code>的defer链表中。</p><h3 id=22-堆上分配>2.2 堆上分配<a hidden class=anchor aria-hidden=true href=#22-堆上分配>#</a></h3><p>堆上分配是默认的兜底方案。</p><p>编译如下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
                <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) {
                        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
                }(<span style=color:#a6e22e>i</span>)
        }
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>go tool compile -S -N  main.go
</code></pre></div><p>可看到其调用了<code>runtime.deferproc</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferproc</span>(<span style=color:#a6e22e>fn</span> <span style=color:#66d9ef>func</span>()) {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>() <span style=color:#75715e>// 获取g
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>curg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span> {
		<span style=color:#75715e>// go code on the system stack can&#39;t defer
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;defer on system stack&#34;</span>)
	}

	<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newdefer</span>() <span style=color:#75715e>// 获取一个_defer
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;deferproc: d.panic != nil after newdefer&#34;</span>)
	}
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// 将_defer以头插法插入到g的_defer链表中
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#a6e22e>fn</span>            <span style=color:#75715e>// 设置_defer函数
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>pc</span> = <span style=color:#a6e22e>getcallerpc</span>() <span style=color:#75715e>// 保存上下文环境
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>getcallersp</span>()

	<span style=color:#a6e22e>return0</span>()
}
</code></pre></div><p>相对于栈上分配，在堆上分配设计到<code>newdefer</code>的调用，而通过上文的分析我们可知，在调用<code>newdefer</code>时，会涉及到<code>sched</code>、<code>p</code>以及对<code>m</code>的加锁，因此性能上不如栈上分配。且，栈上分配不需要写屏障。</p><h2 id=3-执行defer>3. 执行defer<a hidden class=anchor aria-hidden=true href=#3-执行defer>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#ae81ff>1</span>)
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#ae81ff>2</span>)
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#ae81ff>3</span>)
        <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
                <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#ae81ff>4</span>)
        }()
}
</code></pre></div><p>查看以上代码的汇编代码时，可看到：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-s data-lang=s><span style=color:#ae81ff>0x0200</span> <span style=color:#ae81ff>00512</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>)       CALL    <span style=color:#a6e22e>runtime.deferreturn</span>(SB)
<span style=color:#ae81ff>0x0205</span> <span style=color:#ae81ff>00517</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>)       MOVQ    <span style=color:#ae81ff>440</span>(SP), BP
<span style=color:#ae81ff>0x020d</span> <span style=color:#ae81ff>00525</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>)       ADDQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>448</span>, SP
<span style=color:#ae81ff>0x0214</span> <span style=color:#ae81ff>00532</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>)       RET
<span style=color:#ae81ff>0x0215</span> <span style=color:#ae81ff>00533</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>9</span>)        CALL    <span style=color:#a6e22e>runtime.deferreturn</span>(SB)
<span style=color:#ae81ff>0x021a</span> <span style=color:#ae81ff>00538</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>9</span>)        MOVQ    <span style=color:#ae81ff>440</span>(SP), BP
<span style=color:#ae81ff>0x0222</span> <span style=color:#ae81ff>00546</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>9</span>)        ADDQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>448</span>, SP
<span style=color:#ae81ff>0x0229</span> <span style=color:#ae81ff>00553</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>9</span>)        RET
<span style=color:#ae81ff>0x022a</span> <span style=color:#ae81ff>00554</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>)        CALL    <span style=color:#a6e22e>runtime.deferreturn</span>(SB)
<span style=color:#ae81ff>0x022f</span> <span style=color:#ae81ff>00559</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>)        MOVQ    <span style=color:#ae81ff>440</span>(SP), BP
<span style=color:#ae81ff>0x0237</span> <span style=color:#ae81ff>00567</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>)        ADDQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>448</span>, SP
<span style=color:#ae81ff>0x023e</span> <span style=color:#ae81ff>00574</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>)        RET
<span style=color:#ae81ff>0x023f</span> <span style=color:#ae81ff>00575</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>)        NOP
<span style=color:#ae81ff>0x0240</span> <span style=color:#ae81ff>00576</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>7</span>)        CALL    <span style=color:#a6e22e>runtime.deferreturn</span>(SB)
<span style=color:#ae81ff>0x0245</span> <span style=color:#ae81ff>00581</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>7</span>)        MOVQ    <span style=color:#ae81ff>440</span>(SP), BP
<span style=color:#ae81ff>0x024d</span> <span style=color:#ae81ff>00589</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>7</span>)        ADDQ    <span style=color:#f92672>$</span><span style=color:#ae81ff>448</span>, SP
<span style=color:#ae81ff>0x0254</span> <span style=color:#ae81ff>00596</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>7</span>)        RET
<span style=color:#ae81ff>0x0255</span> <span style=color:#ae81ff>00597</span> (main.go<span style=color:#f92672>:</span><span style=color:#ae81ff>6</span>)        CALL    <span style=color:#a6e22e>runtime.deferreturn</span>(SB)
</code></pre></div><p>可以看到会defer的调用是按照其定义的顺序反向调用的。</p><p>在调用了defer的函数中，编译器会自动在函数尾部插入对<code>runtime.deferreturn</code>的调用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deferreturn</span>() {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>() <span style=color:#75715e>// 获取当前g
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// defer链表的第一个defer，也是最后一个被定义的defer
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>return</span>
		}
		<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallersp</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>sp</span> {
			<span style=color:#66d9ef>return</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>openDefer</span> { <span style=color:#75715e>// 如果开启了open-coded defer
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runOpenDeferFrame</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>d</span>)
			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>done</span> {
				<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unfinished open-coded defers in deferreturn&#34;</span>)
			}
			<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span> <span style=color:#75715e>//// 删除链表的第一个元素
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span>)
			<span style=color:#75715e>// If this frame uses open defers, then this
</span><span style=color:#75715e></span>			<span style=color:#75715e>// must be the only defer record for the
</span><span style=color:#75715e></span>			<span style=color:#75715e>// frame, so we can just return.
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span>
		}

		<span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> <span style=color:#75715e>// 取出defer函数
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span> <span style=color:#75715e>// 删除链表的第一个元素
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span>) <span style=color:#75715e>// 释放_defer
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>fn</span>() <span style=color:#75715e>// 调用defer函数
</span><span style=color:#75715e></span>	}
}
</code></pre></div><h2 id=4-defer的三种处理机制>4. defer的三种处理机制<a hidden class=anchor aria-hidden=true href=#4-defer的三种处理机制>#</a></h2><p>经过以上的分析，我们可以总结一下，defer的三种处理机制：</p><ol><li>open-coded defer</li><li>栈上分配的defer</li><li>堆上分配的defer</li></ol><p>其执行效率为：<code>open-coded defer > 栈上分配的defer > 堆上分配的defer</code></p><h3 id=41-处理机制的选择>4.1 处理机制的选择<a hidden class=anchor aria-hidden=true href=#41-处理机制的选择>#</a></h3><ul><li><p>在defer语句出现在了循环语句里，或者无法执行更高阶的编译器优化时，亦或者同一个函数中使用了过多的defer时，会使用堆上分配<a href=https://cloud.tencent.com/developer/article/1596802>[2]</a></p></li><li><p>满足以下三种情况时<a href=https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#535-%e5%bc%80%e6%94%be%e7%bc%96%e7%a0%81>[3]</a>，会使用open-coded defer</p><ol><li>没有禁用编译器优化，即没有设置 -gcflags &ldquo;-N&rdquo;；</li><li>函数内 defer 的数量不超过 8 个，且返回语句与延迟语句个数的乘积不超过 15；</li><li>defer 不是在循环语句中。</li></ol></li><li><p>其他大部分情况下，会使用栈上分配</p></li></ul><p><strong>END</strong></p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md>https://github.com/golang/proposal/blob/master/design/34481-opencoded-defers.md</a></p><p><a href=https://cloud.tencent.com/developer/article/1596802>https://cloud.tencent.com/developer/article/1596802</a></p><p><a href=https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#535-%e5%bc%80%e6%94%be%e7%bc%96%e7%a0%81>https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#535-%e5%bc%80%e6%94%be%e7%bc%96%e7%a0%81</a></p><p><a href=https://juejin.cn/post/6844904078569373710>https://juejin.cn/post/6844904078569373710</a></p><p><a href=https://xargin.com/go-1-13-defer-change/>https://xargin.com/go-1-13-defer-change/</a></p><p><a href=https://juejin.cn/post/6975686540601245709>https://juejin.cn/post/6975686540601245709</a></p><p><a href=https://zhuanlan.zhihu.com/p/401339057>https://zhuanlan.zhihu.com/p/401339057</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/golang/>golang</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/runtime/>runtime</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%94slice/><span class=title>« Prev Page</span><br><span>runtime篇五：slice</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/><span class=title>Next Page »</span><br><span>runtime篇四：panic</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>