<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>runtime篇二：通道 | Linote</title><meta name=keywords content="golang,runtime"><meta name=description content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. chan的结构 一个channel长这样：
type hchan struct { qcount uint // total data in the queue 	dataqsiz uint // size of the circular queue 	buf unsafe.Pointer // points to an array of dataqsiz elements 	elemsize uint16 // chan中元素大小 	closed uint32 // 是否关闭 	elemtype *_type // element type 	sendx uint // send index 	recvx uint // receive index 	recvq waitq // list of recv waiters 	sendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分："><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="runtime篇二：通道"><meta property="og:description" content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. chan的结构 一个channel长这样：
type hchan struct { qcount uint // total data in the queue 	dataqsiz uint // size of the circular queue 	buf unsafe.Pointer // points to an array of dataqsiz elements 	elemsize uint16 // chan中元素大小 	closed uint32 // 是否关闭 	elemtype *_type // element type 	sendx uint // send index 	recvx uint // receive index 	recvq waitq // list of recv waiters 	sendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分："><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-05T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-05T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="runtime篇二：通道"><meta name=twitter:description content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. chan的结构 一个channel长这样：
type hchan struct { qcount uint // total data in the queue 	dataqsiz uint // size of the circular queue 	buf unsafe.Pointer // points to an array of dataqsiz elements 	elemsize uint16 // chan中元素大小 	closed uint32 // 是否关闭 	elemtype *_type // element type 	sendx uint // send index 	recvx uint // receive index 	recvq waitq // list of recv waiters 	sendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"runtime篇二：通道","item":"http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"runtime篇二：通道","name":"runtime篇二：通道","description":"本系列代码基于golang1.19\n  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. chan的结构 一个channel长这样：\ntype hchan struct { qcount uint // total data in the queue \tdataqsiz uint // size of the circular queue \tbuf unsafe.Pointer // points to an array of dataqsiz elements \telemsize uint16 // chan中元素大小 \tclosed uint32 // 是否关闭 \telemtype *_type // element type \tsendx uint // send index \trecvx uint // receive index \trecvq waitq // list of recv waiters \tsendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分：","keywords":["golang","runtime"],"articleBody":" 本系列代码基于golang1.19\n  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic runtime篇五：slice  1. chan的结构 一个channel长这样：\ntype hchan struct { qcount uint // total data in the queue \tdataqsiz uint // size of the circular queue \tbuf unsafe.Pointer // points to an array of dataqsiz elements \telemsize uint16 // chan中元素大小 \tclosed uint32 // 是否关闭 \telemtype *_type // element type \tsendx uint // send index \trecvx uint // receive index \trecvq waitq // list of recv waiters \tsendq waitq // list of send waiters  lock mutex } channel的字段中，主要可以分为三部分：\n第一部分是标识channel自身的一些状态和性质，如hchan.closed标识chan是否关闭，hchan.elemsize标识chan中元素的大小、hchan.elemtype标识chan中元素类型；\n第二部分是标识底层循环数组的状态的字段，如hchan.qcount标识当前数组中元素数量、hchan.dataqsiz标识循环数组的大小、hchan.buf是指向底层数组的指针、hchan.sendx标识待发送元素的下标、hchan.recvx标识待接收元素的下标；\n第三部分是存储正等待当前chan的goroutine，如hchan.recvq存储等待接收的goroutine，hchan.sendq存储等待发送的gotoutine\n最后是一个锁，保证了并发安全。\n1.1 如何构造一个chan 通过汇编可以看到，在构造chan时，调用的是runtime.makechan函数，函数如下：\ntype chantype struct { typ _type elem *_type dir uintptr } func makechan(t *chantype, size int) *hchan { elem := t.elem // ...  // 省略部分检查代码  mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem  maxAlloc-hchanSize || size 0 { panic(plainError(\"makechan: size out of range\")) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. \t// buf points into the same allocation, elemtype is persistent. \t// SudoG's are referenced from their owning thread so they can't be collected. \t// TODO(dvyukov,rlh): Rethink when collector can move allocated objects. \tvar c *hchan switch { case mem == 0: // Queue or element size is zero. \tc = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. \tc.buf = c.raceaddr() case elem.ptrdata == 0: // Elements do not contain pointers. \t// Allocate hchan and buf in one call. \tc = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. \tc = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026c.lock, lockRankHchan) if debugChan { print(\"makechan: chan=\", c, \"; elemsize=\", elem.size, \"; dataqsiz=\", size, \"\\n\") } return c } 首先对mem进行了计算，mem是chan中元素所占的空间\nruntime.makechan函数中，受先是一些检查，然后根据chan的长度和elem的类型，会有不同的构造策略：\n 如果是构造一个无缓冲chan，即参数size为0，那么默认分配hchanSize=96字节空间并强制转换为*hchan类型，96字节是一个hchan的大小。然后 如果chan的elem不包含指针，则分配hchanSize+mem空间给chan，并将hchanSize之后的所有空间分配给hchan.buf。 如果chan的elel包含指针，那么直接new一个chan，并为hchan.buf分配meme大小的空间  最后将hchan.elemsize、hchan.elemtype、hchan.dataqsiz进行赋值。\n返回一个hchan的指针，这保证了我们在对channel进行传递时不会进行复制。\n2. chan的发送与接收 2.1 chan的发送 chan发送时调用了runtime.chansend1:\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { // 如果chan为nil \tif !block { // 如果不可阻塞 \treturn false // 发送失败 \t} gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) // 可阻塞，goroutine挂起 \tthrow(\"unreachable\") } // 省略部分代码  if !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c) { // 不可阻塞，chan未关闭且已满，则发送失败 \treturn false } var t0 int64 if blockprofilerate  0 { t0 = cputicks() } lock(\u0026c.lock) // 加锁，并发安全  if c.closed != 0 { // 如果chan已经被关闭了 \tunlock(\u0026c.lock) // 解锁 \tpanic(plainError(\"send on closed channel\")) // 向已关闭的chan发送会panic \t} // 如果接收队列中存在goroutine，则不经过hchan.buf，而直接复制到接收端缓冲区 \tif sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send \t// directly to the receiver, bypassing the channel buffer (if any). \tsend(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true } // chan还没满 \tif c.qcount c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. \tqp := chanbuf(c, c.sendx) // 计算存放元素的内存地址 \tif raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) // 将元素复制到buf \tc.sendx++ // 待发送下标+1 \tif c.sendx == c.dataqsiz { // 循环数组 \tc.sendx = 0 } c.qcount++ // 总元素数量+1 \tunlock(\u0026c.lock) // 解锁 \treturn true // 发送成功 \t} // chan满了  if !block { // chan满了，且要求不可阻塞，则直接失败 \tunlock(\u0026c.lock) return false } // 可以阻塞  // 获取当前goroutine指针 \tgp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // 当前goroutine进入chan的待发送队列  atomic.Store8(\u0026gp.parkingOnChan, 1) // 挂起当前goroutine \tgopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) KeepAlive(ep) // 当前goroutine被唤醒了 \tif mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime  0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) if closed { // 被唤醒后发现chan关闭了 \tif c.closed == 0 { throw(\"chansend: spurious wakeup\") } panic(plainError(\"send on closed channel\")) } return true } 上述代码的主要逻辑是：\n 检查会发送失败的情况 加锁  再次检查会发送失败的情况，失败则解锁返回失败 如果有goroutine在等着接收，直接复制给它，解锁返回成功 chan的buf没满，复制到buf中，解锁返回成功 如果chan的buf满了  不可以阻塞，解锁返回失败 可以阻塞，让goroutine进入等待队列并挂起，等待唤醒      唤醒后，不会再进行发送或复制等，因为一个goroutine如果是从等待队列被唤醒，则是直接从发送goroutine将消息复制过来，然后才唤醒，因此可以直接结束。\n如果在发送时发现有等待接收的goroutine，会调用runtime.send将元素复制给等待的goroutine，runtime.send如下：\nfunc send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { if raceenabled { if c.dataqsiz == 0 { racesync(c, sg) } else { // Pretend we go through the buffer, even though \t// we copy directly. Note that we need to increment \t// the head/tail locations only when raceenabled. \tracenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz \t} } // sg.elem 指向接收到的值存放的位置，如 val \tif sg.elem != nil { sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } 2.2 chan的接收 chan接收时调用的函数为runtime.chanrecv:\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { if debugChan { print(\"chanrecv: chan=\", c, \"\\n\") } if c == nil { // chan为nil \tif !block { // 且不可阻塞 \treturn\t// 直接返回失败 \t} gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) // 可阻塞，gotoutine挂起 \tthrow(\"unreachable\") } // Fast path: check for failed non-blocking operation without acquiring the lock. \tif !block \u0026\u0026 empty(c) { // 不可阻塞且chan为空 \tif atomic.Load(\u0026c.closed) == 0 { // chan没关闭 \treturn } // The channel is irreversibly closed. Re-check whether the channel has any pending data \t// to receive, which could have arrived between the empty and closed checks above. \t// Sequential consistency is also required here, when racing with such a send. \tif empty(c) { // chan被关闭了，但其中可能还有未取出的值 \t// The channel is irreversibly closed and empty. \tif raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } var t0 int64 if blockprofilerate  0 { t0 = cputicks() } lock(\u0026c.lock) // 上锁  if c.closed != 0 {\t// 再次检查chan是否被关闭 \tif c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } // The channel has been closed, but the channel's buffer have data. \t} else { // Just found waiting sender with not closed. \tif sg := c.sendq.dequeue(); sg != nil { // 有个chan等着发 \t// Found a waiting sender. If buffer is size 0, receive value \t// directly from sender. Otherwise, receive from head of queue \t// and add sender's value to the tail of the queue (both map to \t// the same buffer slot because the queue is full). \trecv(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true, true } } if c.qcount  0 { // 当前chan中有值 \t// Receive directly from queue \tqp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } if ep != nil { typedmemmove(c.elemtype, ep, qp)\t// 将消息复制给接收者 \t} typedmemclr(c.elemtype, qp)\t// 清理发送者内存空间 \tc.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026c.lock) return true, true } if !block {\t// 当前chan中没有值，又不能阻塞，只好失败 \tunlock(\u0026c.lock) return false, false } // 可以阻塞，先坐等一会 \tgp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg \t// on gp.waiting where copystack can find it. \tmysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil c.recvq.enqueue(mysg) atomic.Store8(\u0026gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) // 被唤醒了 \tif mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime  0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) return true, success } 总体来看，和发送的过程很相似，主要是检查chan是否关闭，是否可阻塞，是否有发送者等待，chan中是否有值，然后做出响应的处理。\n在使用chan进行接收时，有时可以使用ok来标识是否真的从chan中接收到了值，go底层通过不同的函数做到这一点：\n// a := func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } // a, ok := func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } 3. chan的关闭 关闭chan时，调用的是runtime.closechan:\nfunc closechan(c *hchan) { if c == nil { // 不能关闭一个nilchan \tpanic(plainError(\"close of nil channel\")) } lock(\u0026c.lock) if c.closed != 0 { // 不能重复关闭chan \tunlock(\u0026c.lock) panic(plainError(\"close of closed channel\")) } if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan)) racerelease(c.raceaddr()) } c.closed = 1 // 设置chan状态为关闭  var glist gList // 处理所有等待读取的goroutine \tfor { sg := c.recvq.dequeue() if sg == nil { // 当recvq中没有goroutine时跳出 \tbreak } if sg.elem != nil { // sg.elem不为空说明接受者未忽略接收值 \ttypedmemclr(c.elemtype, sg.elem) // 给等待读取的设置零值 \tsg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } // 把goroutine取出来 \tgp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) // 将goroutine推入glist \t} // 所有想要发送的goroutine，对不起，你们panic吧 \tfor { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) // 将goroutine推入glist \t} unlock(\u0026c.lock) // 遍历gList，把其中的所有goroutine唤醒 \tfor !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } } 对于chan的关闭，主要有两点：\n 对于待接收的chan，如果chan缓冲区中没有值了，则返回其一个零值，如果缓冲区还有值，则把值交给它 对于待发送的chan，对不起了宝贝们，你们都给爷爷panic吧  References https://golang.design/go-questions/channel/struct/\nhttps://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8\n","wordCount":"1419","inLanguage":"en","datePublished":"2022-08-05T00:00:00Z","dateModified":"2022-08-05T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>runtime篇二：通道</h1><div class=post-meta><span title="2022-08-05 00:00:00 +0000 UTC">August 5, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-chan%e7%9a%84%e7%bb%93%e6%9e%84 aria-label="1. chan的结构">1. chan的结构</a><ul><li><a href=#11-%e5%a6%82%e4%bd%95%e6%9e%84%e9%80%a0%e4%b8%80%e4%b8%aachan aria-label="1.1 如何构造一个chan">1.1 如何构造一个chan</a></li></ul></li><li><a href=#2-chan%e7%9a%84%e5%8f%91%e9%80%81%e4%b8%8e%e6%8e%a5%e6%94%b6 aria-label="2. chan的发送与接收">2. chan的发送与接收</a><ul><li><a href=#21-chan%e7%9a%84%e5%8f%91%e9%80%81 aria-label="2.1 chan的发送">2.1 chan的发送</a></li><li><a href=#22-chan%e7%9a%84%e6%8e%a5%e6%94%b6 aria-label="2.2 chan的接收">2.2 chan的接收</a></li></ul></li><li><a href=#3-chan%e7%9a%84%e5%85%b3%e9%97%ad aria-label="3. chan的关闭">3. chan的关闭</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><blockquote><p>本系列代码基于<a href=https://github.com/golang/go/tree/1e5987635cc8bf99e8a20d240da80bd6f0f793f7>golang1.19</a></p></blockquote><ul><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/>runtime篇一：接口</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/>runtime篇二：通道</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/>runtime篇三：defer</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/>runtime篇四：panic</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%94slice/>runtime篇五：slice</a></li></ul><h2 id=1-chan的结构>1. chan的结构<a hidden class=anchor aria-hidden=true href=#1-chan的结构>#</a></h2><p>一个channel长这样：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>qcount</span>   <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// total data in the queue
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>           <span style=color:#75715e>// size of the circular queue
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>buf</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// points to an array of dataqsiz elements
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// chan中元素大小
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>closed</span>   <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 是否关闭
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span> <span style=color:#75715e>// element type
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sendx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// send index
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>recvx</span>    <span style=color:#66d9ef>uint</span>   <span style=color:#75715e>// receive index
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>recvq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// list of recv waiters
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sendq</span>    <span style=color:#a6e22e>waitq</span>  <span style=color:#75715e>// list of send waiters
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
}
</code></pre></div><p>channel的字段中，主要可以分为三部分：</p><p>第一部分是标识channel自身的一些状态和性质，如<code>hchan.closed</code>标识chan是否关闭，<code>hchan.elemsize</code>标识chan中元素的大小、<code>hchan.elemtype</code>标识chan中元素类型；</p><p>第二部分是标识底层循环数组的状态的字段，如<code>hchan.qcount</code>标识当前数组中元素数量、<code>hchan.dataqsiz</code>标识循环数组的大小、<code>hchan.buf</code>是指向底层数组的指针、<code>hchan.sendx</code>标识待发送元素的下标、<code>hchan.recvx</code>标识待接收元素的下标；</p><p>第三部分是存储正等待当前chan的goroutine，如<code>hchan.recvq</code>存储等待接收的goroutine，<code>hchan.sendq</code>存储等待发送的gotoutine</p><p>最后是一个锁，保证了并发安全。</p><h3 id=11-如何构造一个chan>1.1 如何构造一个chan<a hidden class=anchor aria-hidden=true href=#11-如何构造一个chan>#</a></h3><p>通过汇编可以看到，在构造chan时，调用的是<code>runtime.makechan</code>函数，函数如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>chantype</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>typ</span>  <span style=color:#a6e22e>_type</span>
	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
	<span style=color:#a6e22e>dir</span>  <span style=color:#66d9ef>uintptr</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makechan</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>chantype</span>, <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span> {
	<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>

	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 省略部分检查代码
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>size</span>))
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span><span style=color:#f92672>-</span><span style=color:#a6e22e>hchanSize</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#ae81ff>0</span> {
		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;makechan: size out of range&#34;</span>))
	}

	<span style=color:#75715e>// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// buf points into the same allocation, elemtype is persistent.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span><span style=color:#75715e></span>	<span style=color:#75715e>// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>
	<span style=color:#66d9ef>switch</span> {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>mem</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
		<span style=color:#75715e>// Queue or element size is zero.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
		<span style=color:#75715e>// Race detector uses this location for synchronization.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>()
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
		<span style=color:#75715e>// Elements do not contain pointers.
</span><span style=color:#75715e></span>		<span style=color:#75715e>// Allocate hchan and buf in one call.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>)(<span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>hchanSize</span><span style=color:#f92672>+</span><span style=color:#a6e22e>mem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>))
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>c</span>), <span style=color:#a6e22e>hchanSize</span>)
	<span style=color:#66d9ef>default</span>:
		<span style=color:#75715e>// Elements contain pointers.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> = new(<span style=color:#a6e22e>hchan</span>)
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
	}

	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemsize</span> = uint16(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>)
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span> = <span style=color:#a6e22e>elem</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> = uint(<span style=color:#a6e22e>size</span>)
	<span style=color:#a6e22e>lockInit</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankHchan</span>)

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>debugChan</span> {
		print(<span style=color:#e6db74>&#34;makechan: chan=&#34;</span>, <span style=color:#a6e22e>c</span>, <span style=color:#e6db74>&#34;; elemsize=&#34;</span>, <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>size</span>, <span style=color:#e6db74>&#34;; dataqsiz=&#34;</span>, <span style=color:#a6e22e>size</span>, <span style=color:#e6db74>&#34;\n&#34;</span>)
	}
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
}
</code></pre></div><p>首先对<code>mem</code>进行了计算，<code>mem</code>是chan中元素所占的空间</p><p><code>runtime.makechan</code>函数中，受先是一些检查，然后根据chan的长度和elem的类型，会有不同的构造策略：</p><ul><li>如果是构造一个无缓冲chan，即参数size为0，那么默认分配<code>hchanSize</code>=96字节空间并强制转换为*hchan类型，96字节是一个hchan的大小。然后</li><li>如果chan的elem不包含指针，则分配<code>hchanSize+mem</code>空间给chan，并将<code>hchanSize</code>之后的所有空间分配给<code>hchan.buf</code>。</li><li>如果chan的elel包含指针，那么直接new一个chan，并为<code>hchan.buf</code>分配<code>meme</code>大小的空间</li></ul><p>最后将<code>hchan.elemsize</code>、<code>hchan.elemtype</code>、<code>hchan.dataqsiz</code>进行赋值。</p><p>返回一个<code>hchan</code>的指针，这保证了我们在对channel进行传递时不会进行复制。</p><h2 id=2-chan的发送与接收>2. chan的发送与接收<a hidden class=anchor aria-hidden=true href=#2-chan的发送与接收>#</a></h2><h3 id=21-chan的发送>2.1 chan的发送<a hidden class=anchor aria-hidden=true href=#21-chan的发送>#</a></h3><p>chan发送时调用了<code>runtime.chansend1</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chansend</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>callerpc</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 如果chan为nil
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> { <span style=color:#75715e>// 如果不可阻塞
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>    <span style=color:#75715e>// 发送失败
</span><span style=color:#75715e></span>		}
		<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanSendNilChan</span>, <span style=color:#a6e22e>traceEvGoStop</span>, <span style=color:#ae81ff>2</span>) <span style=color:#75715e>// 可阻塞，goroutine挂起
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
	}

    <span style=color:#75715e>// 省略部分代码
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>full</span>(<span style=color:#a6e22e>c</span>) { <span style=color:#75715e>// 不可阻塞，chan未关闭且已满，则发送失败
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
	}

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t0</span> <span style=color:#66d9ef>int64</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
	}

	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>// 加锁，并发安全
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 如果chan已经被关闭了
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>// 解锁
</span><span style=color:#75715e></span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>)) <span style=color:#75715e>// 向已关闭的chan发送会panic
</span><span style=color:#75715e></span>	}

    <span style=color:#75715e>// 如果接收队列中存在goroutine，则不经过hchan.buf，而直接复制到接收端缓冲区
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#75715e>// Found a waiting receiver. We pass the value we want to send
</span><span style=color:#75715e></span>		<span style=color:#75715e>// directly to the receiver, bypassing the channel buffer (if any).
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
	}

    <span style=color:#75715e>// chan还没满
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &lt; <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
		<span style=color:#75715e>// Space is available in the channel buffer. Enqueue the element to send.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>) <span style=color:#75715e>// 计算存放元素的内存地址
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span>, <span style=color:#66d9ef>nil</span>)
		}
		<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>, <span style=color:#a6e22e>ep</span>) <span style=color:#75715e>// 将元素复制到buf
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span><span style=color:#f92672>++</span> <span style=color:#75715e>// 待发送下标+1
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> { <span style=color:#75715e>// 循环数组
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#ae81ff>0</span>
		}
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>++</span> <span style=color:#75715e>// 总元素数量+1
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>// 解锁
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span> <span style=color:#75715e>// 发送成功
</span><span style=color:#75715e></span>	}

    <span style=color:#75715e>// chan满了
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> { <span style=color:#75715e>// chan满了，且要求不可阻塞，则直接失败
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
	}

    <span style=color:#75715e>// 可以阻塞
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 获取当前goroutine指针
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
	}
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>isSelect</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>) <span style=color:#75715e>// 当前goroutine进入chan的待发送队列
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store8</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>parkingOnChan</span>, <span style=color:#ae81ff>1</span>)

    <span style=color:#75715e>// 挂起当前goroutine
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>chanparkcommit</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>waitReasonChanSend</span>, <span style=color:#a6e22e>traceEvGoBlockSend</span>, <span style=color:#ae81ff>2</span>)
	<span style=color:#a6e22e>KeepAlive</span>(<span style=color:#a6e22e>ep</span>)

	<span style=color:#75715e>// 当前goroutine被唤醒了
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
	}
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>closed</span> <span style=color:#f92672>:=</span> !<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
	}
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>closed</span> { <span style=color:#75715e>// 被唤醒后发现chan关闭了
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;chansend: spurious wakeup&#34;</span>)
		}
		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;send on closed channel&#34;</span>))
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
</code></pre></div><p>上述代码的主要逻辑是：</p><ul><li>检查会发送失败的情况</li><li>加锁<ul><li>再次检查会发送失败的情况，失败则解锁返回失败</li><li>如果有goroutine在等着接收，直接复制给它，解锁返回成功</li><li>chan的buf没满，复制到buf中，解锁返回成功</li><li>如果chan的buf满了<ul><li>不可以阻塞，解锁返回失败</li><li>可以阻塞，让goroutine进入等待队列并挂起，等待唤醒</li></ul></li></ul></li></ul><p>唤醒后，不会再进行发送或复制等，因为一个goroutine如果是从等待队列被唤醒，则是直接从发送goroutine将消息复制过来，然后才唤醒，因此可以直接结束。</p><p>如果在发送时发现有等待接收的goroutine，会调用<code>runtime.send</code>将元素复制给等待的goroutine，<code>runtime.send</code>如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>sg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sudog</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(), <span style=color:#a6e22e>skip</span> <span style=color:#66d9ef>int</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>racesync</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>)
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#75715e>// Pretend we go through the buffer, even though
</span><span style=color:#75715e></span>			<span style=color:#75715e>// we copy directly. Note that we need to increment
</span><span style=color:#75715e></span>			<span style=color:#75715e>// the head/tail locations only when raceenabled.
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#66d9ef>nil</span>)
			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#a6e22e>sg</span>)
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
				<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
			}
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendx</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#75715e>// c.sendx = (c.sendx+1) % c.dataqsiz
</span><span style=color:#75715e></span>		}
	}
	<span style=color:#75715e>// sg.elem 指向接收到的值存放的位置，如 val &lt;- ch，指的就是 &amp;val
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>sendDirect</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>)
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
	}
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
	<span style=color:#a6e22e>unlockf</span>()
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
	<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
	}
	<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>skip</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
}
</code></pre></div><h3 id=22-chan的接收>2.2 chan的接收<a hidden class=anchor aria-hidden=true href=#22-chan的接收>#</a></h3><p>chan接收时调用的函数为<code>runtime.chanrecv</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>ep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>block</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#a6e22e>selected</span>, <span style=color:#a6e22e>received</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>debugChan</span> {
		print(<span style=color:#e6db74>&#34;chanrecv: chan=&#34;</span>, <span style=color:#a6e22e>c</span>, <span style=color:#e6db74>&#34;\n&#34;</span>)
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// chan为nil
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> { <span style=color:#75715e>// 且不可阻塞
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span>	<span style=color:#75715e>// 直接返回失败
</span><span style=color:#75715e></span>		}
		<span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>waitReasonChanReceiveNilChan</span>, <span style=color:#a6e22e>traceEvGoStop</span>, <span style=color:#ae81ff>2</span>) <span style=color:#75715e>// 可阻塞，gotoutine挂起
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;unreachable&#34;</span>)
	}

	<span style=color:#75715e>// Fast path: check for failed non-blocking operation without acquiring the lock.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>empty</span>(<span style=color:#a6e22e>c</span>) { <span style=color:#75715e>// 不可阻塞且chan为空
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// chan没关闭
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span>
		}
		<span style=color:#75715e>// The channel is irreversibly closed. Re-check whether the channel has any pending data
</span><span style=color:#75715e></span>		<span style=color:#75715e>// to receive, which could have arrived between the empty and closed checks above.
</span><span style=color:#75715e></span>		<span style=color:#75715e>// Sequential consistency is also required here, when racing with such a send.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>empty</span>(<span style=color:#a6e22e>c</span>) { <span style=color:#75715e>// chan被关闭了，但其中可能还有未取出的值
</span><span style=color:#75715e></span>			<span style=color:#75715e>// The channel is irreversibly closed and empty.
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
				<span style=color:#a6e22e>raceacquire</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
			}
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>)
			}
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>
		}
	}

	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>t0</span> <span style=color:#66d9ef>int64</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>blockprofilerate</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>t0</span> = <span style=color:#a6e22e>cputicks</span>()
	}

	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) <span style=color:#75715e>// 上锁
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {	<span style=color:#75715e>// 再次检查chan是否被关闭
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
				<span style=color:#a6e22e>raceacquire</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
			}
			<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
				<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>)
			}
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>
		}
		<span style=color:#75715e>// The channel has been closed, but the channel&#39;s buffer have data.
</span><span style=color:#75715e></span>	} <span style=color:#66d9ef>else</span> {
		<span style=color:#75715e>// Just found waiting sender with not closed.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>(); <span style=color:#a6e22e>sg</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 有个chan等着发
</span><span style=color:#75715e></span>			<span style=color:#75715e>// Found a waiting sender. If buffer is size 0, receive value
</span><span style=color:#75715e></span>			<span style=color:#75715e>// directly from sender. Otherwise, receive from head of queue
</span><span style=color:#75715e></span>			<span style=color:#75715e>// and add sender&#39;s value to the tail of the queue (both map to
</span><span style=color:#75715e></span>			<span style=color:#75715e>// the same buffer slot because the queue is full).
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>recv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>sg</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#66d9ef>func</span>() { <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>) }, <span style=color:#ae81ff>3</span>)
			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>
		}
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span> &gt; <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 当前chan中有值
</span><span style=color:#75715e></span>		<span style=color:#75715e>// Receive directly from queue
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>qp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chanbuf</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
			<span style=color:#a6e22e>racenotify</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span>, <span style=color:#66d9ef>nil</span>)
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ep</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>ep</span>, <span style=color:#a6e22e>qp</span>)	<span style=color:#75715e>// 将消息复制给接收者
</span><span style=color:#75715e></span>		}
		<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>qp</span>)	<span style=color:#75715e>// 清理发送者内存空间
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span><span style=color:#f92672>++</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dataqsiz</span> {
			<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvx</span> = <span style=color:#ae81ff>0</span>
		}
		<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>qcount</span><span style=color:#f92672>--</span>
		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>true</span>
	}

	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>block</span> {	<span style=color:#75715e>// 当前chan中没有值，又不能阻塞，只好失败
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>
	}

	<span style=color:#75715e>// 可以阻塞，先坐等一会
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>mysg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquireSudog</span>()
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t0</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
	}
	<span style=color:#75715e>// No stack splits between assigning elem and enqueuing mysg
</span><span style=color:#75715e></span>	<span style=color:#75715e>// on gp.waiting where copystack can find it.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>ep</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>waitlink</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#a6e22e>mysg</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>gp</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>isSelect</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>c</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>enqueue</span>(<span style=color:#a6e22e>mysg</span>)
	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store8</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>parkingOnChan</span>, <span style=color:#ae81ff>1</span>)
	<span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>chanparkcommit</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>), <span style=color:#a6e22e>waitReasonChanReceive</span>, <span style=color:#a6e22e>traceEvGoBlockRecv</span>, <span style=color:#ae81ff>2</span>)

	<span style=color:#75715e>// 被唤醒了
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> {
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;G waiting list is corrupted&#34;</span>)
	}
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waiting</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>activeStackChans</span> = <span style=color:#66d9ef>false</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span> &gt; <span style=color:#ae81ff>0</span> {
		<span style=color:#a6e22e>blockevent</span>(<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>releasetime</span><span style=color:#f92672>-</span><span style=color:#a6e22e>t0</span>, <span style=color:#ae81ff>2</span>)
	}
	<span style=color:#a6e22e>success</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>success</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>mysg</span>.<span style=color:#a6e22e>c</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#a6e22e>releaseSudog</span>(<span style=color:#a6e22e>mysg</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>success</span>
}
</code></pre></div><p>总体来看，和发送的过程很相似，主要是检查chan是否关闭，是否可阻塞，是否有发送者等待，chan中是否有值，然后做出响应的处理。</p><p>在使用chan进行接收时，有时可以使用ok来标识是否真的从chan中接收到了值，go底层通过不同的函数做到这一点：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// a := &lt;-chan
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv1</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) {
	<span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
}

<span style=color:#75715e>// a, ok :=  &lt;-chan
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>chanrecv2</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>, <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) (<span style=color:#a6e22e>received</span> <span style=color:#66d9ef>bool</span>) {
	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>received</span> = <span style=color:#a6e22e>chanrecv</span>(<span style=color:#a6e22e>c</span>, <span style=color:#a6e22e>elem</span>, <span style=color:#66d9ef>true</span>)
	<span style=color:#66d9ef>return</span>
}
</code></pre></div><h2 id=3-chan的关闭>3. chan的关闭<a hidden class=anchor aria-hidden=true href=#3-chan的关闭>#</a></h2><p>关闭chan时，调用的是<code>runtime.closechan</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>closechan</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hchan</span>) {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 不能关闭一个nilchan
</span><span style=color:#75715e></span>		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of nil channel&#34;</span>))
	}

	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> { <span style=color:#75715e>// 不能重复关闭chan
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)
		panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;close of closed channel&#34;</span>))
	}

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
		<span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
		<span style=color:#a6e22e>racewritepc</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>(), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>closechan</span>))
		<span style=color:#a6e22e>racerelease</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
	}

	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>closed</span> = <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 设置chan状态为关闭
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>glist</span> <span style=color:#a6e22e>gList</span>

	<span style=color:#75715e>// 处理所有等待读取的goroutine
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>recvq</span>.<span style=color:#a6e22e>dequeue</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 当recvq中没有goroutine时跳出
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// sg.elem不为空说明接受者未忽略接收值
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>typedmemclr</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>elemtype</span>, <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span>) <span style=color:#75715e>// 给等待读取的设置零值
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
		}

		<span style=color:#75715e>// 把goroutine取出来
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>false</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
			<span style=color:#a6e22e>raceacquireg</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
		}
		<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>) <span style=color:#75715e>// 将goroutine推入glist
</span><span style=color:#75715e></span>	}

	<span style=color:#75715e>// 所有想要发送的goroutine，对不起，你们panic吧
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>sg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>sendq</span>.<span style=color:#a6e22e>dequeue</span>()
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#66d9ef>break</span>
		}
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>elem</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
			<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>releasetime</span> = <span style=color:#a6e22e>cputicks</span>()
		}
		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>g</span>
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>param</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>sg</span>)
		<span style=color:#a6e22e>sg</span>.<span style=color:#a6e22e>success</span> = <span style=color:#66d9ef>false</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
			<span style=color:#a6e22e>raceacquireg</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>raceaddr</span>())
		}
		<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>gp</span>) <span style=color:#75715e>// 将goroutine推入glist
</span><span style=color:#75715e></span>	}
	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>lock</span>)

	<span style=color:#75715e>// 遍历gList，把其中的所有goroutine唤醒
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> !<span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>empty</span>() {
		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>glist</span>.<span style=color:#a6e22e>pop</span>()
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>schedlink</span> = <span style=color:#ae81ff>0</span>
		<span style=color:#a6e22e>goready</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#ae81ff>3</span>)
	}
}
</code></pre></div><p>对于chan的关闭，主要有两点：</p><ul><li>对于待接收的chan，如果chan缓冲区中没有值了，则返回其一个零值，如果缓冲区还有值，则把值交给它</li><li>对于待发送的chan，对不起了宝贝们，你们都给爷爷panic吧</li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://golang.design/go-questions/channel/struct/>https://golang.design/go-questions/channel/struct/</a></p><p><a href=https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8>https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/golang/>golang</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/runtime/>runtime</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/container/%E6%A6%82%E8%A7%88%E5%AE%B9%E5%99%A8%E7%AF%87%E4%BA%8C%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/><span class=title>« Prev Page</span><br><span>概览容器篇二：容器网络</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/><span class=title>Next Page »</span><br><span>runtime篇一：接口</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>