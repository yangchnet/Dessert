<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>runtime篇四：panic | Linote</title><meta name=keywords content="golang,runtime"><meta name=description content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic  1. panic的底层结构 panic在runtime中的底层表示是runtime._panic结构体。
type _panic struct { argp unsafe.Pointer // 指向defer调用时参数的指针 	arg any // panic参数 	link *_panic // 连接到更早的_panic 	pc uintptr // 程序计数器 	sp unsafe.Pointer // 栈指针 	recovered bool // 当前panic是否被recover恢复 	aborted bool // 当前panic是否被中止 	goexit bool // 是否调用了runtime.Goexit } 类似于_defer，panic也被组织成链表结构，多个panic通过link字段连接成一个链表。
在_panic结构体中，pc、sp、goexit三个字段是为了修复runtime.Goexit带来的问题引入的[1].
2. 调用panic 在函数中调用panic时，底层会调用runtime.gopanic，其源码如下：
func gopanic(e any) { gp := getg() // 获取当前g  // ."><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="runtime篇四：panic"><meta property="og:description" content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic  1. panic的底层结构 panic在runtime中的底层表示是runtime._panic结构体。
type _panic struct { argp unsafe.Pointer // 指向defer调用时参数的指针 	arg any // panic参数 	link *_panic // 连接到更早的_panic 	pc uintptr // 程序计数器 	sp unsafe.Pointer // 栈指针 	recovered bool // 当前panic是否被recover恢复 	aborted bool // 当前panic是否被中止 	goexit bool // 是否调用了runtime.Goexit } 类似于_defer，panic也被组织成链表结构，多个panic通过link字段连接成一个链表。
在_panic结构体中，pc、sp、goexit三个字段是为了修复runtime.Goexit带来的问题引入的[1].
2. 调用panic 在函数中调用panic时，底层会调用runtime.gopanic，其源码如下：
func gopanic(e any) { gp := getg() // 获取当前g  // ."><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-12T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-12T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="runtime篇四：panic"><meta name=twitter:description content="本系列代码基于golang1.19
  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic  1. panic的底层结构 panic在runtime中的底层表示是runtime._panic结构体。
type _panic struct { argp unsafe.Pointer // 指向defer调用时参数的指针 	arg any // panic参数 	link *_panic // 连接到更早的_panic 	pc uintptr // 程序计数器 	sp unsafe.Pointer // 栈指针 	recovered bool // 当前panic是否被recover恢复 	aborted bool // 当前panic是否被中止 	goexit bool // 是否调用了runtime.Goexit } 类似于_defer，panic也被组织成链表结构，多个panic通过link字段连接成一个链表。
在_panic结构体中，pc、sp、goexit三个字段是为了修复runtime.Goexit带来的问题引入的[1].
2. 调用panic 在函数中调用panic时，底层会调用runtime.gopanic，其源码如下：
func gopanic(e any) { gp := getg() // 获取当前g  // ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"runtime篇四：panic","item":"http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"runtime篇四：panic","name":"runtime篇四：panic","description":"本系列代码基于golang1.19\n  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic  1. panic的底层结构 panic在runtime中的底层表示是runtime._panic结构体。\ntype _panic struct { argp unsafe.Pointer // 指向defer调用时参数的指针 \targ any // panic参数 \tlink *_panic // 连接到更早的_panic \tpc uintptr // 程序计数器 \tsp unsafe.Pointer // 栈指针 \trecovered bool // 当前panic是否被recover恢复 \taborted bool // 当前panic是否被中止 \tgoexit bool // 是否调用了runtime.Goexit } 类似于_defer，panic也被组织成链表结构，多个panic通过link字段连接成一个链表。\n在_panic结构体中，pc、sp、goexit三个字段是为了修复runtime.Goexit带来的问题引入的[1].\n2. 调用panic 在函数中调用panic时，底层会调用runtime.gopanic，其源码如下：\nfunc gopanic(e any) { gp := getg() // 获取当前g  // .","keywords":["golang","runtime"],"articleBody":" 本系列代码基于golang1.19\n  runtime篇一：接口 runtime篇二：通道 runtime篇三：defer runtime篇四：panic  1. panic的底层结构 panic在runtime中的底层表示是runtime._panic结构体。\ntype _panic struct { argp unsafe.Pointer // 指向defer调用时参数的指针 \targ any // panic参数 \tlink *_panic // 连接到更早的_panic \tpc uintptr // 程序计数器 \tsp unsafe.Pointer // 栈指针 \trecovered bool // 当前panic是否被recover恢复 \taborted bool // 当前panic是否被中止 \tgoexit bool // 是否调用了runtime.Goexit } 类似于_defer，panic也被组织成链表结构，多个panic通过link字段连接成一个链表。\n在_panic结构体中，pc、sp、goexit三个字段是为了修复runtime.Goexit带来的问题引入的[1].\n2. 调用panic 在函数中调用panic时，底层会调用runtime.gopanic，其源码如下：\nfunc gopanic(e any) { gp := getg() // 获取当前g  // ...  // 此处省略部分代码  var p _panic p.arg = e // panic参数 \tp.link = gp._panic // 头插 \tgp._panic = (*_panic)(noescape(unsafe.Pointer(\u0026p))) // 省略defer调用部分  // ran out of deferred calls - old-school panic now \t// Because it is unsafe to call arbitrary user code after freezing \t// the world, we call preprintpanics to invoke all necessary Error \t// and String methods to prepare the panic strings before startpanic. \tpreprintpanics(gp._panic) fatalpanic(gp._panic) // should not return \t*(*int)(nil) = 0 // not reached } 先看panic主干流程，首先获取当前发生了panic的g，然后新建了一个_panic，将其字段赋值后，以头插的形式插入到g的_panic链表中，在函数的最后，调用了runtime.fatalpanic，这个函数实现了无法被恢复的程序崩溃：\nfunc fatalpanic(msgs *_panic) { pc := getcallerpc() sp := getcallersp() gp := getg() var docrash bool // Switch to the system stack to avoid any stack growth, which \t// may make things worse if the runtime is in a bad state.  // 切换到系统栈以避免用户栈增长 \tsystemstack(func() { // startpanic_m在应该打印panic信息时返回true \tif startpanic_m() \u0026\u0026 msgs != nil { // \tatomic.Xadd(\u0026runningPanicDefers, -1) printpanics(msgs) // 打印panic信息 \t} docrash = dopanic_m(gp, pc, sp) }) if docrash { crash() } systemstack(func() { exit(2) }) *(*int)(nil) = 0 // not reached } runtime.fatalpanic最后调用exit(2)终止程序，返回值为2.\n3. 在有defer调用时panic 上面介绍的情况是在函数运行时没有设置defer调用，然后直接panic，现在来看具有defer调用的函数发生panic时会怎样。\n回顾runtime篇三：defer我们知道，程序的defer调用以_defer链表的形式存储在g中。\n先大致看下源码:\nfunc gopanic(e any) { gp := getg() // 获取当前g  // 省略部分代码  var p _panic p.arg = e // panic参数 \tp.link = gp._panic // 头插 \tgp._panic = (*_panic)(noescape(unsafe.Pointer(\u0026p))) // 将当前这个panic赋值给当前defer  atomic.Xadd(\u0026runningPanicDefers, 1) // By calculating getcallerpc/getcallersp here, we avoid scanning the \t// gopanic frame (stack scanning is slow...) \taddOneOpenDeferFrame(gp, getcallerpc(), unsafe.Pointer(getcallersp())) // 这里添加了一个open-code defer  // 检查g中是否还存在defer调用 \tfor { d := gp._defer // 尝试获取_defer \tif d == nil { // 如果没有设置_defer，则直接跳出 \tbreak } // 如果defer被更早的panic或Goexit启动了（或者在程序到达这里之前，又触发了一个新的panic）， \t// 则将当前defer移出defer链表，先前的panic将不再执行，但确保先前的Goexit继续执行  if d.started { // defer已经被启动了 \tif d._panic != nil { // defer函数中也存在panic \td._panic.aborted = true // 终止defer的panic \t} d._panic = nil if !d.openDefer { // 未使用开放编码 \td.fn = nil gp._defer = d.link // 继续检查下一个defer \tfreedefer(d) continue } } // Mark defer as started, but keep on list, so that traceback \t// can find and update the defer's argument frame if stack growth \t// or a garbage collection happens before executing d.fn. \td.started = true // 将defer标记为启动  // Record the panic that is running the defer. \t// If there is a new panic during the deferred call, that panic \t// will find d in the list and will mark d._panic (this panic) aborted. \td._panic = (*_panic)(noescape(unsafe.Pointer(\u0026p))) // 将当前panic赋值給defer  done := true if d.openDefer { done = runOpenDeferFrame(gp, d) if done \u0026\u0026 !d._panic.recovered { addOneOpenDeferFrame(gp, 0, nil) } } else { p.argp = unsafe.Pointer(getargp()) d.fn() // 调用defer函数 \t} p.argp = nil // Deferred function did not panic. Remove d. \tif gp._defer != d { throw(\"bad defer entry in panic\") } d._panic = nil // trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic \t//GC()  pc := d.pc sp := unsafe.Pointer(d.sp) // must be pointer so it gets adjusted during stack copy \tif done { // 如果完成了defer函数 \td.fn = nil gp._defer = d.link freedefer(d) } if p.recovered { // 如果panic被recover，则继续执行下一个panic \t// 省略recover部分 \t} } preprintpanics(gp._panic) fatalpanic(gp._panic) // should not return \t*(*int)(nil) = 0 // not reached } 有点复杂，结合具体程序来看这段代码：\n1│ package main 2│ 3│ func main() { 4│ defer func() { 5│ panic(\"2\") 6│ }() 7│ panic(\"1\") 8│ } 对于这个程序，我们来分析它的运行过程，首先程序在运行到第4行时，会将这个defer放入g的_defer链表中，这个defer的fn字段指向func(){panic(\"2\")}。然后程序继续执行，来到第7行，在这里调用了runtime.gopanic函数。\n 新建了一个_panic结构体，并将其插入到g的_panic链表头部，这里称为panic1 在g上又新增了一个open-coded defer，现在g上有两个defer了，第一个为我们调用defer产生的（暂称为mydefer），第二个为open-coded defer，是runtime添加的(暂称openDefer) 当g上还有defer时，取出第一个defer，这里为mydefer  mydefer没有在运行 标记mydefer为运行状态，将panic1放入mydefer的_panic字段 检查mydefer不是open-coded defer，调用_defer.fn()     这里暂停一下，我们需要明确此时g中_defer和_panic的状态，在调用_defer.fn()之前，g中有两个defer，分别为mydefer、openDefer，且mydefer.link = openDefer：有一个panic，为panic1。且，mydefer._panic = panic1.\n 继续，这里调用的_defer.fn()为func(){panic(\"2\")}，在defer函数中再一次调用了panic，注意这里进行了栈帧的切换，当前的panic变成了panic2。这次调用panic的执行过程为：\n 新建一个新建了一个_panic结构体，并将其插入到g的_panic链表头部，这里称为panic2 这回不再增加新的open-coded defer 当g上还有defer时，取出第一个defer，这里为mydefer  mydefer在运行  mydefer._panic不为空，将其标记为aborted，即把panic1标记为aborted mydefer不是open-coded defer，将mydefer.fn设为空，将mydefer从g._defer链表中取出 重新检查g._defer中是否还存在defer       再次暂停，此时g上只剩下一个_defer：openDefer\n 继续：\n g上还有openDefer存在 openDefer不在运行，将其标记为运行，将panic2赋值到openDefer._panic上 执行openDefer 完成openDefer后，free it 检查是否有recover调用 调用fatalpanic使程序崩溃  分析完毕。\n4. recover 编译器在将关键字recover转换成runtime.gorecover:\nfunc gorecover(argp uintptr) any { gp := getg() p := gp._panic if p != nil \u0026\u0026 !p.goexit \u0026\u0026 !p.recovered \u0026\u0026 argp == uintptr(p.argp) { p.recovered = true return p.arg } return nil } 这个函数很简单，先是获取g，然后再获取g._panic的第一个元素，然后将其recovered标志设为true。\n让我们先结合具体程序来简单看下recover流程：\n1 │ package main 2 │ 3 │ func main() { 4 │ defer func() { 5 │ if r := recover(); r != nil { 6 │ println(r) 7 │ } 8 │ }() 9 │ panic(\"1\") 10│ } 首先程序会执行到第9行，然后一个panic1将会被添加到g._panic链表上；然后在runtime.gopanic中会添加一个openDefer, 然后调用defer.fn，会执行到recover，根据runtime.gorecover，会将g._panic的第一个元素取出，然后将其设置为可recover。\n现在，g中有了两个_defer（mydefer.link = openDefer），一个_panic（panic1），且mydefer被设置recovered = true。我们可以开始分析recover是怎么执行的了：\n而对recover的处理，还要来看runtime.gopanic:\n1 │func gopanic(e any) { 2 │ ... 3 │ for { 4 │ d := gp._defer // panic退出程序前，要执行defer 5 │ if d == nil { 6 │ break 7 │ } 8 │ 9 │ ... 10│ 11│ if p.recovered { // 如果panic被recover，则继续执行下一个panic 12│ gp._panic = p.link 13│ if gp._panic != nil \u0026\u0026 gp._panic.goexit \u0026\u0026 gp._panic.aborted { 14│ // A normal recover would bypass/abort the Goexit. Instead, 15│ // we return to the processing loop of the Goexit. 16│ gp.sigcode0 = uintptr(gp._panic.sp) 17│ gp.sigcode1 = uintptr(gp._panic.pc) 18│ mcall(recovery) 19│ throw(\"bypassed recovery failed\") // mcall should not return 20│ } 21│ atomic.Xadd(\u0026runningPanicDefers, -1) 22│ 23│ // After a recover, remove any remaining non-started, 24│ // open-coded defer entries, since the corresponding defers 25│ // will be executed normally (inline). Any such entry will 26│ // become stale once we run the corresponding defers inline 27│ // and exit the associated stack frame. We only remove up to 28│ // the first started (in-progress) open defer entry, not 29│ // including the current frame, since any higher entries will 30│ // be from a higher panic in progress, and will still be 31│ // needed. 32│ d := gp._defer 33│ var prev *_defer 34│ if !done { 35│ // Skip our current frame, if not done. It is 36│ // needed to complete any remaining defers in 37│ // deferreturn() 38│ prev = d 39│ d = d.link 40│ } 41│ for d != nil { // 这里去除了已经开始的open defer 42│ // 暂时省略 43│ } 44│ 45│ gp._panic = p.link 46│ // Aborted panics are marked but remain on the g.panic list. 47│ // Remove them from the list. 48│ for gp._panic != nil \u0026\u0026 gp._panic.aborted { 49│ gp._panic = gp._panic.link 50│ } 51│ if gp._panic == nil { // must be done with signal 52│ gp.sig = 0 53│ } 54│ // Pass information about recovering frame to recovery. 55│ gp.sigcode0 = uintptr(sp) 56│ gp.sigcode1 = pc 57│ mcall(recovery) 58│ throw(\"recovery failed\") // mcall should not return 59│ } 60│ } 61│ 62│ // ... 63│} 当程序开始进行recover时，首先在13行会做一个if判断。正常recover是会绕过Goexit的，所以为了解决这个，添加了这个判断，这样就可以保证Goexit也会被recover住，这里是通过从runtime._panic中取出了程序计数器pc和栈指针sp并且调用runtime.recovery函数触发goroutine的调度，调度之前会准备好 sp、pc 以及函数的返回值。\n对于我们的程序来说，并未调用Goexit，因此这里会跳过，然后在32～43行，由于done为true，这里d将会被赋值为mydefer，然后来到45行，将defer1从g._panic链表中取出，然后将余下的被标记为aborted的_panic删除，这里没有。\n55、56两行设置g的sigcode0、sigcode1指针，用于跳转，然后57行mcall(recovery)。\nmcall是一个汇编实现的函数，其函数原型为：func mcall(fn func(*g))，其主要功能是切换到g0的栈，然后调用fn(g)，fn(g)将不会返回，并且触发g的重新调度。\n这里的fn就是recovery，来看：\nfunc recovery(gp *g) { // Info about defer passed in G struct. \tsp := gp.sigcode0 pc := gp.sigcode1 // d's arguments need to be in the stack. \tif sp != 0 \u0026\u0026 (sp gp.stack.lo || gp.stack.hi sp) { print(\"recover: \", hex(sp), \" not in [\", hex(gp.stack.lo), \", \", hex(gp.stack.hi), \"]\\n\") throw(\"bad recovery\") } // Make the deferproc for this d return again, \t// this time returning 1. The calling function will \t// jump to the standard return epilogue. \tgp.sched.sp = sp gp.sched.pc = pc gp.sched.lr = 0 gp.sched.ret = 1 gogo(\u0026gp.sched) } 没什么特别的魔法，就是重新设置了g的一些指针，然后对其重新进行调度。\n这样就完成了panic的恢复。\n5. 场景分析 Q1 为什么recover必须放在defer里面 A1 不放到defer里面，没机会运行啊。。。\nQ2 为什么如下使用方法不会恢复：\nfunc main() { defer recover() panic(\"1\") } A2 在调用recover()函数时，会有如下if条件：\nif p != nil \u0026\u0026 !p.goexit \u0026\u0026 !p.recovered \u0026\u0026 argp == uintptr(p.argp) { p.recovered = true return p.arg } 这里p != nil \u0026\u0026 !p.goexit \u0026\u0026 !p.recovered会满足，而argp和uintptr(p.argp)并不相等，argp是runtime.gopinic报告的参数指针，p.argp是最顶层 defer 函数调用的参数指针，二者并不相等。\nQ3 下面这段代码将输出什么？为什么？\nfunc main() { defer func() { // topdefer \tfmt.Println(recover()) }() defer panic(3) // defer3 \tdefer panic(2) // defer2 \tdefer panic(1) // defer1 \tpanic(0) } A3 将输出3.\n分析：在runtime.gopanic中，有如下代码：\nif d.started { if d._panic != nil { d._panic.aborted = true } d._panic = nil if !d.openDefer { d.fn = nil gp._defer = d.link freedefer(d) continue } } 当我们执行到panic(0)后，将返回执行defer1，这时defer1被设置为started，panic(0)被设置为aborted，然后defer1被释放； 紧接着执行defer2，defer2被设置为started，panic(1)被设置为aborted，然后defer2被释放； 紧接着执行defer3，defer3被设置为started，panic(2)被设置为aborted，然后defer3被释放； 最后执行到topdefer，又因如下代码：\nfor gp._panic != nil \u0026\u0026 gp._panic.aborted { gp._panic = gp._panic.link } 被标记为aborted的panic将被忽略，因此只剩下了panic(3)。\n这样，最后输出的值就是3。\nQ4 为什么recover不能捕获不同goroutine的panic A4 查看runtime.gorecover源码：\nfunc gorecover(argp uintptr) any { gp := getg() p := gp._panic if p != nil \u0026\u0026 !p.goexit \u0026\u0026 !p.recovered \u0026\u0026 argp == uintptr(p.argp) { p.recovered = true return p.arg } return nil } 这个函数获取了当前的g，并为其第一个_panic设置recover，跟其他g没有关系\nQ5 为什么子goroutine的panic不被recover会造成整个程序的崩溃 A5 查看runtime.fatalpanic:\nfunc fatalpanic(msgs *_panic) { // ...  systemstack(func() { exit(2) }) *(*int)(nil) = 0 // not reached } 其在执行exit(2)时，是在systemstack上执行的，因此整个程序都会退出。\nEND\nReferences https://gfw.go101.org/article/panic-and-recover-more.html\nhttps://golang.design/under-the-hood/zh-cn/part1basic/ch03lang/panic/\nhttps://www.purewhite.io/2019/11/28/runtime-hacking-translate/\nhttps://zhuanlan.zhihu.com/p/346514343\nhttps://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/\nhttps://xiaomi-info.github.io/2020/01/20/go-trample-panic-recover/\n","wordCount":"1315","inLanguage":"en","datePublished":"2022-08-12T00:00:00Z","dateModified":"2022-08-12T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>runtime篇四：panic</h1><div class=post-meta><span title="2022-08-12 00:00:00 +0000 UTC">August 12, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-panic%e7%9a%84%e5%ba%95%e5%b1%82%e7%bb%93%e6%9e%84 aria-label="1. panic的底层结构">1. panic的底层结构</a></li><li><a href=#2-%e8%b0%83%e7%94%a8panic aria-label="2. 调用panic">2. 调用panic</a></li><li><a href=#3-%e5%9c%a8%e6%9c%89defer%e8%b0%83%e7%94%a8%e6%97%b6panic aria-label="3. 在有defer调用时panic">3. 在有defer调用时panic</a></li><li><a href=#4-recover aria-label="4. recover">4. recover</a></li><li><a href=#5-%e5%9c%ba%e6%99%af%e5%88%86%e6%9e%90 aria-label="5. 场景分析">5. 场景分析</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><blockquote><p>本系列代码基于<a href=https://github.com/golang/go/tree/1e5987635cc8bf99e8a20d240da80bd6f0f793f7>golang1.19</a></p></blockquote><ul><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%80%E6%8E%A5%E5%8F%A3/>runtime篇一：接口</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%BA%8C%E9%80%9A%E9%81%93/>runtime篇二：通道</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/>runtime篇三：defer</a></li><li><a href=https://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E5%9B%9Bpanic/>runtime篇四：panic</a></li></ul><h2 id=1-panic的底层结构>1. panic的底层结构<a hidden class=anchor aria-hidden=true href=#1-panic的底层结构>#</a></h2><p>panic在runtime中的底层表示是<code>runtime._panic</code>结构体。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_panic</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#a6e22e>argp</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 指向defer调用时参数的指针
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>arg</span>       <span style=color:#a6e22e>any</span>            <span style=color:#75715e>// panic参数
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>link</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>        <span style=color:#75715e>// 连接到更早的_panic
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>pc</span>        <span style=color:#66d9ef>uintptr</span>        <span style=color:#75715e>// 程序计数器
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sp</span>        <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 栈指针
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>recovered</span> <span style=color:#66d9ef>bool</span>           <span style=color:#75715e>// 当前panic是否被recover恢复
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>aborted</span>   <span style=color:#66d9ef>bool</span>           <span style=color:#75715e>// 当前panic是否被中止
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>goexit</span>    <span style=color:#66d9ef>bool</span>           <span style=color:#75715e>// 是否调用了runtime.Goexit
</span><span style=color:#75715e></span>}
</code></pre></div><p>类似于<code>_defer</code>，panic也被组织成链表结构，多个panic通过<code>link</code>字段连接成一个链表。</p><p>在<code>_panic</code>结构体中，pc、sp、goexit三个字段是为了修复<code>runtime.Goexit</code>带来的问题引入的<a href=https://github.com/golang/go/commit/7dcd343ed641d3b70c09153d3b041ca3fe83b25e>[1]</a>.</p><h2 id=2-调用panic>2. 调用panic<a hidden class=anchor aria-hidden=true href=#2-调用panic>#</a></h2><p>在函数中调用panic时，底层会调用<code>runtime.gopanic</code>，其源码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopanic</span>(<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>any</span>) {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()         <span style=color:#75715e>// 获取当前g
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 此处省略部分代码
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>_panic</span>
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>arg</span> = <span style=color:#a6e22e>e</span>          <span style=color:#75715e>// panic参数
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>link</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#75715e>// 头插
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>)(<span style=color:#a6e22e>noescape</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>)))

	<span style=color:#75715e>// 省略defer调用部分
</span><span style=color:#75715e></span>
	<span style=color:#75715e>// ran out of deferred calls - old-school panic now
</span><span style=color:#75715e></span>	<span style=color:#75715e>// Because it is unsafe to call arbitrary user code after freezing
</span><span style=color:#75715e></span>	<span style=color:#75715e>// the world, we call preprintpanics to invoke all necessary Error
</span><span style=color:#75715e></span>	<span style=color:#75715e>// and String methods to prepare the panic strings before startpanic.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>preprintpanics</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>)

	<span style=color:#a6e22e>fatalpanic</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>) <span style=color:#75715e>// should not return
</span><span style=color:#75715e></span>	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#66d9ef>nil</span>) = <span style=color:#ae81ff>0</span>      <span style=color:#75715e>// not reached
</span><span style=color:#75715e></span>}
</code></pre></div><p>先看panic主干流程，首先获取当前发生了panic的<code>g</code>，然后新建了一个<code>_panic</code>，将其字段赋值后，以头插的形式插入到<code>g</code>的<code>_panic</code>链表中，在函数的最后，调用了<code>runtime.fatalpanic</code>，这个函数实现了无法被恢复的程序崩溃：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fatalpanic</span>(<span style=color:#a6e22e>msgs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>) {
	<span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallersp</span>()
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>docrash</span> <span style=color:#66d9ef>bool</span>
	<span style=color:#75715e>// Switch to the system stack to avoid any stack growth, which
</span><span style=color:#75715e></span>	<span style=color:#75715e>// may make things worse if the runtime is in a bad state.
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 切换到系统栈以避免用户栈增长
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
        <span style=color:#75715e>// startpanic_m在应该打印panic信息时返回true
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>startpanic_m</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>msgs</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>runningPanicDefers</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)

			<span style=color:#a6e22e>printpanics</span>(<span style=color:#a6e22e>msgs</span>) <span style=color:#75715e>// 打印panic信息
</span><span style=color:#75715e></span>		}

		<span style=color:#a6e22e>docrash</span> = <span style=color:#a6e22e>dopanic_m</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>)
	})

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>docrash</span> {
		<span style=color:#a6e22e>crash</span>()
	}

	<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
		<span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>2</span>)
	})

	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#66d9ef>nil</span>) = <span style=color:#ae81ff>0</span> <span style=color:#75715e>// not reached
</span><span style=color:#75715e></span>}
</code></pre></div><p><code>runtime.fatalpanic</code>最后调用<code>exit(2)</code>终止程序，返回值为2.</p><h2 id=3-在有defer调用时panic>3. 在有defer调用时panic<a hidden class=anchor aria-hidden=true href=#3-在有defer调用时panic>#</a></h2><p>上面介绍的情况是在函数运行时没有设置defer调用，然后直接panic，现在来看具有defer调用的函数发生panic时会怎样。</p><p>回顾<a href>runtime篇三：defer</a>我们知道，程序的defer调用以<code>_defer</code>链表的形式存储在<code>g</code>中。</p><p>先大致看下源码:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopanic</span>(<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>any</span>) {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()         <span style=color:#75715e>// 获取当前g
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 省略部分代码
</span><span style=color:#75715e></span>
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>_panic</span>
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>arg</span> = <span style=color:#a6e22e>e</span>          <span style=color:#75715e>// panic参数
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>link</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#75715e>// 头插
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>)(<span style=color:#a6e22e>noescape</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>))) <span style=color:#75715e>// 将当前这个panic赋值给当前defer
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>runningPanicDefers</span>, <span style=color:#ae81ff>1</span>)

	<span style=color:#75715e>// By calculating getcallerpc/getcallersp here, we avoid scanning the
</span><span style=color:#75715e></span>	<span style=color:#75715e>// gopanic frame (stack scanning is slow...)
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>addOneOpenDeferFrame</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>getcallerpc</span>(), <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>getcallersp</span>())) <span style=color:#75715e>// 这里添加了一个open-code defer
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// 检查g中是否还存在defer调用
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> {
		<span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// 尝试获取_defer
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 如果没有设置_defer，则直接跳出
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>break</span>
		}

        <span style=color:#75715e>// 如果defer被更早的panic或Goexit启动了（或者在程序到达这里之前，又触发了一个新的panic），
</span><span style=color:#75715e></span>		<span style=color:#75715e>// 则将当前defer移出defer链表，先前的panic将不再执行，但确保先前的Goexit继续执行
</span><span style=color:#75715e></span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>started</span> { <span style=color:#75715e>// defer已经被启动了
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// defer函数中也存在panic
</span><span style=color:#75715e></span>				<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>aborted</span> = <span style=color:#66d9ef>true</span> <span style=color:#75715e>// 终止defer的panic
</span><span style=color:#75715e></span>			}
			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>openDefer</span> { <span style=color:#75715e>// 未使用开放编码
</span><span style=color:#75715e></span>				<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#66d9ef>nil</span>
				<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span> <span style=color:#75715e>// 继续检查下一个defer
</span><span style=color:#75715e></span>				<span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span>)
				<span style=color:#66d9ef>continue</span>
			}
		}
		<span style=color:#75715e>// Mark defer as started, but keep on list, so that traceback
</span><span style=color:#75715e></span>		<span style=color:#75715e>// can find and update the defer&#39;s argument frame if stack growth
</span><span style=color:#75715e></span>		<span style=color:#75715e>// or a garbage collection happens before executing d.fn.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>started</span> = <span style=color:#66d9ef>true</span> <span style=color:#75715e>// 将defer标记为启动
</span><span style=color:#75715e></span>
		<span style=color:#75715e>// Record the panic that is running the defer.
</span><span style=color:#75715e></span>		<span style=color:#75715e>// If there is a new panic during the deferred call, that panic
</span><span style=color:#75715e></span>		<span style=color:#75715e>// will find d in the list and will mark d._panic (this panic) aborted.
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>)(<span style=color:#a6e22e>noescape</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>))) <span style=color:#75715e>// 将当前panic赋值給defer
</span><span style=color:#75715e></span>
		<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>true</span>
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>openDefer</span> {
			<span style=color:#a6e22e>done</span> = <span style=color:#a6e22e>runOpenDeferFrame</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>d</span>)
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>done</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>recovered</span> {
				<span style=color:#a6e22e>addOneOpenDeferFrame</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>nil</span>)
			}
		} <span style=color:#66d9ef>else</span> {
			<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>argp</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>getargp</span>())
			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span>() <span style=color:#75715e>// 调用defer函数
</span><span style=color:#75715e></span>		}
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>argp</span> = <span style=color:#66d9ef>nil</span>

		<span style=color:#75715e>// Deferred function did not panic. Remove d.
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>d</span> {
			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;bad defer entry in panic&#34;</span>)
		}
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#66d9ef>nil</span>

		<span style=color:#75715e>// trigger shrinkage to test stack copy. See stack_test.go:TestStackPanic
</span><span style=color:#75715e></span>		<span style=color:#75715e>//GC()
</span><span style=color:#75715e></span>
		<span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>pc</span>
		<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>sp</span>) <span style=color:#75715e>// must be pointer so it gets adjusted during stack copy
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>done</span> { <span style=color:#75715e>// 如果完成了defer函数
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#66d9ef>nil</span>
			<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>
			<span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span>)
		}
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> { <span style=color:#75715e>// 如果panic被recover，则继续执行下一个panic
</span><span style=color:#75715e></span>			<span style=color:#75715e>// 省略recover部分
</span><span style=color:#75715e></span>		}
	}

	<span style=color:#a6e22e>preprintpanics</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>)

	<span style=color:#a6e22e>fatalpanic</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>) <span style=color:#75715e>// should not return
</span><span style=color:#75715e></span>	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#66d9ef>nil</span>) = <span style=color:#ae81ff>0</span>      <span style=color:#75715e>// not reached
</span><span style=color:#75715e></span>}
</code></pre></div><p>有点复杂，结合具体程序来看这段代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>│</span> <span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style=color:#ae81ff>2</span><span style=color:#960050;background-color:#1e0010>│</span>
<span style=color:#ae81ff>3</span><span style=color:#960050;background-color:#1e0010>│</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style=color:#ae81ff>4</span><span style=color:#960050;background-color:#1e0010>│</span>     <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
<span style=color:#ae81ff>5</span><span style=color:#960050;background-color:#1e0010>│</span>         panic(<span style=color:#e6db74>&#34;2&#34;</span>)
<span style=color:#ae81ff>6</span><span style=color:#960050;background-color:#1e0010>│</span>     }()
<span style=color:#ae81ff>7</span><span style=color:#960050;background-color:#1e0010>│</span>     panic(<span style=color:#e6db74>&#34;1&#34;</span>)
<span style=color:#ae81ff>8</span><span style=color:#960050;background-color:#1e0010>│</span> }
</code></pre></div><p>对于这个程序，我们来分析它的运行过程，首先程序在运行到第4行时，会将这个defer放入<code>g</code>的<code>_defer</code>链表中，这个defer的fn字段指向<code>func(){panic("2")}</code>。然后程序继续执行，来到第7行，在这里调用了<code>runtime.gopanic</code>函数。</p><ol><li>新建了一个<code>_panic</code>结构体，并将其插入到<code>g</code>的<code>_panic</code>链表头部，这里称为<code>panic1</code></li><li>在<code>g</code>上又新增了一个open-coded defer，现在<code>g</code>上有两个defer了，第一个为我们调用defer产生的（暂称为<code>mydefer</code>），第二个为open-coded defer，是runtime添加的(暂称<code>openDefer</code>)</li><li>当<code>g</code>上还有defer时，取出第一个defer，这里为<code>mydefer</code><ol><li><code>mydefer</code>没有在运行</li><li>标记<code>mydefer</code>为运行状态，将<code>panic1</code>放入<code>mydefer</code>的_panic字段</li><li>检查<code>mydefer</code>不是open-coded defer，调用<code>_defer.fn()</code></li></ol></li></ol><blockquote><p>这里暂停一下，我们需要明确此时<code>g</code>中<code>_defer</code>和<code>_panic</code>的状态，在调用<code>_defer.fn()</code>之前，<code>g</code>中有两个defer，分别为<code>mydefer</code>、<code>openDefer</code>，且<code>mydefer.link = openDefer</code>：有一个panic，为<code>panic1</code>。且，<code>mydefer._panic = panic1</code>.</p></blockquote><p>继续，这里调用的<code>_defer.fn()</code>为<code>func(){panic("2")}</code>，在defer函数中再一次调用了panic，注意这里进行了栈帧的切换，当前的panic变成了<code>panic2</code>。这次调用panic的执行过程为：</p><ol><li>新建一个新建了一个<code>_panic</code>结构体，并将其插入到<code>g</code>的<code>_panic</code>链表头部，这里称为<code>panic2</code></li><li>这回不再增加新的open-coded defer</li><li>当<code>g</code>上还有defer时，取出第一个defer，这里为<code>mydefer</code><ol><li><code>mydefer</code>在运行<ol><li><code>mydefer._panic</code>不为空，将其标记为aborted，即把<code>panic1</code>标记为aborted</li><li><code>mydefer</code>不是open-coded defer，将<code>mydefer.fn</code>设为空，将<code>mydefer</code>从<code>g._defer</code>链表中取出</li><li>重新检查<code>g._defer</code>中是否还存在defer</li></ol></li></ol></li></ol><blockquote><p>再次暂停，此时<code>g</code>上只剩下一个<code>_defer</code>：<code>openDefer</code></p></blockquote><p>继续：</p><ol><li><code>g</code>上还有<code>openDefer</code>存在</li><li><code>openDefer</code>不在运行，将其标记为运行，将<code>panic2</code>赋值到<code>openDefer._panic</code>上</li><li>执行<code>openDefer</code></li><li>完成<code>openDefer</code>后，free it</li><li>检查是否有recover调用</li><li>调用fatalpanic使程序崩溃</li></ol><p>分析完毕。</p><h2 id=4-recover>4. recover<a hidden class=anchor aria-hidden=true href=#4-recover>#</a></h2><p>编译器在将关键字<code>recover</code>转换成<code>runtime.gorecover</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gorecover</span>(<span style=color:#a6e22e>argp</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#a6e22e>any</span> {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>goexit</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>argp</span> <span style=color:#f92672>==</span> uintptr(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>argp</span>) {
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> = <span style=color:#66d9ef>true</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>arg</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>这个函数很简单，先是获取<code>g</code>，然后再获取<code>g._panic</code>的第一个元素，然后将其<code>recovered</code>标志设为true。</p><p>让我们先结合具体程序来简单看下recover流程：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ae81ff>1</span> <span style=color:#960050;background-color:#1e0010>│</span> <span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style=color:#ae81ff>2</span> <span style=color:#960050;background-color:#1e0010>│</span>
<span style=color:#ae81ff>3</span> <span style=color:#960050;background-color:#1e0010>│</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
<span style=color:#ae81ff>4</span> <span style=color:#960050;background-color:#1e0010>│</span>     <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
<span style=color:#ae81ff>5</span> <span style=color:#960050;background-color:#1e0010>│</span>         <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> recover(); <span style=color:#a6e22e>r</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
<span style=color:#ae81ff>6</span> <span style=color:#960050;background-color:#1e0010>│</span>             println(<span style=color:#a6e22e>r</span>)
<span style=color:#ae81ff>7</span> <span style=color:#960050;background-color:#1e0010>│</span>         }
<span style=color:#ae81ff>8</span> <span style=color:#960050;background-color:#1e0010>│</span>     }()
<span style=color:#ae81ff>9</span> <span style=color:#960050;background-color:#1e0010>│</span>     panic(<span style=color:#e6db74>&#34;1&#34;</span>)
<span style=color:#ae81ff>10</span><span style=color:#960050;background-color:#1e0010>│</span> }
</code></pre></div><p>首先程序会执行到第9行，然后一个<code>panic1</code>将会被添加到<code>g._panic</code>链表上；然后在<code>runtime.gopanic</code>中会添加一个<code>openDefer</code>, 然后调用defer.fn，会执行到recover，根据<code>runtime.gorecover</code>，会将<code>g._panic</code>的第一个元素取出，然后将其设置为可recover。</p><p>现在，<code>g</code>中有了两个<code>_defer</code>（<code>mydefer.link = openDefer</code>），一个<code>_panic</code>（<code>panic1</code>），且<code>mydefer</code>被设置<code>recovered = true</code>。我们可以开始分析recover是怎么执行的了：</p><p>而对recover的处理，还要来看<code>runtime.gopanic</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ae81ff>1</span> <span style=color:#960050;background-color:#1e0010>│</span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopanic</span>(<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>any</span>) {
<span style=color:#ae81ff>2</span> <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#f92672>...</span>
<span style=color:#ae81ff>3</span> <span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#66d9ef>for</span> {
<span style=color:#ae81ff>4</span> <span style=color:#960050;background-color:#1e0010>│</span>        <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> <span style=color:#75715e>// panic退出程序前，要执行defer
</span><span style=color:#75715e></span><span style=color:#ae81ff>5</span> <span style=color:#960050;background-color:#1e0010>│</span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
<span style=color:#ae81ff>6</span> <span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#66d9ef>break</span>
<span style=color:#ae81ff>7</span> <span style=color:#960050;background-color:#1e0010>│</span>        }
<span style=color:#ae81ff>8</span> <span style=color:#960050;background-color:#1e0010>│</span>
<span style=color:#ae81ff>9</span> <span style=color:#960050;background-color:#1e0010>│</span>        <span style=color:#f92672>...</span>
<span style=color:#ae81ff>10</span><span style=color:#960050;background-color:#1e0010>│</span>
<span style=color:#ae81ff>11</span><span style=color:#960050;background-color:#1e0010>│</span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> { <span style=color:#75715e>// 如果panic被recover，则继续执行下一个panic
</span><span style=color:#75715e></span><span style=color:#ae81ff>12</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>link</span>
<span style=color:#ae81ff>13</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>goexit</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>aborted</span> {
<span style=color:#ae81ff>14</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#75715e>// A normal recover would bypass/abort the Goexit.  Instead,
</span><span style=color:#75715e></span><span style=color:#ae81ff>15</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#75715e>// we return to the processing loop of the Goexit.
</span><span style=color:#75715e></span><span style=color:#ae81ff>16</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode0</span> = uintptr(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>sp</span>)
<span style=color:#ae81ff>17</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode1</span> = uintptr(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>pc</span>)
<span style=color:#ae81ff>18</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>recovery</span>)
<span style=color:#ae81ff>19</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;bypassed recovery failed&#34;</span>) <span style=color:#75715e>// mcall should not return
</span><span style=color:#75715e></span><span style=color:#ae81ff>20</span><span style=color:#960050;background-color:#1e0010>│</span>            }
<span style=color:#ae81ff>21</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Xadd</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>runningPanicDefers</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
<span style=color:#ae81ff>22</span><span style=color:#960050;background-color:#1e0010>│</span>
<span style=color:#ae81ff>23</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// After a recover, remove any remaining non-started,
</span><span style=color:#75715e></span><span style=color:#ae81ff>24</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// open-coded defer entries, since the corresponding defers
</span><span style=color:#75715e></span><span style=color:#ae81ff>25</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// will be executed normally (inline). Any such entry will
</span><span style=color:#75715e></span><span style=color:#ae81ff>26</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// become stale once we run the corresponding defers inline
</span><span style=color:#75715e></span><span style=color:#ae81ff>27</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// and exit the associated stack frame. We only remove up to
</span><span style=color:#75715e></span><span style=color:#ae81ff>28</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// the first started (in-progress) open defer entry, not
</span><span style=color:#75715e></span><span style=color:#ae81ff>29</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// including the current frame, since any higher entries will
</span><span style=color:#75715e></span><span style=color:#ae81ff>30</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// be from a higher panic in progress, and will still be
</span><span style=color:#75715e></span><span style=color:#ae81ff>31</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// needed.
</span><span style=color:#75715e></span><span style=color:#ae81ff>32</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span>
<span style=color:#ae81ff>33</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>prev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_defer</span>
<span style=color:#ae81ff>34</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>done</span> {
<span style=color:#ae81ff>35</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#75715e>// Skip our current frame, if not done. It is
</span><span style=color:#75715e></span><span style=color:#ae81ff>36</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#75715e>// needed to complete any remaining defers in
</span><span style=color:#75715e></span><span style=color:#ae81ff>37</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#75715e>// deferreturn()
</span><span style=color:#75715e></span><span style=color:#ae81ff>38</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>d</span>
<span style=color:#ae81ff>39</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#a6e22e>d</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>
<span style=color:#ae81ff>40</span><span style=color:#960050;background-color:#1e0010>│</span>            }
<span style=color:#ae81ff>41</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// 这里去除了已经开始的open defer
</span><span style=color:#75715e></span><span style=color:#ae81ff>42</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#75715e>// 暂时省略
</span><span style=color:#75715e></span><span style=color:#ae81ff>43</span><span style=color:#960050;background-color:#1e0010>│</span>            }
<span style=color:#ae81ff>44</span><span style=color:#960050;background-color:#1e0010>│</span>
<span style=color:#ae81ff>45</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>link</span>
<span style=color:#ae81ff>46</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// Aborted panics are marked but remain on the g.panic list.
</span><span style=color:#75715e></span><span style=color:#ae81ff>47</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// Remove them from the list.
</span><span style=color:#75715e></span><span style=color:#ae81ff>48</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>aborted</span> {
<span style=color:#ae81ff>49</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>link</span>
<span style=color:#ae81ff>50</span><span style=color:#960050;background-color:#1e0010>│</span>            }
<span style=color:#ae81ff>51</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> { <span style=color:#75715e>// must be done with signal
</span><span style=color:#75715e></span><span style=color:#ae81ff>52</span><span style=color:#960050;background-color:#1e0010>│</span>                <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sig</span> = <span style=color:#ae81ff>0</span>
<span style=color:#ae81ff>53</span><span style=color:#960050;background-color:#1e0010>│</span>            }
<span style=color:#ae81ff>54</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#75715e>// Pass information about recovering frame to recovery.
</span><span style=color:#75715e></span><span style=color:#ae81ff>55</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode0</span> = uintptr(<span style=color:#a6e22e>sp</span>)
<span style=color:#ae81ff>56</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode1</span> = <span style=color:#a6e22e>pc</span>
<span style=color:#ae81ff>57</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>recovery</span>)
<span style=color:#ae81ff>58</span><span style=color:#960050;background-color:#1e0010>│</span>            <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;recovery failed&#34;</span>) <span style=color:#75715e>// mcall should not return
</span><span style=color:#75715e></span><span style=color:#ae81ff>59</span><span style=color:#960050;background-color:#1e0010>│</span>        }
<span style=color:#ae81ff>60</span><span style=color:#960050;background-color:#1e0010>│</span>    }
<span style=color:#ae81ff>61</span><span style=color:#960050;background-color:#1e0010>│</span>
<span style=color:#ae81ff>62</span><span style=color:#960050;background-color:#1e0010>│</span>    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#ae81ff>63</span><span style=color:#960050;background-color:#1e0010>│</span>}
</code></pre></div><p>当程序开始进行recover时，首先在13行会做一个if判断。正常recover是会绕过Goexit的，所以为了解决这个，添加了这个判断，这样就可以保证Goexit也会被recover住，这里是通过从runtime._panic中取出了程序计数器pc和栈指针sp并且调用runtime.recovery函数触发goroutine的调度，调度之前会准备好 sp、pc 以及函数的返回值。</p><p>对于我们的程序来说，并未调用Goexit，因此这里会跳过，然后在32～43行，由于<code>done</code>为true，这里d将会被赋值为<code>mydefer</code>，然后来到45行，将<code>defer1</code>从<code>g._panic</code>链表中取出，然后将余下的被标记为aborted的<code>_panic</code>删除，这里没有。</p><p>55、56两行设置<code>g</code>的<code>sigcode0</code>、<code>sigcode1</code>指针，用于跳转，然后57行<code>mcall(recovery)</code>。</p><p><code>mcall</code>是一个汇编实现的函数，其函数原型为：<code>func mcall(fn func(*g))</code>，其主要功能是切换到<code>g0</code>的栈，然后调用<code>fn(g)</code>，<code>fn(g)</code>将不会返回，并且触发<code>g</code>的重新调度。</p><p>这里的<code>fn</code>就是<code>recovery</code>，来看：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>recovery</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
	<span style=color:#75715e>// Info about defer passed in G struct.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>sp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode0</span>
	<span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sigcode1</span>

	<span style=color:#75715e>// d&#39;s arguments need to be in the stack.
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sp</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>sp</span> &lt; <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span> &lt; <span style=color:#a6e22e>sp</span>) {
		print(<span style=color:#e6db74>&#34;recover: &#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>sp</span>), <span style=color:#e6db74>&#34; not in [&#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>lo</span>), <span style=color:#e6db74>&#34;, &#34;</span>, <span style=color:#a6e22e>hex</span>(<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>hi</span>), <span style=color:#e6db74>&#34;]\n&#34;</span>)
		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;bad recovery&#34;</span>)
	}

	<span style=color:#75715e>// Make the deferproc for this d return again,
</span><span style=color:#75715e></span>	<span style=color:#75715e>// this time returning 1. The calling function will
</span><span style=color:#75715e></span>	<span style=color:#75715e>// jump to the standard return epilogue.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>sp</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>pc</span> = <span style=color:#a6e22e>pc</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lr</span> = <span style=color:#ae81ff>0</span>
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>ret</span> = <span style=color:#ae81ff>1</span>
	<span style=color:#a6e22e>gogo</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>)
}
</code></pre></div><p>没什么特别的魔法，就是重新设置了<code>g</code>的一些指针，然后对其重新进行调度。</p><p>这样就完成了panic的恢复。</p><h2 id=5-场景分析>5. 场景分析<a hidden class=anchor aria-hidden=true href=#5-场景分析>#</a></h2><p><strong>Q1</strong> 为什么recover必须放在defer里面
<strong>A1</strong> 不放到defer里面，没机会运行啊。。。</p><p><strong>Q2</strong> 为什么如下使用方法不会恢复：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>defer</span> recover()
	panic(<span style=color:#e6db74>&#34;1&#34;</span>)
}
</code></pre></div><p><strong>A2</strong> 在调用recover()函数时，会有如下if条件：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>goexit</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>argp</span> <span style=color:#f92672>==</span> uintptr(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>argp</span>) {
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> = <span style=color:#66d9ef>true</span>
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>arg</span>
}
</code></pre></div><p>这里<code>p != nil && !p.goexit && !p.recovered</code>会满足，而<code>argp</code>和<code>uintptr(p.argp)</code>并不相等，<code>argp</code>是<code>runtime.gopinic</code>报告的参数指针，<code>p.argp</code>是最顶层 defer 函数调用的参数指针，二者并不相等。</p><p><strong>Q3</strong> 下面这段代码将输出什么？为什么？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() { <span style=color:#75715e>// topdefer
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(recover())
	}()

	<span style=color:#66d9ef>defer</span> panic(<span style=color:#ae81ff>3</span>) <span style=color:#75715e>// defer3
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>defer</span> panic(<span style=color:#ae81ff>2</span>) <span style=color:#75715e>// defer2
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>defer</span> panic(<span style=color:#ae81ff>1</span>) <span style=color:#75715e>// defer1
</span><span style=color:#75715e></span>	panic(<span style=color:#ae81ff>0</span>)
}
</code></pre></div><p><strong>A3</strong> 将输出3.</p><p>分析：在<code>runtime.gopanic</code>中，有如下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>started</span> {
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>aborted</span> = <span style=color:#66d9ef>true</span>
	}
	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#66d9ef>nil</span>
	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>openDefer</span> {
		<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>fn</span> = <span style=color:#66d9ef>nil</span>
		<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_defer</span> = <span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>link</span>
		<span style=color:#a6e22e>freedefer</span>(<span style=color:#a6e22e>d</span>)
		<span style=color:#66d9ef>continue</span>
	}
}
</code></pre></div><p>当我们执行到<code>panic(0)</code>后，将返回执行<code>defer1</code>，这时<code>defer1</code>被设置为<code>started</code>，<code>panic(0)</code>被设置为<code>aborted</code>，然后<code>defer1</code>被释放；
紧接着执行<code>defer2</code>，<code>defer2</code>被设置为<code>started</code>，<code>panic(1)</code>被设置为<code>aborted</code>，然后<code>defer2</code>被释放；
紧接着执行<code>defer3</code>，<code>defer3</code>被设置为<code>started</code>，<code>panic(2)</code>被设置为<code>aborted</code>，然后<code>defer3</code>被释放；
最后执行到<code>topdefer</code>，又因如下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>aborted</span> {
	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>.<span style=color:#a6e22e>link</span>
}
</code></pre></div><p>被标记为<code>aborted</code>的panic将被忽略，因此只剩下了<code>panic(3)</code>。</p><p>这样，最后输出的值就是3。</p><p><strong>Q4</strong> 为什么recover不能捕获不同goroutine的panic
<strong>A4</strong> 查看<code>runtime.gorecover</code>源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gorecover</span>(<span style=color:#a6e22e>argp</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#a6e22e>any</span> {
	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>_panic</span>
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>goexit</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>argp</span> <span style=color:#f92672>==</span> uintptr(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>argp</span>) {
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>recovered</span> = <span style=color:#66d9ef>true</span>
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>arg</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>这个函数获取了当前的<code>g</code>，并为其第一个<code>_panic</code>设置recover，跟其他<code>g</code>没有关系</p><p><strong>Q5</strong> 为什么子goroutine的panic不被recover会造成整个程序的崩溃
<strong>A5</strong> 查看<code>runtime.fatalpanic</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fatalpanic</span>(<span style=color:#a6e22e>msgs</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_panic</span>) {
	<span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
		<span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>2</span>)
	})

	<span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>)(<span style=color:#66d9ef>nil</span>) = <span style=color:#ae81ff>0</span> <span style=color:#75715e>// not reached
</span><span style=color:#75715e></span>}
</code></pre></div><p>其在执行<code>exit(2)</code>时，是在<code>systemstack</code>上执行的，因此整个程序都会退出。</p><p>END</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://gfw.go101.org/article/panic-and-recover-more.html>https://gfw.go101.org/article/panic-and-recover-more.html</a></p><p><a href=https://golang.design/under-the-hood/zh-cn/part1basic/ch03lang/panic/>https://golang.design/under-the-hood/zh-cn/part1basic/ch03lang/panic/</a></p><p><a href=https://www.purewhite.io/2019/11/28/runtime-hacking-translate/>https://www.purewhite.io/2019/11/28/runtime-hacking-translate/</a></p><p><a href=https://zhuanlan.zhihu.com/p/346514343>https://zhuanlan.zhihu.com/p/346514343</a></p><p><a href=https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/>https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</a></p><p><a href=https://xiaomi-info.github.io/2020/01/20/go-trample-panic-recover/>https://xiaomi-info.github.io/2020/01/20/go-trample-panic-recover/</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/golang/>golang</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/runtime/>runtime</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/golang/runtime%E7%AF%87%E4%B8%89defer/><span class=title>« Prev Page</span><br><span>runtime篇三：defer</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/linux/top%E5%91%BD%E4%BB%A4/><span class=title>Next Page »</span><br><span>top命令</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>