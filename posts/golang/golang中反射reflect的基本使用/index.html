<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang中反射reflect的基本使用 | Linote</title><meta name=keywords content="reflect,language,golang"><meta name=description content="在计算机领域，反射是指一类应用，它们能够自描述和自控制。也即是说，这类应用通过采用某种机制来实现对自己行为的描述和监测，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射（reflect）让我们能在运行期探知对象的类型信息和内存结构，这从一定程度上弥(mi)补了静态语言在动态行为上的不足。 反射（reflect）是在计算机程序运行时，访问，检查，修改它自身的一种能力，是元编程的一种形式。 Go语音提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，但是在编译时并不知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。
 1. 为何我们需要反射？ fmt.Fprintf函数提供字符串格式化处理逻辑，它可以对任意类型的值格式化并打印，甚至支持用户自定义的类型。 让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。 这里我们使用switch类型分支来对不同的类型进行处理。
func Sprint(x interface{}) string { type stringer interface { String() string } switch x := x.(type) { case stringer: return x.String() case string: return x case int: return strconv.Itoa(x) // ...similar cases for int16, uint32, and so on...  case bool: if x { return &#34;true&#34; } return &#34;false&#34; default: // array, chan, func, map, pointer, slice, struct  return &#34;?"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/posts/golang/golang%E4%B8%AD%E5%8F%8D%E5%B0%84reflect%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Golang中反射reflect的基本使用"><meta property="og:description" content="在计算机领域，反射是指一类应用，它们能够自描述和自控制。也即是说，这类应用通过采用某种机制来实现对自己行为的描述和监测，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射（reflect）让我们能在运行期探知对象的类型信息和内存结构，这从一定程度上弥(mi)补了静态语言在动态行为上的不足。 反射（reflect）是在计算机程序运行时，访问，检查，修改它自身的一种能力，是元编程的一种形式。 Go语音提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，但是在编译时并不知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。
 1. 为何我们需要反射？ fmt.Fprintf函数提供字符串格式化处理逻辑，它可以对任意类型的值格式化并打印，甚至支持用户自定义的类型。 让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。 这里我们使用switch类型分支来对不同的类型进行处理。
func Sprint(x interface{}) string { type stringer interface { String() string } switch x := x.(type) { case stringer: return x.String() case string: return x case int: return strconv.Itoa(x) // ...similar cases for int16, uint32, and so on...  case bool: if x { return &#34;true&#34; } return &#34;false&#34; default: // array, chan, func, map, pointer, slice, struct  return &#34;?"><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/posts/golang/golang%E4%B8%AD%E5%8F%8D%E5%B0%84reflect%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"><meta property="og:image" content="http://yangchnet.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-22T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-22T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/papermod-cover.png"><meta name=twitter:title content="Golang中反射reflect的基本使用"><meta name=twitter:description content="在计算机领域，反射是指一类应用，它们能够自描述和自控制。也即是说，这类应用通过采用某种机制来实现对自己行为的描述和监测，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射（reflect）让我们能在运行期探知对象的类型信息和内存结构，这从一定程度上弥(mi)补了静态语言在动态行为上的不足。 反射（reflect）是在计算机程序运行时，访问，检查，修改它自身的一种能力，是元编程的一种形式。 Go语音提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，但是在编译时并不知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。
 1. 为何我们需要反射？ fmt.Fprintf函数提供字符串格式化处理逻辑，它可以对任意类型的值格式化并打印，甚至支持用户自定义的类型。 让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。 这里我们使用switch类型分支来对不同的类型进行处理。
func Sprint(x interface{}) string { type stringer interface { String() string } switch x := x.(type) { case stringer: return x.String() case string: return x case int: return strconv.Itoa(x) // ...similar cases for int16, uint32, and so on...  case bool: if x { return &#34;true&#34; } return &#34;false&#34; default: // array, chan, func, map, pointer, slice, struct  return &#34;?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://yangchnet.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Golang中反射reflect的基本使用","item":"http://yangchnet.github.io/posts/golang/golang%E4%B8%AD%E5%8F%8D%E5%B0%84reflect%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang中反射reflect的基本使用","name":"Golang中反射reflect的基本使用","description":"在计算机领域，反射是指一类应用，它们能够自描述和自控制。也即是说，这类应用通过采用某种机制来实现对自己行为的描述和监测，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射（reflect）让我们能在运行期探知对象的类型信息和内存结构，这从一定程度上弥(mi)补了静态语言在动态行为上的不足。 反射（reflect）是在计算机程序运行时，访问，检查，修改它自身的一种能力，是元编程的一种形式。 Go语音提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，但是在编译时并不知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。\n 1. 为何我们需要反射？ fmt.Fprintf函数提供字符串格式化处理逻辑，它可以对任意类型的值格式化并打印，甚至支持用户自定义的类型。 让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。 这里我们使用switch类型分支来对不同的类型进行处理。\nfunc Sprint(x interface{}) string { type stringer interface { String() string } switch x := x.(type) { case stringer: return x.String() case string: return x case int: return strconv.Itoa(x) // ...similar cases for int16, uint32, and so on...  case bool: if x { return \u0026#34;true\u0026#34; } return \u0026#34;false\u0026#34; default: // array, chan, func, map, pointer, slice, struct  return \u0026#34;?","keywords":["reflect","language","golang"],"articleBody":" 在计算机领域，反射是指一类应用，它们能够自描述和自控制。也即是说，这类应用通过采用某种机制来实现对自己行为的描述和监测，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射（reflect）让我们能在运行期探知对象的类型信息和内存结构，这从一定程度上弥(mi)补了静态语言在动态行为上的不足。 反射（reflect）是在计算机程序运行时，访问，检查，修改它自身的一种能力，是元编程的一种形式。 Go语音提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，但是在编译时并不知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。\n 1. 为何我们需要反射？ fmt.Fprintf函数提供字符串格式化处理逻辑，它可以对任意类型的值格式化并打印，甚至支持用户自定义的类型。 让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。 这里我们使用switch类型分支来对不同的类型进行处理。\nfunc Sprint(x interface{}) string { type stringer interface { String() string } switch x := x.(type) { case stringer: return x.String() case string: return x case int: return strconv.Itoa(x) // ...similar cases for int16, uint32, and so on...  case bool: if x { return \"true\" } return \"false\" default: // array, chan, func, map, pointer, slice, struct  return \"???\" } } 但是我们如何处理其它类似[]float64、map[string][]string等类型呢？我们当然可以添加更多的测试分支，但是这些组合类型的数目基本是无穷的。还有如何处理url.Values等命名的类型呢？虽然类型分支可以识别出底层的基础类型是map[string][]string，但是它并不匹配url.Values类型，因为它们是两种不同的类型，而且switch类型分支也不可能包含每个类似url.Values的类型，这会导致对这些库的循环依赖。 没有一种方法来检查未知类型的表示方式，我们被卡住了，这就是我们为何需要反射的原因。\n2. reflect.Type和reflect.Values 2.1 interface{}和反射 接口值 概念上讲一个接口的值，由两部分组成，一个具体的类型和那个类型的值, 它们被称为接口的动态类型和动态值。在Go的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。 下面4个语句中，变量w得到了3个不同的值（第一个和最后一个是相同的）\nvar w io.Writer w = os.Stdout w = new(bytes.Buffer) w = nil 进一步观察在每一个语句后的w变量的值和动态行为。\n 第一个语句定义了变量w:  var w io.Writer 在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil.如下图： 一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。\n第二个语句将一个*os.File类型的值赋给变量w  w = os.Stdout 这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的.这个接口值的动态类型被设为*os.Stdout指针的类型描述符，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的os.File类型变量的指针 调用一个包含*os.File类型指针的接口值的Write方法，使得(*os.File).Write方法被调用。这个调用输出“hello”。\nw.Write([]byte(\"hello\")) 通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配(即运行时分配)。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝：os.Stdout(参照上图)。效果和下面这个直接调用一样：\nos.Stdout.Write([]byte(\"hello\")) // \"hello\" 第三个语句给接口值赋了一个*bytes.Buffer类型的值  w = new(bytes.Buffer) 现在动态类型是*bytes.Buffer并且动态值是一个指向新分配的缓冲区的指针。 Write方法的调用也使用了和之前一样的机制。\nw.Write([]byte(\"hello\")) // write \"hello\" to the bytes.Buffers 这次类型描述符是*bytes.Buffer，所以调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。\n最后，第四个语句将nil赋给了接口值  w = nil 这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时相同的状态图。 interface及其动态类型，动态值的存在，是Golang中实现反射的前提，理解了接口的动态类型的动态值，就更容易理解反射。反射就是用来检测存储在接口变量内部动态类型，动态值的一种机制。\n2.2 类型（Type） 一个Type表示一个Go类型，它是一个接口:reflect.Type()。 函数reflect.TypeOf接受任意的interface{}类型，并返回对应动态类型的reflect.Type:\nt := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // int fmt.Println(t) // int TypeOf(3)调用将3作为interface{}类型参数传入。按[2.1节](### 2.1 interface{}和反射)所述，将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：操作数的动态类型（这里是int）和它的动态的值（这里是3）。\n因为reflect.TypeOf返回的是一个接口的动态类型值，它总是返回具体的类型，因此下面的代码将打印“*os.File”而不是“io.Writer”.\nvar w io.Writer = os.Stdout fmt.Println(reflect.TypeOf(w)) // \"*os.File\" reflect.Type接口是满足fmt.Stringer接口的。因为打印动态类型值对于调试和日志是很有帮助的，fmt.Printf提供了一个简短的%T标志参数，内部使用reflect.TypeOf的结果输出。\nfmt.Printf(\"%T\\n\", 3) // \"int\" 2.3 值（Value） 一个reflect.Value可以持有一个任意类型的值，函数reflect.ValueOf接受任意的interface{}类型，并返回对应动态类型的reflect。Value。 与reflect.TypeOf类似，reflect.ValueOf返回的结果也是对于具体的类型，但是reflect.Value也可以持有一个接口值。\nv := reflect.ValueOf(3) // a reflect.Value fmt.Println(v) // \"3\" fmt.Printf(\"%v\\n\", v) // \"3\" fmt.Println(v.String()) // NOTE: \"和reflect.Type 类似, reflect.Value 也满足 fmt.Stringer 接口, 但是除非 Value 持有的是字符串,否则 String 只是返回具体的类型. 相同, 使用 fmt 包的 %v 标志参数, 将使用 reflect.Values 的结果格式化.\n调用Value的Type方法将返回具体类型所对应的reflect.Type\nt := v.Type() fmt.Println(t.String()) // int 逆操作是调用 reflect.ValueOf 对应的 reflect.Value.Interface 方法. 它返回一个 interface{} 类型 表示 reflect.Value 对应类型的具体值:\nv := reflect.ValueOf(3) // a reflect.Value x := v.Interface() // an interface{} i := x.(int) // an int fmt.Printf(\"%d\\n\", i) // \"3\" 一个 reflect.Value 和 interface{} 都能保存任意的值. 所不同的是, 一个空的接口隐藏了值对应的表示方式和所有的公开的方法, 因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值(就像上面那样), 对于内部值并没有特别可做的事情. 相比之下, 一个 Value 则有很多方法来检查其内容, 无论它的具体类型是什么.\n2.4 再次尝试format.Any 我们使用 reflect.Value 的 Kind 方法来替代之前的类型switch. 虽然还是有无穷多的类型, 但是它们的kinds类型却是有限的: Bool, String 和 所有数字类型的基础类型; Array 和 Struct 对应的聚合类型; Chan, Func, Ptr, Slice, 和 Map 对应的引用类似; 接口类型; 还有表示空值的无效类型. (空的 reflect.Value 对应 Invalid 无效类型. reflect.Value.Kind()返回reflect.Value的基类型。即对应类型的底层表示。\nvar f func(string)int v := reflect.TypeOf(f) fmt.Println(v, v.Kind()) // \"func(string)int\" \"int\" v.Kind() == reflect.Func // true package format import ( \"reflect\" \"strconv\" ) // Any formats any value as a string. func Any(value interface{}) string { return formatAtom(reflect.ValueOf(value)) } // formatAtom formats a value without inspecting its internal structure. func formatAtom(v reflect.Value) string { switch v.Kind() { case reflect.Invalid: return \"invalid\" case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: return strconv.FormatInt(v.Int(), 10) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: return strconv.FormatUint(v.Uint(), 10) // ...floating-point and complex cases omitted for brevity... \tcase reflect.Bool: return strconv.FormatBool(v.Bool()) case reflect.String: return strconv.Quote(v.String()) case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map: return v.Type().String() + \" 0x\" + strconv.FormatUint(uint64(v.Pointer()), 16) default: // reflect.Array, reflect.Struct, reflect.Interface \treturn v.Type().String() + \" value\" } } 3. 三大法则 3.1 从interface{}变量可以反射出反射对象 当我们执行 reflect.ValueOf(1) 时，虽然看起来是获取了基本类型 int 对应的反射类型，但是由于 reflect.TypeOf、reflect.ValueOf 两个方法的入参都是 interface{} 类型，所以在方法执行的过程中发生了类型转换。\n因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 int 会转换成 interface{} 类型，这也就是为什么第一条法则是从接口到反射对象。\n上面提到的 reflect.TypeOf 和 reflect.ValueOf 函数就能完成这里的转换，如果我们认为 Go 语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。 请看以下例子：\nauthor := \"Bob\" fmt.Println(\"TypeOf author:\", reflect.TypeOf(author)) // TypeOf author: string  fmt.Println(\"ValueOf author:\", reflect.ValueOf(author)) // ValueOf author: Bob 有了变量的类型之后，我们可以通过 Method 方法获得类型实现的方法，通过 Field 获取类型包含的全部字段。对于不同的类型，我们也可以调用不同的方法获取相关信息：\n 结构体：获取字段的数量并通过下标和字段名获取字段 StructField； 哈希表：获取哈希表的 Key 类型； 函数或方法：获取入参和返回值的类型； … 总而言之，使用 reflect.TypeOf和 reflect.ValueOf 能够获取 Go 语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。  3.2 从反射对象可以获取interface{}变量 既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，reflect包中的reflect.Value.Interface就能完成这项工作：\nv := reflect.ValueOf(3) // a reflect.Value x := v.Interface() // an interface{} i := x.(int) // an int fmt.Printf(\"%d\\n\", i) // \"3\" reflect.ValueOf、reflect.TypeOf与Interface方法可以说是一个互逆的过程。reflect.ValueOf、reflect.TypeOf将interface{}转化为reflect对象，而Interface将一个reflect对象重新转化为一个接口值。 3.3 要修改反射对象，其值必须可设置 假如我们想要更新一个reflect.Value,那么它持有的值一定是可以被更新的，假设有如下代码：\ni := 1 v := reflect.ValueOf(i) v.SetInt(10) fmt.Println(i) // panic: reflect: reflect.flag.mustBeAssignable using unaddressable value 运行上述代码会导致程序崩溃并报出 “reflect: reflect.flag.mustBe Assignableusing unaddressable value” 错误，仔细思考一下就能够发现出错的原因：由于 Go 语言的函数调用都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。\n想要修改原变量只能使用如下方法：\ni := 1 v := reflect.ValueOf(\u0026i) v.Elem().SetInt(10) fmt.Println(i) reflect.Value.Elem()方法获取指针指向的变量\n4. reflect场景实践  动态调用函数(无参数)  type T struct {} func main() { name := \"Do\" t := \u0026T{} reflect.ValueOf(t).MethodByName(name).Call(nil) } func (t *T) Do() { fmt.Println(\"hello\") } 动态调用函数(有参数)  type T struct{} func main() { name := \"Do\" t := \u0026T{} a := reflect.ValueOf(1111) b := reflect.ValueOf(\"world\") in := []reflect.Value{a, b} reflect.ValueOf(t).MethodByName(name).Call(in) } func (t *T) Do(a int, b string) { fmt.Println(\"hello\" + b, a) } 处理返回值中的错误  返回值也是 Value 类型，对于错误，可以转为 interface 之后断言\ntype T struct{} func main() { name := \"Do\" t := \u0026T{} ret := reflect.ValueOf(t).MethodByName(name).Call(nil) fmt.Printf(\"strValue: %[1]v\\nerrValue: %[2]v\\nstrType: %[1]T\\nerrType: %[2]T\", ret[0], ret[1].Interface().(error)) } func (t *T) Do() (string, error) { return \"hello\", errors.New(\"new error\") } struct tag 解析  type T struct { A int `json:\"aaa\" test:\"testaaa\"` B string `json:\"bbb\" test:\"testbbb\"` } func main() { t := T{ A: 123, B: \"hello\", } tt := reflect.TypeOf(t) for i := 0; i tt.NumField(); i++ { field := tt.Field(i) if json, ok := field.Tag.Lookup(\"json\"); ok { fmt.Println(json) } test := field.Tag.Get(\"test\") fmt.Println(test) } } 类型转换和赋值  type T struct { A int `newT:\"AA\"` B string `newT:\"BB\"` } type newT struct { AA int BB string } func main() { t := T{ A: 123, B: \"hello\", } tt := reflect.TypeOf(t) tv := reflect.ValueOf(t) newT := \u0026newT{} newTValue := reflect.ValueOf(newT) for i := 0; i tt.NumField(); i++ { field := tt.Field(i) newTTag := field.Tag.Get(\"newT\") tValue := tv.Field(i) newTValue.Elem().FieldByName(newTTag).Set(tValue) } fmt.Println(newT) } 通过 kind（）处理不同分支  func main() { a := 1 t := reflect.TypeOf(a) switch t.Kind() { case reflect.Int: fmt.Println(\"int\") case reflect.String: fmt.Println(\"string\") } } 判断实例是否实现了某接口  type IT interface { test1() } type T struct { A string } func (t *T) test1() {} func main() { t := \u0026T{} ITF := reflect.TypeOf((*IT)(nil)).Elem() tv := reflect.TypeOf(t) fmt.Println(tv.Implements(ITF)) } Reference 《The Go Programmer Language》 Golang的反射reflect深入理解和示例\nGo 语言设计与实现\n《Go学习笔记 . 雨痕》反射\nGo Reflect 高级实践\nPackage reflect\n","wordCount":"836","inLanguage":"en","datePublished":"2021-05-22T00:00:00Z","dateModified":"2021-05-22T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/posts/golang/golang%E4%B8%AD%E5%8F%8D%E5%B0%84reflect%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/ accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/posts/>Posts</a></div><h1 class=post-title>Golang中反射reflect的基本使用</h1><div class=post-meta><span title="2021-05-22 00:00:00 +0000 UTC">May 22, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e4%b8%ba%e4%bd%95%e6%88%91%e4%bb%ac%e9%9c%80%e8%a6%81%e5%8f%8d%e5%b0%84 aria-label="1. 为何我们需要反射？">1. 为何我们需要反射？</a></li><li><a href=#2-reflecttype%e5%92%8creflectvalues aria-label="2. reflect.Type和reflect.Values">2. reflect.Type和reflect.Values</a><ul><li><a href=#21-interface%e5%92%8c%e5%8f%8d%e5%b0%84 aria-label="2.1 interface{}和反射">2.1 interface{}和反射</a></li><li><a href=#22-%e7%b1%bb%e5%9e%8btype aria-label="2.2 类型（Type）">2.2 类型（Type）</a></li><li><a href=#23-%e5%80%bcvalue aria-label="2.3 值（Value）">2.3 值（Value）</a></li><li><a href=#24-%e5%86%8d%e6%ac%a1%e5%b0%9d%e8%af%95formatany aria-label="2.4 再次尝试format.Any">2.4 再次尝试format.Any</a></li></ul></li><li><a href=#3-%e4%b8%89%e5%a4%a7%e6%b3%95%e5%88%99 aria-label="3. 三大法则">3. 三大法则</a><ul><li><a href=#31-%e4%bb%8einterface%e5%8f%98%e9%87%8f%e5%8f%af%e4%bb%a5%e5%8f%8d%e5%b0%84%e5%87%ba%e5%8f%8d%e5%b0%84%e5%af%b9%e8%b1%a1 aria-label="3.1 从interface{}变量可以反射出反射对象">3.1 从<code>interface{}</code>变量可以反射出反射对象</a></li><li><a href=#32-%e4%bb%8e%e5%8f%8d%e5%b0%84%e5%af%b9%e8%b1%a1%e5%8f%af%e4%bb%a5%e8%8e%b7%e5%8f%96interface%e5%8f%98%e9%87%8f aria-label="3.2 从反射对象可以获取interface{}变量">3.2 从反射对象可以获取<code>interface{}</code>变量</a></li><li><a href=#33-%e8%a6%81%e4%bf%ae%e6%94%b9%e5%8f%8d%e5%b0%84%e5%af%b9%e8%b1%a1%e5%85%b6%e5%80%bc%e5%bf%85%e9%a1%bb%e5%8f%af%e8%ae%be%e7%bd%ae aria-label="3.3 要修改反射对象，其值必须可设置">3.3 要修改反射对象，其值必须可设置</a></li></ul></li><li><a href=#4-reflect%e5%9c%ba%e6%99%af%e5%ae%9e%e8%b7%b5 aria-label="4. reflect场景实践">4. reflect场景实践</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><blockquote><p>在计算机领域，反射是指一类应用，它们能够自描述和自控制。也即是说，这类应用通过采用某种机制来实现对自己行为的描述和监测，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。
反射（reflect）让我们能在运行期探知对象的类型信息和内存结构，这从一定程度上弥(mi)补了静态语言在动态行为上的不足。
反射（reflect）是在计算机程序运行时，访问，检查，修改它自身的一种能力，是元编程的一种形式。
Go语音提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，但是在编译时并不知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。</p></blockquote><h2 id=1-为何我们需要反射>1. 为何我们需要反射？<a hidden class=anchor aria-hidden=true href=#1-为何我们需要反射>#</a></h2><p><code>fmt.Fprintf</code>函数提供字符串格式化处理逻辑，它可以对任意类型的值格式化并打印，甚至支持用户自定义的类型。
让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。
这里我们使用switch类型分支来对不同的类型进行处理。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sprint</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>string</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stringer</span> <span style=color:#66d9ef>interface</span> {
        <span style=color:#a6e22e>String</span>() <span style=color:#66d9ef>string</span>
    }
    <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>.(<span style=color:#66d9ef>type</span>) {
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>stringer</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>String</span>()
    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>string</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>
    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>int</span>:
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>x</span>)
        <span style=color:#75715e>// ...similar cases for int16, uint32, and so on...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>bool</span>:
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> {
            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;true&#34;</span>
        }
        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;false&#34;</span>
    <span style=color:#66d9ef>default</span>:
            <span style=color:#75715e>// array, chan, func, map, pointer, slice, struct
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;???&#34;</span>
    }
}
</code></pre></div><p>但是我们如何处理其它类似<code>[]float64、map[string][]string</code>等类型呢？我们当然可以添加更多的测试分支，但是这些组合类型的数目基本是无穷的。还有如何处理<code>url.Values</code>等命名的类型呢？虽然类型分支可以识别出底层的基础类型是<code>map[string][]string</code>，但是它并不匹配<code>url.Values</code>类型，因为它们是两种不同的类型，而且switch类型分支也不可能包含每个类似<code>url.Values</code>的类型，这会导致对这些库的循环依赖。
没有一种方法来检查未知类型的表示方式，我们被卡住了，这就是我们为何需要反射的原因。</p><h2 id=2-reflecttype和reflectvalues>2. reflect.Type和reflect.Values<a hidden class=anchor aria-hidden=true href=#2-reflecttype和reflectvalues>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img20210522163144.png alt=20210522163144></p><h3 id=21-interface和反射>2.1 interface{}和反射<a hidden class=anchor aria-hidden=true href=#21-interface和反射>#</a></h3><p><strong>接口值</strong>
概念上讲一个接口的值，由两部分组成，一个具体的类型和那个类型的值, 它们被称为接口的动态类型和动态值。在Go的概念模型中，一些提供每个类型信息的值被称为<code>类型描述符</code>，比如类型的名称和方法。<strong>在一个接口值中，类型部分代表与之相关类型的描述符</strong>。
下面4个语句中，变量w得到了3个不同的值（第一个和最后一个是相同的）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>w</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Writer</span>
<span style=color:#a6e22e>w</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>
<span style=color:#a6e22e>w</span> = new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
<span style=color:#a6e22e>w</span> = <span style=color:#66d9ef>nil</span>
</code></pre></div><p>进一步观察在每一个语句后的w变量的值和动态行为。</p><ol><li>第一个语句定义了变量w:</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>w</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Writer</span>
</code></pre></div><p>在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil.如下图：
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img20210522143522.png alt=20210522143522>
一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。</p><ol start=2><li>第二个语句将一个<code>*os.File</code>类型的值赋给变量<code>w</code></li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>w</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>
</code></pre></div><p>这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用<code>io.Writer(os.Stdout)</code>是等价的.这个接口值的动态类型被设为<code>*os.Stdout</code>指针的类型描述符，它的动态值持有<code>os.Stdout</code>的拷贝；这是一个代表处理标准输出的<code>os.File</code>类型变量的指针
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img20210522144134.png alt=20210522144134>
调用一个包含<code>*os.File</code>类型指针的接口值的<code>Write</code>方法，使得<code>(*os.File).Write</code>方法被调用。这个调用输出“hello”。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;hello&#34;</span>))
</code></pre></div><p>通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配(即运行时分配)。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝：<code>os.Stdout</code>(参照上图)。效果和下面这个直接调用一样：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;hello&#34;</span>)) <span style=color:#75715e>// &#34;hello&#34;
</span></code></pre></div><ol start=3><li>第三个语句给接口值赋了一个<code>*bytes.Buffer</code>类型的值</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>w</span> = new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</code></pre></div><p>现在动态类型是<code>*bytes.Buffer</code>并且动态值是一个指向新分配的缓冲区的指针。
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img20210522145148.png alt=20210522145148>
<code>Write</code>方法的调用也使用了和之前一样的机制。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>&#34;hello&#34;</span>))  <span style=color:#75715e>// write &#34;hello&#34; to the bytes.Buffers
</span></code></pre></div><p>这次类型描述符是<code>*bytes.Buffer</code>，所以调用了<code>(*bytes.Buffer).Write</code>方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。</p><ol start=4><li>最后，第四个语句将nil赋给了接口值</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>w</span> = <span style=color:#66d9ef>nil</span>
</code></pre></div><p>这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时相同的状态图。
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img20210522143522.png alt=20210522143522></p><p>interface及其<code>动态类型，动态值</code>的存在，是Golang中实现反射的前提，理解了接口的动态类型的动态值，就更容易理解反射。反射就是用来检测存储在接口变量内部动态类型，动态值的一种机制。</p><h3 id=22-类型type>2.2 类型（Type）<a hidden class=anchor aria-hidden=true href=#22-类型type>#</a></h3><p>一个Type表示一个Go类型，它是一个接口:reflect.Type()。
函数<code>reflect.TypeOf</code>接受任意的<code>interface{}</code>类型，并返回对应动态类型的<code>reflect.Type</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#ae81ff>3</span>)  <span style=color:#75715e>// a reflect.Type
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>String</span>()) <span style=color:#75715e>// int
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>t</span>) <span style=color:#75715e>// int
</span></code></pre></div><p><code>TypeOf(3)</code>调用将3作为<code>interface{}</code>类型参数传入。按[2.1节](### 2.1 interface{}和反射)所述，将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：操作数的动态类型（这里是int）和它的动态的值（这里是3）。</p><p>因为<code>reflect.TypeOf</code>返回的是一个接口的动态类型值，它总是返回具体的类型，因此下面的代码将打印“*os.File”而不是“io.Writer”.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>w</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Writer</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>w</span>)) <span style=color:#75715e>// &#34;*os.File&#34;
</span></code></pre></div><p><code>reflect.Type</code>接口是满足<code>fmt.Stringer</code>接口的。因为打印动态类型值对于调试和日志是很有帮助的，<code>fmt.Printf</code>提供了一个简短的<code>%T</code>标志参数，内部使用<code>reflect.TypeOf</code>的结果输出。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%T\n&#34;</span>, <span style=color:#ae81ff>3</span>) <span style=color:#75715e>// &#34;int&#34;
</span></code></pre></div><h3 id=23-值value>2.3 值（Value）<a hidden class=anchor aria-hidden=true href=#23-值value>#</a></h3><p>一个<code>reflect.Value</code>可以持有一个任意类型的值，函数<code>reflect.ValueOf</code>接受任意的<code>interface{}</code>类型，并返回对应动态类型的<code>reflect。Value</code>。
与<code>reflect.TypeOf</code>类似，<code>reflect.ValueOf</code>返回的结果也是对于具体的类型，但是<code>reflect.Value</code>也可以持有一个接口值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#ae81ff>3</span>) <span style=color:#75715e>// a reflect.Value
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>) <span style=color:#75715e>// &#34;3&#34;
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%v\n&#34;</span>, <span style=color:#a6e22e>v</span>) <span style=color:#75715e>// &#34;3&#34;
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>String</span>()) <span style=color:#75715e>// NOTE: &#34;&lt;int Value&gt;
</span></code></pre></div><p>和<code>reflect.Type</code> 类似, <code>reflect.Value</code> 也满足 <code>fmt.Stringer</code> 接口, 但是除非 Value 持有的是字符串,否则 String 只是返回具体的类型. 相同, 使用 <code>fmt</code> 包的 <code>%v</code> 标志参数, 将使用 <code>reflect.Values</code> 的结果格式化.</p><p>调用<code>Value</code>的<code>Type</code>方法将返回具体类型所对应的<code>reflect.Type</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Type</span>()
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>String</span>()) <span style=color:#75715e>// int
</span></code></pre></div><p>逆操作是调用 reflect.ValueOf 对应的 reflect.Value.Interface 方法. 它返回一个 interface{} 类型
表示 reflect.Value 对应类型的具体值:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#ae81ff>3</span>) <span style=color:#75715e>// a reflect.Value
</span><span style=color:#75715e></span><span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Interface</span>() <span style=color:#75715e>// an interface{}
</span><span style=color:#75715e></span><span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>.(<span style=color:#66d9ef>int</span>) <span style=color:#75715e>// an int
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d\n&#34;</span>, <span style=color:#a6e22e>i</span>) <span style=color:#75715e>// &#34;3&#34;
</span></code></pre></div><p>一个 <code>reflect.Value</code> 和 <code>interface{}</code> 都能保存任意的值. 所不同的是, 一个空的接口隐藏了值对应的表示方式和所有的公开的方法, 因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值(就像上面那样), 对于内部值并没有特别可做的事情. 相比之下, 一个 <code>Value</code> 则有很多方法来检查其内容, 无论它的具体类型是什么.</p><h3 id=24-再次尝试formatany>2.4 再次尝试format.Any<a hidden class=anchor aria-hidden=true href=#24-再次尝试formatany>#</a></h3><p>我们使用 <code>reflect.Value</code> 的 <code>Kind</code> 方法来替代之前的类型switch. 虽然还是有无穷多的类型, 但是它们的<code>kinds</code>类型却是有限的: Bool, String 和 所有数字类型的基础类型; Array 和 Struct 对应的聚合类型; Chan, Func, Ptr, Slice, 和 Map 对应的引用类似; 接口类型; 还有表示空值的无效类型. (空的 reflect.Value 对应 Invalid 无效类型.
<code>reflect.Value.Kind()</code>返回<code>reflect.Value</code>的基类型。即对应类型的底层表示。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>string</span>)<span style=color:#66d9ef>int</span>
<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>f</span>)
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Kind</span>())  <span style=color:#75715e>// &#34;func(string)int&#34;  &#34;int&#34;
</span><span style=color:#75715e></span><span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Kind</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Func</span>  <span style=color:#75715e>// true
</span></code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>format</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;reflect&#34;</span>
	<span style=color:#e6db74>&#34;strconv&#34;</span>
)

<span style=color:#75715e>// Any formats any value as a string.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Any</span>(<span style=color:#a6e22e>value</span> <span style=color:#66d9ef>interface</span>{}) <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>formatAtom</span>(<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>value</span>))
}

<span style=color:#75715e>// formatAtom formats a value without inspecting its internal structure.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>formatAtom</span>(<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>string</span> {
	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Kind</span>() {
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Invalid</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;invalid&#34;</span>
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int8</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int16</span>,
		<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int32</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int64</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatInt</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Int</span>(), <span style=color:#ae81ff>10</span>)
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint8</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint16</span>,
		<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint32</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uint64</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Uintptr</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatUint</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Uint</span>(), <span style=color:#ae81ff>10</span>)
		<span style=color:#75715e>// ...floating-point and complex cases omitted for brevity...
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Bool</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatBool</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Bool</span>())
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>String</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Quote</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>String</span>())
	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Chan</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Func</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Ptr</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Slice</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Map</span>:
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Type</span>().<span style=color:#a6e22e>String</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 0x&#34;</span> <span style=color:#f92672>+</span>
			<span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatUint</span>(uint64(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Pointer</span>()), <span style=color:#ae81ff>16</span>)
	<span style=color:#66d9ef>default</span>: <span style=color:#75715e>// reflect.Array, reflect.Struct, reflect.Interface
</span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Type</span>().<span style=color:#a6e22e>String</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; value&#34;</span>
	}
}
</code></pre></div><h2 id=3-三大法则>3. 三大法则<a hidden class=anchor aria-hidden=true href=#3-三大法则>#</a></h2><h3 id=31-从interface变量可以反射出反射对象>3.1 从<code>interface{}</code>变量可以反射出反射对象<a hidden class=anchor aria-hidden=true href=#31-从interface变量可以反射出反射对象>#</a></h3><p>当我们执行 <code>reflect.ValueOf(1)</code> 时，虽然看起来是获取了基本类型 int 对应的反射类型，但是由于 <code>reflect.TypeOf</code>、<code>reflect.ValueOf</code> 两个方法的入参都是 <code>interface{}</code> 类型，所以在方法执行的过程中发生了类型转换。</p><p>因为Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换。基本类型 <code>int</code> 会转换成 <code>interface{}</code> 类型，这也就是为什么第一条法则是从接口到反射对象。</p><p>上面提到的 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 函数就能完成这里的转换，如果我们认为 Go 语言的类型和反射类型处于两个不同的世界，那么这两个函数就是连接这两个世界的桥梁。
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img20210522164336.png alt=20210522164336>
请看以下例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>author</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Bob&#34;</span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;TypeOf author:&#34;</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>author</span>))  <span style=color:#75715e>// TypeOf author: string
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;ValueOf author:&#34;</span>, <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>author</span>)) <span style=color:#75715e>// ValueOf author: Bob
</span></code></pre></div><p>有了变量的类型之后，我们可以通过 Method 方法获得类型实现的方法，通过 Field 获取类型包含的全部字段。对于不同的类型，我们也可以调用不同的方法获取相关信息：</p><ul><li>结构体：获取字段的数量并通过下标和字段名获取字段 StructField；</li><li>哈希表：获取哈希表的 Key 类型；</li><li>函数或方法：获取入参和返回值的类型；</li><li>…
总而言之，使用 <code>reflect.TypeOf</code>和 <code>reflect.ValueOf</code> 能够获取 Go 语言中的变量对应的反射对象。一旦获取了反射对象，我们就能得到跟当前类型相关数据和操作，并可以使用这些运行时获取的结构执行方法。</li></ul><h3 id=32-从反射对象可以获取interface变量>3.2 从反射对象可以获取<code>interface{}</code>变量<a hidden class=anchor aria-hidden=true href=#32-从反射对象可以获取interface变量>#</a></h3><p>既然能够将接口类型的变量转换成反射对象，那么一定需要其他方法将反射对象还原成接口类型的变量，<code>reflect</code>包中的<code>reflect.Value.Interface</code>就能完成这项工作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#ae81ff>3</span>) <span style=color:#75715e>// a reflect.Value
</span><span style=color:#75715e></span><span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Interface</span>() <span style=color:#75715e>// an interface{}
</span><span style=color:#75715e></span><span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>.(<span style=color:#66d9ef>int</span>) <span style=color:#75715e>// an int
</span><span style=color:#75715e></span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%d\n&#34;</span>, <span style=color:#a6e22e>i</span>) <span style=color:#75715e>// &#34;3&#34;
</span></code></pre></div><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img20210522165432.png alt=20210522165432></p><p><code>reflect.ValueOf</code>、<code>reflect.TypeOf</code>与<code>Interface</code>方法可以说是一个互逆的过程。<code>reflect.ValueOf</code>、<code>reflect.TypeOf</code>将<code>interface{}</code>转化为reflect对象，而<code>Interface</code>将一个reflect对象重新转化为一个接口值。
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img20210522170413.png alt=20210522170413></p><h3 id=33-要修改反射对象其值必须可设置>3.3 要修改反射对象，其值必须可设置<a hidden class=anchor aria-hidden=true href=#33-要修改反射对象其值必须可设置>#</a></h3><p>假如我们想要更新一个<code>reflect.Value</code>,那么它持有的值一定是可以被更新的，假设有如下代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>i</span>)
<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>SetInt</span>(<span style=color:#ae81ff>10</span>)
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>) <span style=color:#75715e>// panic: reflect: reflect.flag.mustBeAssignable using unaddressable value
</span></code></pre></div><p>运行上述代码会导致程序崩溃并报出 “reflect: reflect.flag.mustBe Assignableusing unaddressable value” 错误，仔细思考一下就能够发现出错的原因：由于 Go 语言的函数调用都是传值的，所以我们得到的反射对象跟最开始的变量没有任何关系，那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。</p><p>想要修改原变量只能使用如下方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>i</span>)
<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>SetInt</span>(<span style=color:#ae81ff>10</span>)
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>i</span>)
</code></pre></div><p><code>reflect.Value.Elem()</code>方法获取指针指向的变量</p><h2 id=4-reflect场景实践>4. reflect场景实践<a hidden class=anchor aria-hidden=true href=#4-reflect场景实践>#</a></h2><ol><li>动态调用函数(无参数)</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span> {}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Do&#34;</span>
    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>T</span>{}
    <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>t</span>).<span style=color:#a6e22e>MethodByName</span>(<span style=color:#a6e22e>name</span>).<span style=color:#a6e22e>Call</span>(<span style=color:#66d9ef>nil</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>Do</span>() {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello&#34;</span>)
}
</code></pre></div><ol start=2><li>动态调用函数(有参数)</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Do&#34;</span>
    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>T</span>{}
    <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#ae81ff>1111</span>)
    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#e6db74>&#34;world&#34;</span>)
    <span style=color:#a6e22e>in</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Value</span>{<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>}
    <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>t</span>).<span style=color:#a6e22e>MethodByName</span>(<span style=color:#a6e22e>name</span>).<span style=color:#a6e22e>Call</span>(<span style=color:#a6e22e>in</span>)
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>string</span>) {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>a</span>)
}
</code></pre></div><ol start=3><li>处理返回值中的错误</li></ol><p>返回值也是 Value 类型，对于错误，可以转为 interface 之后断言</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span>{}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>name</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Do&#34;</span>
    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>T</span>{}
    <span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>t</span>).<span style=color:#a6e22e>MethodByName</span>(<span style=color:#a6e22e>name</span>).<span style=color:#a6e22e>Call</span>(<span style=color:#66d9ef>nil</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;strValue: %[1]v\nerrValue: %[2]v\nstrType: %[1]T\nerrType: %[2]T&#34;</span>, <span style=color:#a6e22e>ret</span>[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>ret</span>[<span style=color:#ae81ff>1</span>].<span style=color:#a6e22e>Interface</span>().(<span style=color:#66d9ef>error</span>))
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>Do</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;new error&#34;</span>)
}
</code></pre></div><ol start=4><li>struct tag 解析</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>A</span> <span style=color:#66d9ef>int</span>    <span style=color:#e6db74>`json:&#34;aaa&#34; test:&#34;testaaa&#34;`</span>
    <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;bbb&#34; test:&#34;testbbb&#34;`</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>T</span>{
        <span style=color:#a6e22e>A</span>: <span style=color:#ae81ff>123</span>,
        <span style=color:#a6e22e>B</span>: <span style=color:#e6db74>&#34;hello&#34;</span>,
    }
    <span style=color:#a6e22e>tt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>t</span>)
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>NumField</span>(); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>field</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>json</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>field</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Lookup</span>(<span style=color:#e6db74>&#34;json&#34;</span>); <span style=color:#a6e22e>ok</span> {
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>json</span>)
        }
        <span style=color:#a6e22e>test</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>field</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;test&#34;</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>test</span>)
    }
}
</code></pre></div><ol start=5><li>类型转换和赋值</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>A</span> <span style=color:#66d9ef>int</span>    <span style=color:#e6db74>`newT:&#34;AA&#34;`</span>
    <span style=color:#a6e22e>B</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`newT:&#34;BB&#34;`</span>
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>newT</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>AA</span> <span style=color:#66d9ef>int</span>
    <span style=color:#a6e22e>BB</span> <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>T</span>{
        <span style=color:#a6e22e>A</span>: <span style=color:#ae81ff>123</span>,
        <span style=color:#a6e22e>B</span>: <span style=color:#e6db74>&#34;hello&#34;</span>,
    }
    <span style=color:#a6e22e>tt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>t</span>)
    <span style=color:#a6e22e>tv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>t</span>)

    <span style=color:#a6e22e>newT</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newT</span>{}
    <span style=color:#a6e22e>newTValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>ValueOf</span>(<span style=color:#a6e22e>newT</span>)

    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>NumField</span>(); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>field</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>)
        <span style=color:#a6e22e>newTTag</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>field</span>.<span style=color:#a6e22e>Tag</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;newT&#34;</span>)
        <span style=color:#a6e22e>tValue</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Field</span>(<span style=color:#a6e22e>i</span>)
        <span style=color:#a6e22e>newTValue</span>.<span style=color:#a6e22e>Elem</span>().<span style=color:#a6e22e>FieldByName</span>(<span style=color:#a6e22e>newTTag</span>).<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>tValue</span>)
    }

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>newT</span>)
}
</code></pre></div><ol start=6><li>通过 kind（）处理不同分支</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>a</span>)
    <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Kind</span>() {
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>Int</span>:
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;int&#34;</span>)
    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>String</span>:
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;string&#34;</span>)
    }
}
</code></pre></div><ol start=7><li>判断实例是否实现了某接口</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IT</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#a6e22e>test1</span>()
}

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>A</span> <span style=color:#66d9ef>string</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>T</span>) <span style=color:#a6e22e>test1</span>() {}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>T</span>{}
    <span style=color:#a6e22e>ITF</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>IT</span>)(<span style=color:#66d9ef>nil</span>)).<span style=color:#a6e22e>Elem</span>()
    <span style=color:#a6e22e>tv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>TypeOf</span>(<span style=color:#a6e22e>t</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>tv</span>.<span style=color:#a6e22e>Implements</span>(<span style=color:#a6e22e>ITF</span>))
}
</code></pre></div><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><p>《The Go Programmer Language》
<a href=https://juejin.cn/post/6844903559335526407>Golang的反射reflect深入理解和示例</a></p><p><a href=https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/>Go 语言设计与实现</a></p><p><a href=https://www.cnblogs.com/52php/p/6340487.html>《Go学习笔记 . 雨痕》反射</a></p><p><a href=https://segmentfault.com/a/1190000016230264>Go Reflect 高级实践</a></p><p><a href=https://golang.org/pkg/reflect>Package reflect</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/tags/reflect/>reflect</a></li><li><a href=http://yangchnet.github.io/tags/language/>language</a></li><li><a href=http://yangchnet.github.io/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/posts/golang/golang%E4%B8%ADcontext%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/><span class=title>« Prev Page</span><br><span>golang中context包的使用</span></a>
<a class=next href=http://yangchnet.github.io/posts/env/zsh%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/><span class=title>Next Page »</span><br><span>zsh的基本配置</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://yangchnet.github.io/>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>