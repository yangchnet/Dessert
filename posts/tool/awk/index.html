<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>awk基础 | Linote</title><meta name=keywords content="awk,linux"><meta name=description content="https://github.com/wuzhouhui/awk/blob/master/The_AWK_Programming_Language_zh_CN.pdf
 0. 实用一行手册  输入行的总行数 END { print NR } 打印第 10 行 NR == 10 打印每一个输入行的最后一个字段 { print $NF } 打印最后一行的最后一个字段  { field = $NF } END { print field } 打印字段数多于 4 个的输入行 NF > 4 打印最后一个字段值大于 4 的输入行 $NF > 4 打印所有输入行的字段数的总和  { nf = nf + NF } END { print nf } 打印包含 Beth 的行的数量  /Beth/ { nlines = nlines + 1 } END { print nlines } 打印具有最大值的第一个字段, 以及包含它的行 (假设 $1 总是 正的) 18  $1 > max { max = $1; maxline = $0 } END { print max, maxline } 打印至少包含一个字段的行 NF > 0 打印长度超过 80 个字符的行 length($0) > 80 在每一行的前面加上它的字段数 { print NF, $0 } 打印每一行的第 1 与第 2 个字段, 但顺序相反 { print $2, $1 } 交换每一行的第 1 与第 2 个字段, 并打印该行 { temp = $1; $1 = $2; $2 = temp; print } 将每一行的第一个字段用行号代替 { $1 = NR; print } 打印删除了第 2 个字段后的行 { $2 = &#34;&#34;; print } 将每一行的字段按逆序打印  printf(&#34;\n&#34;) }``` 18."><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/tool/awk/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="awk基础"><meta property="og:description" content="https://github.com/wuzhouhui/awk/blob/master/The_AWK_Programming_Language_zh_CN.pdf
 0. 实用一行手册  输入行的总行数 END { print NR } 打印第 10 行 NR == 10 打印每一个输入行的最后一个字段 { print $NF } 打印最后一行的最后一个字段  { field = $NF } END { print field } 打印字段数多于 4 个的输入行 NF > 4 打印最后一个字段值大于 4 的输入行 $NF > 4 打印所有输入行的字段数的总和  { nf = nf + NF } END { print nf } 打印包含 Beth 的行的数量  /Beth/ { nlines = nlines + 1 } END { print nlines } 打印具有最大值的第一个字段, 以及包含它的行 (假设 $1 总是 正的) 18  $1 > max { max = $1; maxline = $0 } END { print max, maxline } 打印至少包含一个字段的行 NF > 0 打印长度超过 80 个字符的行 length($0) > 80 在每一行的前面加上它的字段数 { print NF, $0 } 打印每一行的第 1 与第 2 个字段, 但顺序相反 { print $2, $1 } 交换每一行的第 1 与第 2 个字段, 并打印该行 { temp = $1; $1 = $2; $2 = temp; print } 将每一行的第一个字段用行号代替 { $1 = NR; print } 打印删除了第 2 个字段后的行 { $2 = &#34;&#34;; print } 将每一行的字段按逆序打印  printf(&#34;\n&#34;) }``` 18."><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/tool/awk/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-18T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="awk基础"><meta name=twitter:description content="https://github.com/wuzhouhui/awk/blob/master/The_AWK_Programming_Language_zh_CN.pdf
 0. 实用一行手册  输入行的总行数 END { print NR } 打印第 10 行 NR == 10 打印每一个输入行的最后一个字段 { print $NF } 打印最后一行的最后一个字段  { field = $NF } END { print field } 打印字段数多于 4 个的输入行 NF > 4 打印最后一个字段值大于 4 的输入行 $NF > 4 打印所有输入行的字段数的总和  { nf = nf + NF } END { print nf } 打印包含 Beth 的行的数量  /Beth/ { nlines = nlines + 1 } END { print nlines } 打印具有最大值的第一个字段, 以及包含它的行 (假设 $1 总是 正的) 18  $1 > max { max = $1; maxline = $0 } END { print max, maxline } 打印至少包含一个字段的行 NF > 0 打印长度超过 80 个字符的行 length($0) > 80 在每一行的前面加上它的字段数 { print NF, $0 } 打印每一行的第 1 与第 2 个字段, 但顺序相反 { print $2, $1 } 交换每一行的第 1 与第 2 个字段, 并打印该行 { temp = $1; $1 = $2; $2 = temp; print } 将每一行的第一个字段用行号代替 { $1 = NR; print } 打印删除了第 2 个字段后的行 { $2 = &#34;&#34;; print } 将每一行的字段按逆序打印  printf(&#34;\n&#34;) }``` 18."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"awk基础","item":"http://yangchnet.github.io/Dessert/posts/tool/awk/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"awk基础","name":"awk基础","description":"https://github.com/wuzhouhui/awk/blob/master/The_AWK_Programming_Language_zh_CN.pdf\n 0. 实用一行手册  输入行的总行数 END { print NR } 打印第 10 行 NR == 10 打印每一个输入行的最后一个字段 { print $NF } 打印最后一行的最后一个字段  { field = $NF } END { print field } 打印字段数多于 4 个的输入行 NF \u0026gt; 4 打印最后一个字段值大于 4 的输入行 $NF \u0026gt; 4 打印所有输入行的字段数的总和  { nf = nf + NF } END { print nf } 打印包含 Beth 的行的数量  /Beth/ { nlines = nlines + 1 } END { print nlines } 打印具有最大值的第一个字段, 以及包含它的行 (假设 $1 总是 正的) 18  $1 \u0026gt; max { max = $1; maxline = $0 } END { print max, maxline } 打印至少包含一个字段的行 NF \u0026gt; 0 打印长度超过 80 个字符的行 length($0) \u0026gt; 80 在每一行的前面加上它的字段数 { print NF, $0 } 打印每一行的第 1 与第 2 个字段, 但顺序相反 { print $2, $1 } 交换每一行的第 1 与第 2 个字段, 并打印该行 { temp = $1; $1 = $2; $2 = temp; print } 将每一行的第一个字段用行号代替 { $1 = NR; print } 打印删除了第 2 个字段后的行 { $2 = \u0026quot;\u0026quot;; print } 将每一行的字段按逆序打印  printf(\u0026quot;\\n\u0026quot;) }``` 18.","keywords":["awk","linux"],"articleBody":" https://github.com/wuzhouhui/awk/blob/master/The_AWK_Programming_Language_zh_CN.pdf\n 0. 实用一行手册  输入行的总行数 END { print NR } 打印第 10 行 NR == 10 打印每一个输入行的最后一个字段 { print $NF } 打印最后一行的最后一个字段  { field = $NF } END { print field } 打印字段数多于 4 个的输入行 NF  4 打印最后一个字段值大于 4 的输入行 $NF  4 打印所有输入行的字段数的总和  { nf = nf + NF } END { print nf } 打印包含 Beth 的行的数量  /Beth/ { nlines = nlines + 1 } END { print nlines } 打印具有最大值的第一个字段, 以及包含它的行 (假设 $1 总是 正的) 18  $1  max { max = $1; maxline = $0 } END { print max, maxline } 打印至少包含一个字段的行 NF  0 打印长度超过 80 个字符的行 length($0)  80 在每一行的前面加上它的字段数 { print NF, $0 } 打印每一行的第 1 与第 2 个字段, 但顺序相反 { print $2, $1 } 交换每一行的第 1 与第 2 个字段, 并打印该行 { temp = $1; $1 = $2; $2 = temp; print } 将每一行的第一个字段用行号代替 { $1 = NR; print } 打印删除了第 2 个字段后的行 { $2 = \"\"; print } 将每一行的字段按逆序打印  printf(\"\\n\") }``` 18. 打印每一行的所有字段值之和 { sum = 0 for (i = 1; i 19. 将所有行的所有字段值累加起来 { for (i = 1; i 20. 将每一行的每一个字段用它的绝对值替换 { for (i = 1; i  ---- # 1. 基本概念 awk是一种编程语言，用于处理文本文件。它是一种解释型语言，通常用于文本处理和数据提取。 awk程序的基本结构为： pattern { action }\n 其中，`pattern`是一个条件，`action`是一个或多个命令，当`pattern`匹配时，`action`会被执行。 例如，对于如下文件内容： Beth 4.00 0 Dan 3.75 0 Kathy 4.00 10 Mark 5.00 20 Mary 5.50 22 Susie 4.25 18\n如果要打印每位雇员的名字以及他们的报酬 (每小时工资乘以工作时长), 而雇员的工作时长必须大于零： ```bash awk '$3  0 { print $1, $2 * $3 }' file.txt 在这里，$3  0是一个条件，{ print $1, $2 * $3 }是一个命令，当条件满足时，命令会被执行。\n运行一个awk程序有多种方式，上面我们直接在命令行中输入了awk程序，也可以将awk程序写入一个文件中，然后通过-f选项来执行：\nawk -f progfile file.txt file1.txt 文本也可以被放在输出中：\n{ print \"total pay for\", $1, \"is\", $2 * $3 } 2. 内置变量  NF, 表示当前行的字段数，例如：print NF, $1, $NF会打印出当前行的字段数、第一个字段和最后一个字段。 NR, 这个变量计算到当前为止，读取到的行的数量，例如：awk '{ print NR, $0 }' file.txt会为文件的每一行加上行号  3. 格式化输出 awk提供了printf函数来格式化输出，其语法与C语言中的printf函数类似：\nprintf(\"format\", var1, var2, ...) 其中format是类似于C风格的printf函数的参数，var1、var2等是要输出的值。使用 printf 不会自动产生空格符或换行符; 用户必须自己创建它们, 不要忘了 \\n.\n4. 使用模式进行选择  通过比较操作符进行选择，例如：$3  0，$1 == \"Beth\"等 通过计算操作符进行选择，例如：$2 * $3  10，$1 ~ /Beth/等 可以使用正则表达式，~匹配，!~不匹配 可以使用逻辑运算，\u0026\u0026、||、! 可以使用括弧，(condition)  5. BEGIN 与 END 特殊的模式 BEGIN 在第一个输入文件的第一行之前被匹配, END 在最后一个输入文件的最后一行被处理 之后匹配. 这个程序使用 BEGIN 打印一个标题\nBEGIN { print \"NAME RATE HOURS\"; print \"\" } { print } 6. 计算 在awk里，不仅可以使用内建变量，还可以自定义变量，用户创建的变量不需要声明就可使用。\n 计数，下面的程序用一个变量emp计算工作时长超过15小时的工作人员  $3  15 { emp = emp + 1 } END { print emp, \"employees worked more than 15 hours\" }  操作文本 这个程序搜索每小时工资最高的雇员:  $2  maxrate { maxrate = $2; maxemp = $1 } END { print \"highest hourly rate:\", maxrate, \"for\", maxemp } # highest hourly rate: 5.50 for Mary 程序\n{ names = names $1 \" \" } END { print names } 将所有雇员的名字都收集到一个单独的字符串中, 每一次拼接都是把名字与一个空格符添加到变量 names 的 值的末尾. names 在 END 动作中被打印出来: Beth Dan Kathy Mark Mary Susie\n 内建函数length length函数返回字符串的长度  { print $1, length($1) } 7. 流程控制语句  If-Else 语句 下面这个程序计算每小时工资多于 $6.00 的雇员的总报酬与平均报酬. 在计算平均数时, 它用到了 if 语 句, 避免用 0 作除数.  $2  6 { n = n + 1; pay = pay + $2 * $3 } END { if (n  0) print n, \"employees, total pay is\", pay, \"average pay is\", pay/n else print \"no employees are paid more than $6/hour\" }  While 语句 一个 while 含有一个条件判断与一个循环体. 当条件为真时, 循环体执行. 下面这个程序展示了一笔钱在 一个特定的利率下, 其价值如何随着投资时间的增长而增加, 价值计算的公式是 value = amount(1+rate) years  # interest1 - compute compound interest # input: amount rate years # output: compounded value at the end of each year { i = 1 while (i  For 语句 大多数循环都包括初始化, 测试, 增值, 而 for 语句将这三者压缩成一行. 这里是前一个计算投资回报的 程序, 不过这次用 for 循环:  # interest2 - compute compound interest # input: amount rate years # output: compounded value at the end of each year { for (i = 1; i 8. 数组 Awk 提供了数组, 用来存储一组相关的值. 虽然数组给予了 awk 非常可观的力量, 但是我们在这里只展示 一个简单的例子. 下面这个程序按行逆序显示输入数据. 第一个动作将输入行放入数组 line 的下一个元素中; 也就是说, 第一行放入 line[1], 第二行放入 line[2], 依次类推. END 动作用一个 while 循环, 从数组的最 后一个元素开始打印, 一直打印到第一个元素为止:\n# reverse - print input in reverse order by line { line[NR] = $0 } # remember each input line END { i = NR # print lines in reverse order while (i  0) { print line[i] i = i - 1 } } ","wordCount":"717","inLanguage":"en","datePublished":"2024-10-18T00:00:00Z","dateModified":"2024-10-18T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/tool/awk/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>awk基础</h1><div class=post-meta><span title="2024-10-18 00:00:00 +0000 UTC">October 18, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#0-%e5%ae%9e%e7%94%a8%e4%b8%80%e8%a1%8c%e6%89%8b%e5%86%8c aria-label="0. 实用一行手册">0. 实用一行手册</a></li><li><a href=#2-%e5%86%85%e7%bd%ae%e5%8f%98%e9%87%8f aria-label="2. 内置变量">2. 内置变量</a></li><li><a href=#3-%e6%a0%bc%e5%bc%8f%e5%8c%96%e8%be%93%e5%87%ba aria-label="3. 格式化输出">3. 格式化输出</a></li><li><a href=#4-%e4%bd%bf%e7%94%a8%e6%a8%a1%e5%bc%8f%e8%bf%9b%e8%a1%8c%e9%80%89%e6%8b%a9 aria-label="4. 使用模式进行选择">4. 使用模式进行选择</a></li><li><a href=#5-begin-%e4%b8%8e-end aria-label="5. BEGIN 与 END">5. BEGIN 与 END</a></li><li><a href=#6-%e8%ae%a1%e7%ae%97 aria-label="6. 计算">6. 计算</a></li><li><a href=#7-%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%e8%af%ad%e5%8f%a5 aria-label="7. 流程控制语句">7. 流程控制语句</a></li><li><a href=#8-%e6%95%b0%e7%bb%84 aria-label="8. 数组">8. 数组</a></li></ul></div></details></div><div class=post-content><blockquote><p><a href=https://github.com/wuzhouhui/awk/blob/master/The_AWK_Programming_Language_zh_CN.pdf>https://github.com/wuzhouhui/awk/blob/master/The_AWK_Programming_Language_zh_CN.pdf</a></p></blockquote><h1 id=0-实用一行手册>0. 实用一行手册<a hidden class=anchor aria-hidden=true href=#0-实用一行手册>#</a></h1><ol><li>输入行的总行数
<code>END { print NR }</code></li><li>打印第 10 行
<code>NR == 10</code></li><li>打印每一个输入行的最后一个字段
<code>{ print $NF }</code></li><li>打印最后一行的最后一个字段</li></ol><pre><code>{ field = $NF }
END { print field }
</code></pre><ol start=5><li>打印字段数多于 4 个的输入行
<code>NF > 4</code></li><li>打印最后一个字段值大于 4 的输入行
<code>$NF > 4</code></li><li>打印所有输入行的字段数的总和</li></ol><pre><code>{ nf = nf + NF }
END { print nf }
</code></pre><ol start=8><li>打印包含 Beth 的行的数量</li></ol><pre><code>/Beth/ { nlines = nlines + 1 }
END { print nlines }
</code></pre><ol start=9><li>打印具有最大值的第一个字段, 以及包含它的行 (假设 $1 总是 正的) 18</li></ol><pre><code>$1 &gt; max { max = $1; maxline = $0 }
END { print max, maxline }
</code></pre><ol start=10><li>打印至少包含一个字段的行
<code>NF > 0</code></li><li>打印长度超过 80 个字符的行
<code>length($0) > 80</code></li><li>在每一行的前面加上它的字段数
<code>{ print NF, $0 }</code></li><li>打印每一行的第 1 与第 2 个字段, 但顺序相反
<code>{ print $2, $1 }</code></li><li>交换每一行的第 1 与第 2 个字段, 并打印该行
<code>{ temp = $1; $1 = $2; $2 = temp; print }</code></li><li>将每一行的第一个字段用行号代替
<code>{ $1 = NR; print }</code></li><li>打印删除了第 2 个字段后的行
<code>{ $2 = ""; print }</code></li><li>将每一行的字段按逆序打印</li></ol><pre><code class=language-{ data-lang={>printf(&quot;\n&quot;)
}```
18. 打印每一行的所有字段值之和
</code></pre><p>{ sum = 0
for (i = 1; i &lt;= NF; i = i + 1) sum = sum + $i
print sum
}</p><pre><code>19. 将所有行的所有字段值累加起来
</code></pre><p>{ for (i = 1; i &lt;= NF; i = i + 1) sum = sum + $i }
END { print sum }</p><pre><code>20. 将每一行的每一个字段用它的绝对值替换
</code></pre><p>{ for (i = 1; i &lt;= NF; i = i + 1) if ($i &lt; 0) $i = -$i
print
}</p><pre><code>



----

# 1. 基本概念
awk是一种编程语言，用于处理文本文件。它是一种解释型语言，通常用于文本处理和数据提取。

awk程序的基本结构为：
</code></pre><p>pattern { action }</p><pre><code>
其中，`pattern`是一个条件，`action`是一个或多个命令，当`pattern`匹配时，`action`会被执行。

例如，对于如下文件内容：

</code></pre><p>Beth 4.00 0
Dan 3.75 0
Kathy 4.00 10
Mark 5.00 20
Mary 5.50 22
Susie 4.25 18</p><pre><code>如果要打印每位雇员的名字以及他们的报酬 (每小时工资乘以工作时长), 而雇员的工作时长必须大于零：
```bash
awk '$3 &gt; 0 { print $1, $2 * $3 }' file.txt
</code></pre><p>在这里，<code>$3 > 0</code>是一个条件，<code>{ print $1, $2 * $3 }</code>是一个命令，当条件满足时，命令会被执行。</p><p>运行一个awk程序有多种方式，上面我们直接在命令行中输入了awk程序，也可以将awk程序写入一个文件中，然后通过<code>-f</code>选项来执行：</p><pre><code>awk -f progfile file.txt file1.txt
</code></pre><p>文本也可以被放在输出中：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-awk data-lang=awk>{ <span style=color:#66d9ef>print</span> <span style=color:#e6db74>&#34;total pay for&#34;</span>, <span style=color:#f92672>$</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;is&#34;</span>, <span style=color:#f92672>$</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#f92672>$</span><span style=color:#ae81ff>3</span> }
</code></pre></div><h1 id=2-内置变量>2. 内置变量<a hidden class=anchor aria-hidden=true href=#2-内置变量>#</a></h1><ol><li><code>NF</code>, 表示当前行的字段数，例如：<code>print NF, $1, $NF</code>会打印出当前行的字段数、第一个字段和最后一个字段。</li><li><code>NR</code>, 这个变量计算到当前为止，读取到的行的数量，例如：<code>awk '{ print NR, $0 }' file.txt</code>会为文件的每一行加上行号</li></ol><h1 id=3-格式化输出>3. 格式化输出<a hidden class=anchor aria-hidden=true href=#3-格式化输出>#</a></h1><p>awk提供了<code>printf</code>函数来格式化输出，其语法与C语言中的<code>printf</code>函数类似：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-awk data-lang=awk><span style=color:#66d9ef>printf</span>(<span style=color:#e6db74>&#34;format&#34;</span>, <span style=color:#a6e22e>var1</span>, <span style=color:#a6e22e>var2</span>, ...)
</code></pre></div><p>其中<code>format</code>是类似于C风格的printf函数的参数，var1、var2等是要输出的值。使用 printf 不会自动产生空格符或换行符; 用户必须自己创建它们, 不要忘了 <code>\n</code>.</p><h1 id=4-使用模式进行选择>4. 使用模式进行选择<a hidden class=anchor aria-hidden=true href=#4-使用模式进行选择>#</a></h1><ul><li>通过比较操作符进行选择，例如：<code>$3 > 0</code>，<code>$1 == "Beth"</code>等</li><li>通过计算操作符进行选择，例如：<code>$2 * $3 > 10</code>，<code>$1 ~ /Beth/</code>等</li><li>可以使用正则表达式，<code>~</code>匹配，<code>!~</code>不匹配</li><li>可以使用逻辑运算，<code>&&</code>、<code>||</code>、<code>!</code></li><li>可以使用括弧，<code>(condition)</code></li></ul><h1 id=5-begin-与-end>5. BEGIN 与 END<a hidden class=anchor aria-hidden=true href=#5-begin-与-end>#</a></h1><p>特殊的模式 BEGIN 在第一个输入文件的第一行之前被匹配, END 在最后一个输入文件的最后一行被处理
之后匹配. 这个程序使用 BEGIN 打印一个标题</p><pre><code>BEGIN { print &quot;NAME RATE HOURS&quot;; print &quot;&quot; }
{ print }
</code></pre><h1 id=6-计算>6. 计算<a hidden class=anchor aria-hidden=true href=#6-计算>#</a></h1><p>在awk里，不仅可以使用内建变量，还可以自定义变量，用户创建的变量不需要声明就可使用。</p><ul><li>计数，下面的程序用一个变量emp计算工作时长超过15小时的工作人员</li></ul><pre><code>$3 &gt; 15 { emp = emp + 1 }
END { print emp, &quot;employees worked more than 15 hours&quot; }
</code></pre><ul><li>操作文本
这个程序搜索每小时工资最高的雇员:</li></ul><pre><code>$2 &gt; maxrate { maxrate = $2; maxemp = $1 }
END { print &quot;highest hourly rate:&quot;, maxrate, &quot;for&quot;, maxemp }
# highest hourly rate: 5.50 for Mary
</code></pre><p>程序</p><pre><code>{ names = names $1 &quot; &quot; }
END { print names }


</code></pre><p>将所有雇员的名字都收集到一个单独的字符串中, 每一次拼接都是把名字与一个空格符添加到变量 names 的
值的末尾. names 在 END 动作中被打印出来:
Beth Dan Kathy Mark Mary Susie</p><ul><li>内建函数length
length函数返回字符串的长度</li></ul><pre><code>{ print $1, length($1) }
</code></pre><h1 id=7-流程控制语句>7. 流程控制语句<a hidden class=anchor aria-hidden=true href=#7-流程控制语句>#</a></h1><ul><li>If-Else 语句
下面这个程序计算每小时工资多于 $6.00 的雇员的总报酬与平均报酬. 在计算平均数时, 它用到了 if 语
句, 避免用 0 作除数.</li></ul><pre><code>$2 &gt; 6 { n = n + 1; pay = pay + $2 * $3 }
END     { if (n &gt; 0)
            print n, &quot;employees, total pay is&quot;, pay,
                &quot;average pay is&quot;, pay/n
        else
            print &quot;no employees are paid more than $6/hour&quot;
}
</code></pre><ul><li>While 语句
一个 while 含有一个条件判断与一个循环体. 当条件为真时, 循环体执行. 下面这个程序展示了一笔钱在
一个特定的利率下, 其价值如何随着投资时间的增长而增加, 价值计算的公式是 value = amount(1+rate)
years</li></ul><pre><code># interest1 - compute compound interest
# input: amount rate years
# output: compounded value at the end of each year
{ i = 1
    while (i &lt;= $3) {
        printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)
        i = i + 1
    }
}
</code></pre><ul><li>For 语句
大多数循环都包括初始化, 测试, 增值, 而 for 语句将这三者压缩成一行. 这里是前一个计算投资回报的
程序, 不过这次用 for 循环:</li></ul><pre><code># interest2 - compute compound interest
# input: amount rate years
# output: compounded value at the end of each year
{ for (i = 1; i &lt;= $3; i = i + 1)
    printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)
}
</code></pre><h1 id=8-数组>8. 数组<a hidden class=anchor aria-hidden=true href=#8-数组>#</a></h1><p>Awk 提供了数组, 用来存储一组相关的值. 虽然数组给予了 awk 非常可观的力量, 但是我们在这里只展示
一个简单的例子. 下面这个程序按行逆序显示输入数据. 第一个动作将输入行放入数组 line 的下一个元素中;
也就是说, 第一行放入 line[1], 第二行放入 line[2], 依次类推. END 动作用一个 while 循环, 从数组的最
后一个元素开始打印, 一直打印到第一个元素为止:</p><pre><code># reverse - print input in reverse order by line
{ line[NR] = $0 } # remember each input line
    END { i = NR # print lines in reverse order
        while (i &gt; 0) {
            print line[i]
            i = i - 1
    }
}
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/awk/>awk</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=next href=http://yangchnet.github.io/Dessert/posts/tool/vim/><span class=title>Next Page »</span><br><span>vim技巧</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>