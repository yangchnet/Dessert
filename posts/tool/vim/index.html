<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>vim | Linote</title><meta name=keywords content="vim,tools"><meta name=description content="1. 移动技巧 1.1 在同一行移动  首先是基本的hjkl 使用f<chat>来移动到当前行光标之后的字符上，这里可以选择一些出现频率较低的字符，这样有更高的移动效率。在使用f<char>后，，可以使用;来重复上次的查找移动，如果不小心多移动了一个，可以按,回退 使用w,e,b,ge在单词间跳转，其各自含义为：  w 正向移动到下一单词的开头 b 反向移动到当前单词/上一单词的开头 e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾   w、b等是在单词间的跳转，但一个逗号或点也算单词，如果是想把一个用空格分隔的串叫做单词，可以使用W， B， E， gE  1.2 在当前文件内移动  使用*跳转到当前文件内的当前光标下的单词 %跳转到匹配的括号 使用/执行常规搜索，并按n再次执行搜索  1.3 使用位置标记跳转  m<a-z>在当前文件中标记当前位置，mA-Z在全局定义一个mark '<a-zA-Z>跳转到刚才的缓冲区 vim还预置了一些特殊的标记：  ''当前文件中，上次跳转之前的位置； '.上次修改的地方； '^ 上次插入的地方 '<, '> 上次高亮选区的起始和结束位置    1.4 在文件之间移动  <C-o>, <C-i>后退和前进 [count]G 跳转到某个行号, 例如40G跳转至40行 (, )跳转到上一句/下一句的开头, {, }跳转到上一段/下一段的开头 gf 跳转到光标下的文件名 <C-]> 跳转到光标下关键字的定义 改变列表, :changes查看最近的更改，g;和g,跳转到下一个和上一个更改  2. 选择技巧  在可视模式下的选择技巧"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/tool/vim/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="vim"><meta property="og:description" content="1. 移动技巧 1.1 在同一行移动  首先是基本的hjkl 使用f<chat>来移动到当前行光标之后的字符上，这里可以选择一些出现频率较低的字符，这样有更高的移动效率。在使用f<char>后，，可以使用;来重复上次的查找移动，如果不小心多移动了一个，可以按,回退 使用w,e,b,ge在单词间跳转，其各自含义为：  w 正向移动到下一单词的开头 b 反向移动到当前单词/上一单词的开头 e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾   w、b等是在单词间的跳转，但一个逗号或点也算单词，如果是想把一个用空格分隔的串叫做单词，可以使用W， B， E， gE  1.2 在当前文件内移动  使用*跳转到当前文件内的当前光标下的单词 %跳转到匹配的括号 使用/执行常规搜索，并按n再次执行搜索  1.3 使用位置标记跳转  m<a-z>在当前文件中标记当前位置，mA-Z在全局定义一个mark '<a-zA-Z>跳转到刚才的缓冲区 vim还预置了一些特殊的标记：  ''当前文件中，上次跳转之前的位置； '.上次修改的地方； '^ 上次插入的地方 '<, '> 上次高亮选区的起始和结束位置    1.4 在文件之间移动  <C-o>, <C-i>后退和前进 [count]G 跳转到某个行号, 例如40G跳转至40行 (, )跳转到上一句/下一句的开头, {, }跳转到上一段/下一段的开头 gf 跳转到光标下的文件名 <C-]> 跳转到光标下关键字的定义 改变列表, :changes查看最近的更改，g;和g,跳转到下一个和上一个更改  2. 选择技巧  在可视模式下的选择技巧"><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/tool/vim/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-03T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="vim"><meta name=twitter:description content="1. 移动技巧 1.1 在同一行移动  首先是基本的hjkl 使用f<chat>来移动到当前行光标之后的字符上，这里可以选择一些出现频率较低的字符，这样有更高的移动效率。在使用f<char>后，，可以使用;来重复上次的查找移动，如果不小心多移动了一个，可以按,回退 使用w,e,b,ge在单词间跳转，其各自含义为：  w 正向移动到下一单词的开头 b 反向移动到当前单词/上一单词的开头 e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾   w、b等是在单词间的跳转，但一个逗号或点也算单词，如果是想把一个用空格分隔的串叫做单词，可以使用W， B， E， gE  1.2 在当前文件内移动  使用*跳转到当前文件内的当前光标下的单词 %跳转到匹配的括号 使用/执行常规搜索，并按n再次执行搜索  1.3 使用位置标记跳转  m<a-z>在当前文件中标记当前位置，mA-Z在全局定义一个mark '<a-zA-Z>跳转到刚才的缓冲区 vim还预置了一些特殊的标记：  ''当前文件中，上次跳转之前的位置； '.上次修改的地方； '^ 上次插入的地方 '<, '> 上次高亮选区的起始和结束位置    1.4 在文件之间移动  <C-o>, <C-i>后退和前进 [count]G 跳转到某个行号, 例如40G跳转至40行 (, )跳转到上一句/下一句的开头, {, }跳转到上一段/下一段的开头 gf 跳转到光标下的文件名 <C-]> 跳转到光标下关键字的定义 改变列表, :changes查看最近的更改，g;和g,跳转到下一个和上一个更改  2. 选择技巧  在可视模式下的选择技巧"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"vim","item":"http://yangchnet.github.io/Dessert/posts/tool/vim/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"vim","name":"vim","description":"1. 移动技巧 1.1 在同一行移动  首先是基本的hjkl 使用f\u0026lt;chat\u0026gt;来移动到当前行光标之后的字符上，这里可以选择一些出现频率较低的字符，这样有更高的移动效率。在使用f\u0026lt;char\u0026gt;后，，可以使用;来重复上次的查找移动，如果不小心多移动了一个，可以按,回退 使用w,e,b,ge在单词间跳转，其各自含义为：  w 正向移动到下一单词的开头 b 反向移动到当前单词/上一单词的开头 e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾   w、b等是在单词间的跳转，但一个逗号或点也算单词，如果是想把一个用空格分隔的串叫做单词，可以使用W， B， E， gE  1.2 在当前文件内移动  使用*跳转到当前文件内的当前光标下的单词 %跳转到匹配的括号 使用/执行常规搜索，并按n再次执行搜索  1.3 使用位置标记跳转  m\u0026lt;a-z\u0026gt;在当前文件中标记当前位置，mA-Z在全局定义一个mark '\u0026lt;a-zA-Z\u0026gt;跳转到刚才的缓冲区 vim还预置了一些特殊的标记：  ''当前文件中，上次跳转之前的位置； '.上次修改的地方； '^ 上次插入的地方 '\u0026lt;, '\u0026gt; 上次高亮选区的起始和结束位置    1.4 在文件之间移动  \u0026lt;C-o\u0026gt;, \u0026lt;C-i\u0026gt;后退和前进 [count]G 跳转到某个行号, 例如40G跳转至40行 (, )跳转到上一句/下一句的开头, {, }跳转到上一段/下一段的开头 gf 跳转到光标下的文件名 \u0026lt;C-]\u0026gt; 跳转到光标下关键字的定义 改变列表, :changes查看最近的更改，g;和g,跳转到下一个和上一个更改  2. 选择技巧  在可视模式下的选择技巧","keywords":["vim","tools"],"articleBody":"1. 移动技巧 1.1 在同一行移动  首先是基本的hjkl 使用f来移动到当前行光标之后的字符上，这里可以选择一些出现频率较低的字符，这样有更高的移动效率。在使用f后，，可以使用;来重复上次的查找移动，如果不小心多移动了一个，可以按,回退 使用w,e,b,ge在单词间跳转，其各自含义为：  w 正向移动到下一单词的开头 b 反向移动到当前单词/上一单词的开头 e 正向移动到当前单词/下一单词的结尾 ge 反向移动到上一单词的结尾   w、b等是在单词间的跳转，但一个逗号或点也算单词，如果是想把一个用空格分隔的串叫做单词，可以使用W， B， E， gE  1.2 在当前文件内移动  使用*跳转到当前文件内的当前光标下的单词 %跳转到匹配的括号 使用/执行常规搜索，并按n再次执行搜索  1.3 使用位置标记跳转  m在当前文件中标记当前位置，mA-Z在全局定义一个mark '跳转到刚才的缓冲区 vim还预置了一些特殊的标记：  ''当前文件中，上次跳转之前的位置； '.上次修改的地方； '^ 上次插入的地方 ', ' 上次高亮选区的起始和结束位置    1.4 在文件之间移动  , 后退和前进 [count]G 跳转到某个行号, 例如40G跳转至40行 (, )跳转到上一句/下一句的开头, {, }跳转到上一段/下一段的开头 gf 跳转到光标下的文件名  跳转到光标下关键字的定义 改变列表, :changes查看最近的更改，g;和g,跳转到下一个和上一个更改  2. 选择技巧  在可视模式下的选择技巧\n  +v进入列选择模式 当你在一个具有特定结构的文本中时，例如程序源码，可以使用例如vi}来选择当前大括号中的所有字符，类似的：vi), vi\" vi是选择除之外的字符，如果你想选择包括外围大括号}在内的字符，可以使用va}。为了便于记忆，可以把 i 想成“inside”，而把 a 想成“around” 或“all”。   形如i}, a)的选区选择的文本在vim中被称为文本对象，Vim 的文本对象由两个字符组成，第一个字符永远是 i 或是a。我们一般说，以 i 开头的文本对象会选择分隔符内部的文本，而以 a 开头的文本对象则会选择包括分隔符在内的整个文本。这里我们使用文本对象进行选取，但也可以借助文本对象进行编辑。\n 3. 编辑技巧 3.1 使用文本对象进行编辑  d{motion}、c{motion}、y{motion}，其中的{motion}都可以被替换为文本对象。例如：ci\"修改双引号\"之间的文本，yit 命令拷贝标签内的文本，di} 删除大括号}之间的文本   文本对象包含两类，一类是操作分隔符的文本对象，如 i)、i\" 和 it，它们被称为分隔符文本对象；另一类用于操作文本块，如单词、句子和段落，例如iw 在当前单词内，is当前句子，ip当前段落，iW当前字串，当i被替换为a，这类文本对象将多包含一个空格或空行，这被称为范围文本对象。\n 3.x 使用surround.vim操作分隔符文本对象  http://github.com/tpope/vim-surround\n 4. 寄存器操作  在使用y,d进行复制,删除等操作时,默认使用无名寄存器,这就导致一个问题,当你使用yiw复制了一个单词,然后在另一个地方使用diw删除了一个单词之后,再想粘贴刚刚复制的单词,就会发现寄存器被占用了.此时通过一些寄存器操作来获取刚刚复制的单词. 在复制命令之前加上\"来将复制的内容保存到指定寄存器中,例如\"ayiw将当前单词复制到寄存器a中,然后通过\"ap将寄存器a中的内容粘贴到当前位置 复制专用寄存器\"0, yank操作会将内容保存到寄存器0中,例如[\"0]yiw将当前单词复制到寄存器0中,然后通过\"0p将寄存器0中的内容粘贴到当前位置 黑洞寄存器\"_, 通过\"_d删除内容,不会保存到任何寄存器中 系统剪贴板\"+,可从中读取系统剪贴板的内容 :reg命令可以查看所有寄存器的内容   基本操作  %跳转到匹配的括号 f 找到当前行中，在光标之后的字符，在找到字符后，使用;跳转到后一个字符，,跳转到前一个字符 F 找到当前行中，在光标之前的字符 G 跳转到某行 CTRL-e 向下翻滚页面 CTRL-u 向上翻滚半页 CTRL-d 向下翻滚半页 d$删除至行末，dgg删除从光标到文件开头，ggdG删除整个文件，diw删除当前单词，dip删除当前段，ciw替换当前单词，yiw复制当前单词  vim的抽象层 缓冲区 缓冲区有三种不同状态：\n  active 缓冲区显示在窗口\n  hidden 缓冲区不显示，但存在且文件处于打开状态\n  inactive 缓冲区不显示且为空，没有链接任何文件\n  :buffers 查看所有打开的缓冲区\n  :buffer  移动到该缓冲区\n  :bnext或:bn 移动到下一个缓冲区\n  :bprevious或:bp移动到上一个缓冲区\n  :bfirst或:bf移动到第一个\n  :blast或:bl移动到最后一个缓冲区\n  CTRL-^切换到备用缓冲区，在列表中用#显示\n  CTRL-^切换到ID的特定缓冲区，例如75CTRL-^切换到ID为75的缓冲区\n  :bufdo  将命令应用到所有缓冲区\n  并非所有缓冲区但在列表中，使用:buffers!或:ls!列出所有缓冲区\n  :badd  将某文件添加到缓冲区\n  :bdelete  或:bd 1删除缓冲区，1,10bdelete删除id从1到10的缓冲区\n  窗口 windows vim中的窗口是一个用来显示缓冲区内容的空间，当关闭窗口时，缓冲区仍保持打开状态\n :new创建新的窗口 CTRL-W s 水平拆分当前窗口 CTRL-W v 垂直拆分当前窗口 CTRL-W n 水平拆分当前窗口并编辑新文件 CTRL-W ^ 使用备用文件拆分 CTRL-W ^ 使用某ID的缓冲区拆分窗口 CTRL-W 上下左右 将光标移动到另一个窗口 CTRL-W r 旋转窗口，CTRL-W x与下一个窗口互换 CTRL-W = 调整窗口大小，使其适合相同大小的屏幕 CTRL-W - 降低窗口高度，CTRL-W + 增加窗口高度, CTRL-W  减小窗口宽度， CTRL-W  增加窗口宽度 :q 退出当前窗口  Tabs  :help tab-page\n 缓冲区是一个打开的文件，窗口是活动缓冲区的容器。可以将选项卡视为一堆窗口的容器。这样一来，它与标准 IDE 中的选项卡概念非常不同\n :tabnew 或 :tabe 打开新的选项卡 :tabclose或 :tabc 关闭当前选项卡 tabonly 或 tabo 关闭除当前选项卡外的所有传其他选项卡 gt go 到下一个tab gT go 到上远程tab 1gT go到第一个选项卡  参数列表 arglist  :help arglist\n 参数列表用于组织打开的文件，可将其视为缓冲区列表的稳定子集。它遵循以下两个原则:\n arglist 中的每个文件都将位于缓冲区列表中。 缓冲区列表中的某些缓冲区不会出现在 arglist 中。  运行 Vim 时要打开的文件（例如执行 vim file1 file2 file3 ）将自动添加到 arglist 中\n :args 显示arglist :argadd 将文件添加到arglist argdo 对arglist中的每个文件执行命令 :next 移动到arglist中的下一个文件 :prev 移动到arglist中的上一个文件 :first 移动到arglist中的第一个文件  跳跃  :jumps\n  CTRL-o 转到上一个光标位置 CTRL-i 转到下一个光标位置   :help jump-motions :help jumplist :help changelist\n  [m 移动到方法的开头 ]m 移动到方法的末尾  更改列表 每次插入内容（使用 INSERT 模式）时，光标的位置都会保存在更改列表中。\n g; 跳转到下一个更改 g, 跳转到上一个更改  重复  :help single-repeat\n  . 重复上一次更改 @: 重复执行上次的命令  录制宏  `q`` - 开始在寄存器中记录击键。您可以将寄存器视为内存中的一个位置，也可以将其视为剪贴板。 您接下来要执行的每次击键都将被保存。 q - 停止录制。 @ - 执行您录制的击键。  命令行窗口  :help cmdline-window\n  q: 打开命令行历史记录 q/ 或 q? 打开搜索历史记录 CTRL+f 在命令行模式下打开命令行历史记录 :history : 命令行历史记录 :history / 或 :history ?搜索记录  搜索与替换 单个文件搜索  基本搜索，在normal模式下使用/然后键入要搜索的pattern，这将向前搜索，结果将在文件中突出展示；?向后搜索 //使用上次的模式搜索 :set hlsearch 设置搜索结果高亮 * 搜索当前光标下的单词 g*搜索部分单词  多个文件搜索  :help :vimgrep\n  :vimgrep  **/*.php 在*.php文件中搜索。这将使用搜索结果填充quickfix列表，使用:cnext或:cn、:cprev或:cp来查看结果，也可以通过:copen快速打开修复窗口并浏览结果 :vimgrep pattern * 在工作目录中的每个文件搜索模式  使用grep搜索  可通过grepprg设置要使用的外部搜索程序\n  :help :grep\n  :grep  * 搜索工作目录中出现的每个pattern :grep  a.txt b.txt 在这两个文件中搜索出现的pattern  替换  :help :substitute\n  s/pattern/replace/g 在当前行上使用“replace”替换“pattern”， 这里的s代表substitute，g表示全局 %s/pattern/replace/g 在当前文件中用“replace”替换“pattern” :s/pat\\/tern/replace/g 转义以匹配pat/tern :s#pat\\tern#replace#g 也可以使用其他分隔符 :s/pattern/replace/ 10 将从当前开始的10行中的pattern替换为replace :1,10s/pattern/replace/ 将文件前10行中的pattern替换为replace  一些标志的含意：\u0026使用上一个替换命令中的标志；c要求用户确认每个替换；g替换每行中出现的内容；i不区分大小写；I区分大小写；n只报告匹配次数\n逐个替换  使用/执行常规搜索 使用cgn替换当前单词 使用n转到下一个结果 使用.重复上次的替换或使用n跳转到下一个结果  在多个文件中查找和替换  可通过稳定的arglist来作为可以修改的文件的列表\n 例如，要替换每个html和twig文件中的匹配项，键入如下命令\n :arg *.html使用当前工作目录中的所有html文件填充arglist，然后编辑第一个文件 :argadd *.twig 将twig文件添加到arglist :argdo %s/pattern/replace/ge | update 将arglist中的每个文件中出现的pattern替换为replace :bufdo %s/pattern/replace/ge | update 缓冲区中替换  通过快速修复列表替换\n :grep pattern **/*.html 查找子目录中的html文件 :cdo s/blink/div/g | update替换  g  gf编辑位于光标下文件路径中的文件 gx打开位于光标下文件路径中的文件 gi移动到上次插入并切换到INSERT模式 gv启动VISUAL模式并使用在上次VISUAL模式下所做的选择 gn选择上次搜索的匹配项 gI在行首插入文本，无论第一个字符是什么 ga 以十进制、十六进制或八进制打印光标下字符的 a scii 值 gu 使用动作的小写（例如， guiw ） gU 使用动作的大写（例如， gUiw ）  Range 范围  .表示当前行 $表示当前缓冲区最后一行 %表示整个文件 * 表示在上一个VISUAL模式下所做的最后选择 '，'分别表示选择的第一行和最后一行  例如，结合range与d\n ：1,40d 删除1-40行 :2,$d 删除从第二行到最后 .,$d 删除从当前行到最后 %d删除每一行  QuickFix 和文件列表 TODO\n全局命令 基本形式： :g/pattern/command，其语义为：对全局的pattern执行command命令\n例如，删除当前缓冲区中所有包含“useless”单词的行： :g/useless/d\n :norm命令，可以在命令模式下执行normal模式中的一些指令，例如：:norm daw将删除光标下的单词 :q\n 将normal模式命令与全局命令结合起来： :g/useless/norm gu$ 这将把每个包含useless的行小写\nmarks 书签  normal模式下，使用m当前缓冲区，mA-Z全局缓冲区来定义一个mark normal模式下，使用'跳转到刚才的缓冲区 :marks 显示标记集 :marks 显示一些特定标记 :delmarks  or :delm 删除标记 :delmarks!或delm! 删除a-z范围内所有标记 :marks  显示两个标记和  排序  :sort或:sor根据范围对行进行排序 :sort!或:sor!倒序  还可以为sort添加一些选项\n i忽略大小写 n根据行中的第一个小数排序 f根据行中的第一个浮点数排序 /pattern/根据匹配后的情况排序 r与/pattern/结合，根据匹配模式排序  例如：对csv，根据第二列对每一行进行排序：:sort /[^,]*,/\n","wordCount":"470","inLanguage":"en","datePublished":"2024-07-03T00:00:00Z","dateModified":"2024-07-03T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/tool/vim/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>vim</h1><div class=post-meta><span title="2024-07-03 00:00:00 +0000 UTC">July 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e7%a7%bb%e5%8a%a8%e6%8a%80%e5%b7%a7 aria-label="1. 移动技巧">1. 移动技巧</a><ul><li><a href=#11-%e5%9c%a8%e5%90%8c%e4%b8%80%e8%a1%8c%e7%a7%bb%e5%8a%a8 aria-label="1.1 在同一行移动">1.1 在同一行移动</a></li><li><a href=#12-%e5%9c%a8%e5%bd%93%e5%89%8d%e6%96%87%e4%bb%b6%e5%86%85%e7%a7%bb%e5%8a%a8 aria-label="1.2 在当前文件内移动">1.2 在当前文件内移动</a></li><li><a href=#13-%e4%bd%bf%e7%94%a8%e4%bd%8d%e7%bd%ae%e6%a0%87%e8%ae%b0%e8%b7%b3%e8%bd%ac aria-label="1.3 使用位置标记跳转">1.3 使用位置标记跳转</a></li><li><a href=#14-%e5%9c%a8%e6%96%87%e4%bb%b6%e4%b9%8b%e9%97%b4%e7%a7%bb%e5%8a%a8 aria-label="1.4 在文件之间移动">1.4 在文件之间移动</a></li></ul></li><li><a href=#2-%e9%80%89%e6%8b%a9%e6%8a%80%e5%b7%a7 aria-label="2. 选择技巧">2. 选择技巧</a></li><li><a href=#3-%e7%bc%96%e8%be%91%e6%8a%80%e5%b7%a7 aria-label="3. 编辑技巧">3. 编辑技巧</a><ul><li><a href=#31-%e4%bd%bf%e7%94%a8%e6%96%87%e6%9c%ac%e5%af%b9%e8%b1%a1%e8%bf%9b%e8%a1%8c%e7%bc%96%e8%be%91 aria-label="3.1 使用文本对象进行编辑">3.1 使用文本对象进行编辑</a></li><li><a href=#3x-%e4%bd%bf%e7%94%a8surroundvim%e6%93%8d%e4%bd%9c%e5%88%86%e9%9a%94%e7%ac%a6%e6%96%87%e6%9c%ac%e5%af%b9%e8%b1%a1 aria-label="3.x 使用surround.vim操作分隔符文本对象">3.x 使用surround.vim操作分隔符文本对象</a></li></ul></li><li><a href=#4-%e5%af%84%e5%ad%98%e5%99%a8%e6%93%8d%e4%bd%9c aria-label="4. 寄存器操作">4. 寄存器操作</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c aria-label=基本操作>基本操作</a></li><li><a href=#vim%e7%9a%84%e6%8a%bd%e8%b1%a1%e5%b1%82 aria-label=vim的抽象层>vim的抽象层</a><ul><li><a href=#%e7%bc%93%e5%86%b2%e5%8c%ba aria-label=缓冲区>缓冲区</a></li><li><a href=#%e7%aa%97%e5%8f%a3-windows aria-label="窗口 windows">窗口 windows</a></li><li><a href=#tabs aria-label=Tabs>Tabs</a></li><li><a href=#%e5%8f%82%e6%95%b0%e5%88%97%e8%a1%a8-arglist aria-label="参数列表 arglist">参数列表 arglist</a></li></ul></li><li><a href=#%e8%b7%b3%e8%b7%83 aria-label=跳跃>跳跃</a></li><li><a href=#%e6%9b%b4%e6%94%b9%e5%88%97%e8%a1%a8 aria-label=更改列表>更改列表</a></li><li><a href=#%e9%87%8d%e5%a4%8d aria-label=重复>重复</a></li><li><a href=#%e5%bd%95%e5%88%b6%e5%ae%8f aria-label=录制宏>录制宏</a></li><li><a href=#%e5%91%bd%e4%bb%a4%e8%a1%8c%e7%aa%97%e5%8f%a3 aria-label=命令行窗口>命令行窗口</a></li><li><a href=#%e6%90%9c%e7%b4%a2%e4%b8%8e%e6%9b%bf%e6%8d%a2 aria-label=搜索与替换>搜索与替换</a><ul><li><a href=#%e5%8d%95%e4%b8%aa%e6%96%87%e4%bb%b6%e6%90%9c%e7%b4%a2 aria-label=单个文件搜索>单个文件搜索</a></li><li><a href=#%e5%a4%9a%e4%b8%aa%e6%96%87%e4%bb%b6%e6%90%9c%e7%b4%a2 aria-label=多个文件搜索>多个文件搜索</a></li><li><a href=#%e4%bd%bf%e7%94%a8grep%e6%90%9c%e7%b4%a2 aria-label=使用grep搜索>使用grep搜索</a></li><li><a href=#%e6%9b%bf%e6%8d%a2 aria-label=替换>替换</a><ul><li><a href=#%e9%80%90%e4%b8%aa%e6%9b%bf%e6%8d%a2 aria-label=逐个替换>逐个替换</a></li></ul></li><li><a href=#%e5%9c%a8%e5%a4%9a%e4%b8%aa%e6%96%87%e4%bb%b6%e4%b8%ad%e6%9f%a5%e6%89%be%e5%92%8c%e6%9b%bf%e6%8d%a2 aria-label=在多个文件中查找和替换>在多个文件中查找和替换</a></li></ul></li><li><a href=#g aria-label=g><code>g</code></a></li><li><a href=#range-%e8%8c%83%e5%9b%b4 aria-label="Range 范围">Range 范围</a></li><li><a href=#quickfix-%e5%92%8c%e6%96%87%e4%bb%b6%e5%88%97%e8%a1%a8 aria-label="QuickFix 和文件列表">QuickFix 和文件列表</a></li><li><a href=#%e5%85%a8%e5%b1%80%e5%91%bd%e4%bb%a4 aria-label=全局命令>全局命令</a></li><li><a href=#marks-%e4%b9%a6%e7%ad%be aria-label="marks 书签">marks 书签</a></li><li><a href=#%e6%8e%92%e5%ba%8f aria-label=排序>排序</a></li></ul></div></details></div><div class=post-content><h1 id=1-移动技巧>1. 移动技巧<a hidden class=anchor aria-hidden=true href=#1-移动技巧>#</a></h1><h2 id=11-在同一行移动>1.1 在同一行移动<a hidden class=anchor aria-hidden=true href=#11-在同一行移动>#</a></h2><ul><li>首先是基本的hjkl</li><li>使用<code>f&lt;chat></code>来移动到当前行光标之后的字符上，这里可以选择一些出现频率较低的字符，这样有更高的移动效率。在使用<code>f&lt;char></code>后，，可以使用<code>;</code>来重复上次的查找移动，如果不小心多移动了一个，可以按<code>,</code>回退</li><li>使用<code>w</code>,<code>e</code>,<code>b</code>,<code>ge</code>在单词间跳转，其各自含义为：<ul><li><code>w</code> 正向移动到下一单词的开头</li><li><code>b</code> 反向移动到当前单词/上一单词的开头</li><li><code>e</code> 正向移动到当前单词/下一单词的结尾</li><li><code>ge</code> 反向移动到上一单词的结尾</li></ul></li><li><code>w</code>、<code>b</code>等是在单词间的跳转，但一个逗号或点也算单词，如果是想把一个用空格分隔的串叫做单词，可以使用<code>W</code>， <code>B</code>， <code>E</code>， <code>gE</code></li></ul><h2 id=12-在当前文件内移动>1.2 在当前文件内移动<a hidden class=anchor aria-hidden=true href=#12-在当前文件内移动>#</a></h2><ul><li>使用<code>*</code>跳转到当前文件内的当前光标下的单词</li><li><code>%</code>跳转到匹配的括号</li><li>使用<code>/</code>执行常规搜索，并按<code>n</code>再次执行搜索</li></ul><h2 id=13-使用位置标记跳转>1.3 使用位置标记跳转<a hidden class=anchor aria-hidden=true href=#13-使用位置标记跳转>#</a></h2><ul><li><code>m&lt;a-z></code>在当前文件中标记当前位置，<code>mA-Z</code>在全局定义一个mark</li><li><code>'&lt;a-zA-Z></code>跳转到刚才的缓冲区</li><li>vim还预置了一些特殊的标记：<ul><li><code>''</code>当前文件中，上次跳转之前的位置；</li><li><code>'.</code>上次修改的地方； <code>'^</code> 上次插入的地方</li><li><code>'&lt;</code>, <code>'></code> 上次高亮选区的起始和结束位置</li></ul></li></ul><h2 id=14-在文件之间移动>1.4 在文件之间移动<a hidden class=anchor aria-hidden=true href=#14-在文件之间移动>#</a></h2><ul><li><code>&lt;C-o></code>, <code>&lt;C-i></code>后退和前进</li><li><code>[count]G</code> 跳转到某个行号, 例如<code>40G</code>跳转至40行</li><li><code>(</code>, <code>)</code>跳转到上一句/下一句的开头, <code>{</code>, <code>}</code>跳转到上一段/下一段的开头</li><li><code>gf</code> 跳转到光标下的文件名</li><li><code>&lt;C-]></code> 跳转到光标下关键字的定义</li><li>改变列表, <code>:changes</code>查看最近的更改，<code>g;</code>和<code>g,</code>跳转到下一个和上一个更改</li></ul><h1 id=2-选择技巧>2. 选择技巧<a hidden class=anchor aria-hidden=true href=#2-选择技巧>#</a></h1><blockquote><p>在可视模式下的选择技巧</p></blockquote><ul><li><code>&lt;CR>+v</code>进入列选择模式</li><li>当你在一个具有特定结构的文本中时，例如程序源码，可以使用例如<code>vi}</code>来选择当前大括号中的所有字符，类似的：<code>vi)</code>, <code>vi"</code></li><li><code>vi&lt;char></code>是选择除之外的字符，如果你想选择包括外围大括号}在内的字符，可以使用<code>va}</code>。为了便于记忆，可以把 i 想成“inside”，而把 a 想成“around” 或“all”。</li></ul><blockquote><p>形如<code>i}</code>, <code>a)</code>的选区选择的文本在vim中被称为<code>文本对象</code>，Vim 的文本对象由两个字符组成，第一个字符永远是 i 或是a。我们一般说，以 i 开头的文本对象会选择分隔符内部的文本，而以 a 开头的文本对象则会选择包括分隔符在内的整个文本。这里我们使用文本对象进行选取，但也可以借助文本对象进行编辑。</p></blockquote><h1 id=3-编辑技巧>3. 编辑技巧<a hidden class=anchor aria-hidden=true href=#3-编辑技巧>#</a></h1><h2 id=31-使用文本对象进行编辑>3.1 使用文本对象进行编辑<a hidden class=anchor aria-hidden=true href=#31-使用文本对象进行编辑>#</a></h2><ul><li><code>d{motion}</code>、<code>c{motion}</code>、<code>y{motion}</code>，其中的{motion}都可以被替换为文本对象。例如：<code>ci"</code>修改双引号"之间的文本，<code>yit</code> 命令拷贝标签内的文本，<code>di}</code> 删除大括号}之间的文本</li></ul><blockquote><p>文本对象包含两类，一类是操作分隔符的文本对象，如 <code>i)</code>、<code>i"</code> 和 <code>it</code>，它们被称为<code>分隔符文本对象</code>；另一类用于操作文本块，如单词、句子和段落，例如<code>iw</code> 在当前单词内，<code>is</code>当前句子，<code>ip</code>当前段落，<code>iW</code>当前字串，当<code>i</code>被替换为<code>a</code>，这类文本对象将多包含一个空格或空行，这被称为<code>范围文本对象</code>。</p></blockquote><h2 id=3x-使用surroundvim操作分隔符文本对象>3.x 使用surround.vim操作分隔符文本对象<a hidden class=anchor aria-hidden=true href=#3x-使用surroundvim操作分隔符文本对象>#</a></h2><blockquote><p><a href=http://github.com/tpope/vim-surround>http://github.com/tpope/vim-surround</a></p></blockquote><h1 id=4-寄存器操作>4. 寄存器操作<a hidden class=anchor aria-hidden=true href=#4-寄存器操作>#</a></h1><ul><li>在使用<code>y</code>,<code>d</code>进行复制,删除等操作时,默认使用<code>无名寄存器</code>,这就导致一个问题,当你使用<code>yiw</code>复制了一个单词,然后在另一个地方使用<code>diw</code>删除了一个单词之后,再想粘贴刚刚复制的单词,就会发现寄存器被占用了.此时通过一些寄存器操作来获取刚刚复制的单词.</li><li>在复制命令之前加上<code>"&lt;a_z></code>来将复制的内容保存到指定寄存器中,例如<code>"ayiw</code>将当前单词复制到寄存器a中,然后通过<code>"ap</code>将寄存器a中的内容粘贴到当前位置</li><li>复制专用寄存器<code>"0</code>, yank操作会将内容保存到寄存器0中,例如<code>["0]yiw</code>将当前单词复制到寄存器0中,然后通过<code>"0p</code>将寄存器0中的内容粘贴到当前位置</li><li>黑洞寄存器<code>"_</code>, 通过<code>"_d</code>删除内容,不会保存到任何寄存器中</li><li>系统剪贴板<code>"+</code>,可从中读取系统剪贴板的内容</li><li><code>:reg</code>命令可以查看所有寄存器的内容</li></ul><hr><h1 id=基本操作>基本操作<a hidden class=anchor aria-hidden=true href=#基本操作>#</a></h1><ul><li><code>%</code>跳转到匹配的括号</li><li><code>f&lt;character></code> 找到当前行中，在光标之后的字符，在找到字符后，使用<code>;</code>跳转到后一个字符，<code>,</code>跳转到前一个字符</li><li><code>F&lt;character></code> 找到当前行中，在光标之前的字符</li><li><code>&lt;line_number>G</code> 跳转到某行</li><li><code>CTRL-e</code> 向下翻滚页面</li><li><code>CTRL-u</code> 向上翻滚半页</li><li><code>CTRL-d</code> 向下翻滚半页</li><li><code>d$</code>删除至行末，<code>dgg</code>删除从光标到文件开头，<code>ggdG</code>删除整个文件，<code>diw</code>删除当前单词，<code>dip</code>删除当前段，<code>ciw</code>替换当前单词，<code>yiw</code>复制当前单词</li></ul><h1 id=vim的抽象层>vim的抽象层<a hidden class=anchor aria-hidden=true href=#vim的抽象层>#</a></h1><h2 id=缓冲区>缓冲区<a hidden class=anchor aria-hidden=true href=#缓冲区>#</a></h2><p>缓冲区有三种不同状态：</p><ul><li><p><code>active</code> 缓冲区显示在窗口</p></li><li><p><code>hidden</code> 缓冲区不显示，但存在且文件处于打开状态</p></li><li><p><code>inactive</code> 缓冲区不显示且为空，没有链接任何文件</p></li><li><p><code>:buffers</code> 查看所有打开的缓冲区</p></li><li><p><code>:buffer &lt;ID_or_name></code> 移动到该缓冲区</p></li><li><p><code>:bnext</code>或<code>:bn</code> 移动到下一个缓冲区</p></li><li><p><code>:bprevious</code>或<code>:bp</code>移动到上一个缓冲区</p></li><li><p><code>:bfirst</code>或<code>:bf</code>移动到第一个</p></li><li><p><code>:blast</code>或<code>:bl</code>移动到最后一个缓冲区</p></li><li><p><code>CTRL-^</code>切换到备用缓冲区，在列表中用<code>#</code>显示</p></li><li><p><code>&lt;ID>CTRL-^</code>切换到ID的特定缓冲区，例如<code>75CTRL-^</code>切换到ID为75的缓冲区</p></li><li><p><code>:bufdo &lt;command></code> 将命令应用到所有缓冲区</p></li><li><p>并非所有缓冲区但在列表中，使用<code>:buffers!</code>或<code>:ls!</code>列出所有缓冲区</p></li><li><p><code>:badd &lt;filename></code> 将某文件添加到缓冲区</p></li><li><p><code>:bdelete &lt;ID_or_name></code> 或<code>:bd 1</code>删除缓冲区，<code>1,10bdelete</code>删除id从1到10的缓冲区</p></li></ul><h2 id=窗口-windows>窗口 windows<a hidden class=anchor aria-hidden=true href=#窗口-windows>#</a></h2><p>vim中的窗口是一个用来显示缓冲区内容的空间，当关闭窗口时，缓冲区仍保持打开状态</p><ul><li><code>:new</code>创建新的窗口</li><li><code>CTRL-W s</code> 水平拆分当前窗口</li><li><code>CTRL-W v</code> 垂直拆分当前窗口</li><li><code>CTRL-W n</code> 水平拆分当前窗口并编辑新文件</li><li><code>CTRL-W ^</code> 使用备用文件拆分</li><li><code>&lt;buffer_ID>CTRL-W ^</code> 使用某ID的缓冲区拆分窗口</li><li><code>CTRL-W 上下左右</code> 将光标移动到另一个窗口</li><li><code>CTRL-W r</code> 旋转窗口，<code>CTRL-W x</code>与下一个窗口互换</li><li><code>CTRL-W =</code> 调整窗口大小，使其适合相同大小的屏幕</li><li><code>CTRL-W -</code> 降低窗口高度，<code>CTRL-W +</code> 增加窗口高度, <code>CTRL-W &lt;</code> 减小窗口宽度， <code>CTRL-W ></code> 增加窗口宽度</li><li><code>:q</code> 退出当前窗口</li></ul><h2 id=tabs>Tabs<a hidden class=anchor aria-hidden=true href=#tabs>#</a></h2><blockquote><p><code>:help tab-page</code></p></blockquote><p>缓冲区是一个打开的文件，窗口是活动缓冲区的容器。可以将选项卡视为一堆窗口的容器。这样一来，它与标准 IDE 中的选项卡概念非常不同</p><ul><li><code>:tabnew</code> 或 <code>:tabe</code> 打开新的选项卡</li><li><code>:tabclose</code>或 <code>:tabc</code> 关闭当前选项卡</li><li><code>tabonly</code> 或 <code>tabo</code> 关闭除当前选项卡外的所有传其他选项卡</li><li><code>gt</code> go 到下一个tab</li><li><code>gT</code> go 到上远程tab</li><li><code>1gT</code> go到第一个选项卡</li></ul><h2 id=参数列表-arglist>参数列表 arglist<a hidden class=anchor aria-hidden=true href=#参数列表-arglist>#</a></h2><blockquote><p><code>:help arglist</code></p></blockquote><p>参数列表用于组织打开的文件，可将其视为缓冲区列表的稳定子集。它遵循以下两个原则:</p><ul><li>arglist 中的每个文件都将位于缓冲区列表中。</li><li>缓冲区列表中的某些缓冲区不会出现在 arglist 中。</li></ul><p>运行 Vim 时要打开的文件（例如执行 <code>vim file1 file2 file3</code> ）将自动添加到 arglist 中</p><ul><li><code>:args</code> 显示arglist</li><li><code>:argadd</code> 将文件添加到arglist</li><li><code>argdo</code> 对arglist中的每个文件执行命令</li><li><code>:next</code> 移动到arglist中的下一个文件</li><li><code>:prev</code> 移动到arglist中的上一个文件</li><li><code>:first</code> 移动到arglist中的第一个文件</li></ul><h1 id=跳跃>跳跃<a hidden class=anchor aria-hidden=true href=#跳跃>#</a></h1><blockquote><p><code>:jumps</code></p></blockquote><ul><li><code>CTRL-o</code> 转到上一个光标位置</li><li><code>CTRL-i</code> 转到下一个光标位置</li></ul><blockquote><p>:help jump-motions
:help jumplist
:help changelist</p></blockquote><ul><li><code>[m</code> 移动到方法的开头</li><li><code>]m</code> 移动到方法的末尾</li></ul><h1 id=更改列表>更改列表<a hidden class=anchor aria-hidden=true href=#更改列表>#</a></h1><p>每次插入内容（使用 INSERT 模式）时，光标的位置都会保存在更改列表中。</p><ul><li><code>g;</code> 跳转到下一个更改</li><li><code>g,</code> 跳转到上一个更改</li></ul><h1 id=重复>重复<a hidden class=anchor aria-hidden=true href=#重复>#</a></h1><blockquote><p>:help single-repeat</p></blockquote><ul><li><code>.</code> 重复上一次更改</li><li><code>@:</code> 重复执行上次的命令</li></ul><h1 id=录制宏>录制宏<a hidden class=anchor aria-hidden=true href=#录制宏>#</a></h1><ul><li>`q&lt;lowecase_letter>`` - 开始在寄存器中记录击键。您可以将寄存器视为内存中的一个位置，也可以将其视为剪贴板。</li><li>您接下来要执行的每次击键都将被保存。</li><li><code>q</code> - 停止录制。</li><li><code>@&lt;lowercase_letter></code> - 执行您录制的击键。</li></ul><h1 id=命令行窗口>命令行窗口<a hidden class=anchor aria-hidden=true href=#命令行窗口>#</a></h1><blockquote><p>:help cmdline-window</p></blockquote><ul><li><code>q:</code> 打开命令行历史记录</li><li><code>q/</code> 或 <code>q?</code> 打开搜索历史记录</li><li><code>CTRL+f</code> 在命令行模式下打开命令行历史记录</li><li><code>:history :</code> 命令行历史记录</li><li><code>:history /</code> 或 <code>:history ?</code>搜索记录</li></ul><h1 id=搜索与替换>搜索与替换<a hidden class=anchor aria-hidden=true href=#搜索与替换>#</a></h1><h2 id=单个文件搜索>单个文件搜索<a hidden class=anchor aria-hidden=true href=#单个文件搜索>#</a></h2><ul><li>基本搜索，在normal模式下使用<code>/</code>然后键入要搜索的pattern，这将向前搜索，结果将在文件中突出展示；<code>?</code>向后搜索</li><li><code>//</code>使用上次的模式搜索</li><li><code>:set hlsearch</code> 设置搜索结果高亮</li><li><code>*</code> 搜索当前光标下的单词</li><li><code>g*</code>搜索部分单词</li></ul><h2 id=多个文件搜索>多个文件搜索<a hidden class=anchor aria-hidden=true href=#多个文件搜索>#</a></h2><blockquote><p>:help :vimgrep</p></blockquote><ul><li><code>:vimgrep &lt;pattern> **/*.php</code> 在*.php文件中搜索。这将使用搜索结果填充quickfix列表，使用<code>:cnext</code>或<code>:cn</code>、<code>:cprev</code>或<code>:cp</code>来查看结果，也可以通过<code>:copen</code>快速打开修复窗口并浏览结果</li><li><code>:vimgrep pattern *</code> 在工作目录中的每个文件搜索模式</li></ul><h2 id=使用grep搜索>使用grep搜索<a hidden class=anchor aria-hidden=true href=#使用grep搜索>#</a></h2><blockquote><p>可通过<code>grepprg</code>设置要使用的外部搜索程序</p></blockquote><blockquote><p>:help :grep</p></blockquote><ul><li><code>:grep &lt;pattern> *</code> 搜索工作目录中出现的每个pattern</li><li><code>:grep &lt;pattern> a.txt b.txt</code> 在这两个文件中搜索出现的pattern</li></ul><h2 id=替换>替换<a hidden class=anchor aria-hidden=true href=#替换>#</a></h2><blockquote><p>:help :substitute</p></blockquote><ul><li><code>s/pattern/replace/g</code> 在当前行上使用“replace”替换“pattern”， 这里的<code>s</code>代表substitute，<code>g</code>表示全局</li><li><code>%s/pattern/replace/g</code> 在当前文件中用“replace”替换“pattern”</li><li><code>:s/pat\/tern/replace/g</code> 转义以匹配<code>pat/tern</code></li><li><code>:s#pat\tern#replace#g</code> 也可以使用其他分隔符</li><li><code>:s/pattern/replace/ 10</code> 将从当前开始的10行中的pattern替换为replace</li><li><code>:1,10s/pattern/replace/</code> 将文件前10行中的pattern替换为replace</li></ul><p>一些标志的含意：<code>&</code>使用上一个替换命令中的标志；<code>c</code>要求用户确认每个替换；<code>g</code>替换每行中出现的内容；<code>i</code>不区分大小写；<code>I</code>区分大小写；<code>n</code>只报告匹配次数</p><h3 id=逐个替换>逐个替换<a hidden class=anchor aria-hidden=true href=#逐个替换>#</a></h3><ul><li>使用<code>/</code>执行常规搜索</li><li>使用<code>cgn</code>替换当前单词</li><li>使用<code>n</code>转到下一个结果</li><li>使用<code>.</code>重复上次的替换或使用<code>n</code>跳转到下一个结果</li></ul><h2 id=在多个文件中查找和替换>在多个文件中查找和替换<a hidden class=anchor aria-hidden=true href=#在多个文件中查找和替换>#</a></h2><blockquote><p>可通过稳定的arglist来作为可以修改的文件的列表</p></blockquote><p>例如，要替换每个html和twig文件中的匹配项，键入如下命令</p><ul><li><code>:arg *.html</code>使用当前工作目录中的所有html文件填充arglist，然后编辑第一个文件</li><li><code>:argadd *.twig</code> 将twig文件添加到arglist</li><li><code>:argdo %s/pattern/replace/ge | update</code> 将arglist中的每个文件中出现的pattern替换为replace</li><li><code>:bufdo %s/pattern/replace/ge | update</code> 缓冲区中替换</li></ul><p>通过快速修复列表替换</p><ul><li><code>:grep pattern **/*.html</code> 查找子目录中的html文件</li><li><code>:cdo s/blink/div/g | update</code>替换</li></ul><h1 id=g><code>g</code><a hidden class=anchor aria-hidden=true href=#g>#</a></h1><ul><li><code>gf</code>编辑位于光标下文件路径中的文件</li><li><code>gx</code>打开位于光标下文件路径中的文件</li><li><code>gi</code>移动到上次插入并切换到INSERT模式</li><li><code>gv</code>启动VISUAL模式并使用在上次VISUAL模式下所做的选择</li><li><code>gn</code>选择上次搜索的匹配项</li><li><code>gI</code>在行首插入文本，无论第一个字符是什么</li><li><code>ga</code> 以十进制、十六进制或八进制打印光标下字符的 a scii 值</li><li><code>gu</code> 使用动作的小写（例如， guiw ）</li><li><code>gU</code> 使用动作的大写（例如， gUiw ）</li></ul><h1 id=range-范围>Range 范围<a hidden class=anchor aria-hidden=true href=#range-范围>#</a></h1><ul><li><code>.</code>表示当前行</li><li><code>$</code>表示当前缓冲区最后一行</li><li><code>%</code>表示整个文件</li><li><code>*</code> 表示在上一个VISUAL模式下所做的最后选择</li><li><code>'&lt;</code>，<code>'></code>分别表示选择的第一行和最后一行</li></ul><p>例如，结合range与<code>d</code></p><ul><li><code>：1,40d</code> 删除1-40行</li><li><code>:2,$d</code> 删除从第二行到最后</li><li><code>.,$d</code> 删除从当前行到最后</li><li><code>%d</code>删除每一行</li></ul><h1 id=quickfix-和文件列表>QuickFix 和文件列表<a hidden class=anchor aria-hidden=true href=#quickfix-和文件列表>#</a></h1><p>TODO</p><h1 id=全局命令>全局命令<a hidden class=anchor aria-hidden=true href=#全局命令>#</a></h1><p>基本形式： <code>:g/pattern/command</code>，其语义为：对全局的pattern执行command命令</p><p>例如，删除当前缓冲区中所有包含“useless”单词的行： <code>:g/useless/d</code></p><blockquote><p><code>:norm</code>命令，可以在命令模式下执行normal模式中的一些指令，例如：<code>:norm daw</code>将删除光标下的单词
:q</p></blockquote><p>将normal模式命令与全局命令结合起来：
<code>:g/useless/norm gu$</code> 这将把每个包含useless的行小写</p><h1 id=marks-书签>marks 书签<a hidden class=anchor aria-hidden=true href=#marks-书签>#</a></h1><ul><li>normal模式下，使用<code>m&lt;a-z></code>当前缓冲区，<code>mA-Z</code>全局缓冲区来定义一个mark</li><li>normal模式下，使用<code>'&lt;a-z></code>跳转到刚才的缓冲区</li><li><code>:marks</code> 显示标记集</li><li><code>:marks &lt;marks></code>显示一些特定标记</li><li><code>:delmarks &lt;mark></code> or <code>:delm &lt;mark></code>删除标记</li><li><code>:delmarks!</code>或<code>delm!</code> 删除a-z范围内所有标记</li><li><code>:marks &lt;></code> 显示两个标记<code>&lt;</code>和<code>></code></li></ul><h1 id=排序>排序<a hidden class=anchor aria-hidden=true href=#排序>#</a></h1><ul><li><code>:sort</code>或<code>:sor</code>根据范围对行进行排序</li><li><code>:sort!</code>或<code>:sor!</code>倒序</li></ul><p>还可以为sort添加一些选项</p><ul><li><code>i</code>忽略大小写</li><li><code>n</code>根据行中的第一个小数排序</li><li><code>f</code>根据行中的第一个浮点数排序</li><li><code>/pattern/</code>根据匹配后的情况排序</li><li><code>r</code>与<code>/pattern/</code>结合，根据匹配模式排序</li></ul><p>例如：对csv，根据第二列对每一行进行排序：<code>:sort /[^,]*,/</code></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/vim/>vim</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/tools/>tools</a></li></ul><nav class=paginav><a class=next href=http://yangchnet.github.io/Dessert/posts/container/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E7%AF%87%E4%B8%80%E5%8D%95%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88/><span class=title>Next Page »</span><br><span>容器网络篇一：单机网络方案</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>