<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>概览MySQL篇四：主备与高可用 | Linote</title><meta name=keywords content="MySQL"><meta name=description content="极客时间《MySQL实战45讲》笔记
 主备的基本原理 在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。
当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。
那么从状态1切换到状态2的内部流程是什么样的？
备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：
 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。 sql_thread 读取中转日志，解析出日志里的命令，并执行。  binlog 的三种格式对比 主备复制依赖于bin log，那么bin log中是什么内容。"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A6%82%E8%A7%88mysql%E7%AF%87%E5%9B%9B%E4%B8%BB%E5%A4%87%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="概览MySQL篇四：主备与高可用"><meta property="og:description" content="极客时间《MySQL实战45讲》笔记
 主备的基本原理 在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。
当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。
那么从状态1切换到状态2的内部流程是什么样的？
备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：
 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。 sql_thread 读取中转日志，解析出日志里的命令，并执行。  binlog 的三种格式对比 主备复制依赖于bin log，那么bin log中是什么内容。"><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A6%82%E8%A7%88mysql%E7%AF%87%E5%9B%9B%E4%B8%BB%E5%A4%87%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-23T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-23T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="概览MySQL篇四：主备与高可用"><meta name=twitter:description content="极客时间《MySQL实战45讲》笔记
 主备的基本原理 在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。
当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。
那么从状态1切换到状态2的内部流程是什么样的？
备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：
 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。 sql_thread 读取中转日志，解析出日志里的命令，并执行。  binlog 的三种格式对比 主备复制依赖于bin log，那么bin log中是什么内容。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"概览MySQL篇四：主备与高可用","item":"http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A6%82%E8%A7%88mysql%E7%AF%87%E5%9B%9B%E4%B8%BB%E5%A4%87%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"概览MySQL篇四：主备与高可用","name":"概览MySQL篇四：主备与高可用","description":"极客时间《MySQL实战45讲》笔记\n 主备的基本原理 在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。\n当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。\n那么从状态1切换到状态2的内部流程是什么样的？\n备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：\n 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。 sql_thread 读取中转日志，解析出日志里的命令，并执行。  binlog 的三种格式对比 主备复制依赖于bin log，那么bin log中是什么内容。","keywords":["MySQL"],"articleBody":" 极客时间《MySQL实战45讲》笔记\n 主备的基本原理 在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。\n当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。\n那么从状态1切换到状态2的内部流程是什么样的？\n备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：\n 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。 备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。 sql_thread 读取中转日志，解析出日志里的命令，并执行。  binlog 的三种格式对比 主备复制依赖于bin log，那么bin log中是什么内容。\nbin log的三种格式：\n statement row mixed  对于下表：\nmysql CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `t_modified`(`t_modified`) ) ENGINE=InnoDB; insert into t values(1,1,'2018-11-13'); insert into t values(2,2,'2018-11-12'); insert into t values(3,3,'2018-11-11'); insert into t values(4,4,'2018-11-10'); insert into t values(5,5,'2018-11-09'); 如果要在表中删除一行数据的话，我们来看看这个 delete 语句的 binlog 是怎么记录的：\nmysql delete from t /*comment*/ where a=4 and t_modified'2018-11-10' limit 1; 当binlog_format=statement时，binlog 里面记录的就是 SQL 语句的原文\nmysql show binlog events in 'binlog.000002'; +---------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +---------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------------------------+ | binlog.000002 | 4 | Format_desc | 1 | 126 | Server ver: 8.0.28, Binlog ver: 4 | | binlog.000002 | 126 | Previous_gtids | 1 | 157 | | | binlog.000002 | 157 | Anonymous_Gtid | 1 | 236 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' | | binlog.000002 | 236 | Query | 1 | 332 | BEGIN | | binlog.000002 | 332 | Query | 1 | 496 | use `test_db`; delete from t /*comment*/ where a=4 and t_modified'2018-11-10' limit 1 | | binlog.000002 | 496 | Xid | 1 | 527 | COMMIT /* xid=12 */ | +---------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------------------------+  当使用steaement格式日志时，可能会存在主备数据不一致的情况，例如：\n 如果 delete 语句使用的是索引 a，那么会根据索引 a 找到第一个满足条件的行，也就是说删除的是 a=4 这一行； 但如果使用的是索引 t_modified，那么删除的就是 t_modified=‘2018-11-09’也就是 a=5 这一行。  由于 statement 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 t_modified。因此，MySQL 认为这样写是有风险的。\n当binlog_format=‘row’时：\nmysql show binlog events in 'binlog.000002'; +---------------+-----+----------------+-----------+-------------+--------------------------------------+ | Log_name | Pos | Event_type | Server_id | End_log_pos | Info | +---------------+-----+----------------+-----------+-------------+--------------------------------------+ | binlog.000002 | 4 | Format_desc | 1 | 126 | Server ver: 8.0.28, Binlog ver: 4 | | binlog.000002 | 126 | Previous_gtids | 1 | 157 | | | binlog.000002 | 157 | Anonymous_Gtid | 1 | 236 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' | | binlog.000002 | 236 | Query | 1 | 322 | BEGIN | | binlog.000002 | 322 | Table_map | 1 | 375 | table_id: 88 (test_db.t) | | binlog.000002 | 375 | Delete_rows | 1 | 423 | table_id: 88 flags: STMT_END_F | | binlog.000002 | 423 | Xid | 1 | 454 | COMMIT /* xid=8 */ | +---------------+-----+----------------+-----------+-------------+--------------------------------------+ 与 statement 格式的 binlog 相比，前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。\n Table_map event，用于说明接下来要操作的表是 test 库的表 t; Delete_rows event，用于定义删除的行为。  但这里我们看不到详细信息，需要借助mysqlbinlog工具。用下面这个命令解析和查看 binlog 中的内容。\nmysqlbinlog -vv data/master.000001 --start-position=8900; # The proper term is pseudo_replica_mode, but we use this compatibility alias # to make the statement usable on server versions 8.0.24 and older. /*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/; /*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/; DELIMITER /*!*/; # at 126 #220615 6:51:35 server id 1 end_log_pos 126 CRC32 0xc895f13c Start: binlog v 4, server v 8.0.28 created 220615 6:51:35 at startup # Warning: this binlog is either in use or was not closed properly. ROLLBACK/*!*/; BINLOG ' d4GpYg8BAAAAegAAAH4AAAABAAQAOC4wLjI4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAB3galiEwANAAgAAAAABAAEAAAAYgAEGggAAAAICAgCAAAACgoKKioAEjQA CigAATzxlcg= '/*!*/; # at 157 #220615 6:52:14 server id 1 end_log_pos 236 CRC32 0x245f18b1 Anonymous_GTID last_committed=0 sequence_number=1 rbr_only=yes original_committed_timestamp=1655275934841953immediate_commit_timestamp=1655275934841953 transaction_length=297 /*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/; # original_commit_timestamp=1655275934841953 (2022-06-15 06:52:14.841953 UTC) # immediate_commit_timestamp=1655275934841953 (2022-06-15 06:52:14.841953 UTC) /*!80001 SET @@session.original_commit_timestamp=1655275934841953*//*!*/; /*!80014 SET @@session.original_server_version=80028*//*!*/; /*!80014 SET @@session.immediate_server_version=80028*//*!*/; SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/; # at 236 #220615 6:52:14 server id 1 end_log_pos 322 CRC32 0xfa351183 Query thread_id=8 exec_time=0 error_code=0 SET TIMESTAMP=1655275934/*!*/; SET @@session.pseudo_thread_id=8/*!*/; SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/; SET @@session.sql_mode=1168113696/*!*/; SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/; /*!\\C latin1 *//*!*/; SET @@session.character_set_client=8,@@session.collation_connection=8,@@session.collation_server=255/*!*/; SET @@session.time_zone='SYSTEM'/*!*/; SET @@session.lc_time_names=0/*!*/; SET @@session.collation_database=DEFAULT/*!*/; /*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/; BEGIN /*!*/; # at 322 #220615 6:52:14 server id 1 end_log_pos 375 CRC32 0xe571a47d Table_map: `test_db`.`t` mapped to number 88 # at 375 #220615 6:52:14 server id 1 end_log_pos 423 CRC32 0xafba99da Delete_rows: table id 88 flags: STMT_END_F BINLOG ' noGpYhMBAAAANQAAAHcBAAAAAFgAAAAAAAEAB3Rlc3RfZGIAAXQAAwMDEQEAAgEBAH2kceU= noGpYiABAAAAMAAAAKcBAAAAAFgAAAAAAAEAAgAD/wAEAAAABAAAAFvmH4Dambqv '/*!*/; ### DELETE FROM `test_db`.`t` ### WHERE ### @1=4 /* INT meta=0 nullable=0 is_null=0 */ ### @2=4 /* INT meta=0 nullable=1 is_null=0 */ ### @3=1541808000 /* TIMESTAMP(0) meta=0 nullable=0 is_null=0 */ # at 423 #220615 6:52:14 server id 1 end_log_pos 454 CRC32 0x7e73732f Xid = 8 COMMIT/*!*/; SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/; DELIMITER ; # End of log file /*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/; /*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/; 从上文日志中可以看出：\n server id 1，表示这个事务是在 server_id=1 的这个库上执行的。 每个 event 都有 CRC32 的值，这是因为我把参数 binlog_checksum 设置成了 CRC32。 Table_map event 跟在statement类型日志中看到的相同，显示了接下来要打开的表，map 到数字 226。现在我们这条 SQL 语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的 Table_map event、都会 map 到一个单独的数字，用于区分对不同表的操作。 在 mysqlbinlog 的命令中，使用了 -vv 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4 这些值）。 binlog_row_image 的默认配置是 FULL，因此 Delete_event 里面，包含了删掉的行的所有字段的值。如果把 binlog_row_image 设置为 MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录 id=4 这个信息。 最后的 Xid event，用于表示事务被正确地提交了。  当 binlog_format 使用 row 格式的时候，binlog 里面记录了真实删除行的主键 id，这样 binlog 传到备库去的时候，就肯定会删除 id=4 的行，不会有主备删除不同行的问题。\n为什么会有 mixed 格式的 binlog？  因为有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。 但 row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。 所以，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。  也就是说，mixed 格式可以利用 statment 格式的优点，同时又避免了数据不一致的风险。\n因此，如果你的线上 MySQL 设置的 binlog 格式是 statement 的话，那基本上就可以认为这是一个不合理的设置。你至少应该把 binlog 的格式设置为 mixed。\n但现在越来越多的场景要求把 MySQL 的 binlog 格式设置成 row。这么做的理由有很多，一个最直接的好处：恢复数据。\n  从row格式的日志可以看出，binlog会把删掉的整行信息都保存下来，所以，如果你在执行完一条 delete 语句以后，发现删错数据了，可以直接把 binlog 中记录的 delete 语句转成 insert，把被错删的数据插入回去就可以恢复了。\n  如果你是执行错了 insert 语句呢？那就更直接了。row 格式下，insert 语句的 binlog 里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把 insert 语句转成 delete 语句，删除掉这被误插入的一行数据就可以了。\n  如果执行的是 update 语句的话，binlog 里面会记录修改前整行的数据和修改后的整行数据。所以，如果你误执行了 update 语句的话，只需要把这个 event 前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。\n  循环复制问题 现在可以知道，binlog 的特性确保了在备库执行相同的 binlog，可以得到与主库相同的状态。因此我们可以认为图1中所示的M-S结构中A、B两个节点的内容是一致的。\n但实际生产上使用比较多的是双 M 结构，也就是下图所示的主备切换流程。\n对比上图和图 1，你可以发现，双 M 结构和 M-S 结构，其实区别只是多了一条线，即：节点 A 和 B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。\n但是，双 M 结构还有一个问题需要解决。\n业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（我建议你把参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。\n那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？\n从row格式的日志中可以看到，MySQL 在 binlog 中记录了这个命令第一次执行时所在实例的 server id。因此，可以用下面的逻辑，来解决两个节点间的循环复制的问题：\n 规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系； 一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog； 每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。  按照这个逻辑，如果我们设置了双 M 结构，日志的执行流就会变成这样：\n 从节点 A 更新的事务，binlog 里面记的都是 A 的 server id； 传到节点 B 执行一次以后，节点 B 生成的 binlog 的 server id 也是 A 的 server id； 再传回给节点 A，A 判断到这个 server id 与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。  ","wordCount":"985","inLanguage":"en","datePublished":"2022-03-23T00:00:00Z","dateModified":"2022-03-23T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A6%82%E8%A7%88mysql%E7%AF%87%E5%9B%9B%E4%B8%BB%E5%A4%87%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>概览MySQL篇四：主备与高可用</h1><div class=post-meta><span title="2022-03-23 00:00:00 +0000 UTC">March 23, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%bb%e5%a4%87%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 aria-label=主备的基本原理>主备的基本原理</a><ul><li><a href=#binlog-%e7%9a%84%e4%b8%89%e7%a7%8d%e6%a0%bc%e5%bc%8f%e5%af%b9%e6%af%94 aria-label="binlog 的三种格式对比">binlog 的三种格式对比</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89-mixed-%e6%a0%bc%e5%bc%8f%e7%9a%84-binlog aria-label="为什么会有 mixed 格式的 binlog？">为什么会有 mixed 格式的 binlog？</a></li><li><a href=#%e5%be%aa%e7%8e%af%e5%a4%8d%e5%88%b6%e9%97%ae%e9%a2%98 aria-label=循环复制问题>循环复制问题</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>极客时间<a href="https://time.geekbang.org/column/intro/100020801?tab=catalog">《MySQL实战45讲》</a>笔记</p></blockquote><h3 id=主备的基本原理>主备的基本原理<a hidden class=anchor aria-hidden=true href=#主备的基本原理>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220614154547.png alt=20220614154547></p><p>在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。</p><p>当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。</p><p>那么从状态1切换到状态2的内部流程是什么样的？</p><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220614154646.png alt=20220614154646></p><p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p><ol><li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li><li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li><li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li><li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li><li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li></ol><h4 id=binlog-的三种格式对比>binlog 的三种格式对比<a hidden class=anchor aria-hidden=true href=#binlog-的三种格式对比>#</a></h4><p>主备复制依赖于bin log，那么bin log中是什么内容。</p><p>bin log的三种格式：</p><ul><li>statement</li><li>row</li><li>mixed</li></ul><p>对于下表：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#f92672>`</span>t<span style=color:#f92672>`</span> (
  <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#f92672>`</span>a<span style=color:#f92672>`</span> int(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span>,
  <span style=color:#f92672>`</span>t_modified<span style=color:#f92672>`</span> <span style=color:#66d9ef>timestamp</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>CURRENT_TIMESTAMP</span>,
  <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>),
  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>a<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>a<span style=color:#f92672>`</span>),
  <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>t_modified<span style=color:#f92672>`</span>(<span style=color:#f92672>`</span>t_modified<span style=color:#f92672>`</span>)
) ENGINE<span style=color:#f92672>=</span>InnoDB;

<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t <span style=color:#66d9ef>values</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#e6db74>&#39;2018-11-13&#39;</span>);
<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t <span style=color:#66d9ef>values</span>(<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>,<span style=color:#e6db74>&#39;2018-11-12&#39;</span>);
<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t <span style=color:#66d9ef>values</span>(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>3</span>,<span style=color:#e6db74>&#39;2018-11-11&#39;</span>);
<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t <span style=color:#66d9ef>values</span>(<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>4</span>,<span style=color:#e6db74>&#39;2018-11-10&#39;</span>);
<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> t <span style=color:#66d9ef>values</span>(<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>5</span>,<span style=color:#e6db74>&#39;2018-11-09&#39;</span>);
</code></pre></div><p>如果要在表中删除一行数据的话，我们来看看这个 delete 语句的 binlog 是怎么记录的：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>
mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>from</span> t <span style=color:#75715e>/*comment*/</span>  <span style=color:#66d9ef>where</span> a<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>4</span> <span style=color:#66d9ef>and</span> t_modified<span style=color:#f92672>&lt;=</span><span style=color:#e6db74>&#39;2018-11-10&#39;</span> <span style=color:#66d9ef>limit</span> <span style=color:#ae81ff>1</span>;
</code></pre></div><p>当<code>binlog_format=statement</code>时，binlog 里面记录的就是 SQL 语句的原文</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>show</span> binlog events <span style=color:#66d9ef>in</span> <span style=color:#e6db74>&#39;binlog.000002&#39;</span>;
<span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------------------------+
</span><span style=color:#75715e></span><span style=color:#f92672>|</span> Log_name      <span style=color:#f92672>|</span> Pos <span style=color:#f92672>|</span> Event_type     <span style=color:#f92672>|</span> Server_id <span style=color:#f92672>|</span> End_log_pos <span style=color:#f92672>|</span> Info                                                                                     <span style=color:#f92672>|</span>
<span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------------------------+
</span><span style=color:#75715e></span><span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span>   <span style=color:#ae81ff>4</span> <span style=color:#f92672>|</span> Format_desc    <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>126</span> <span style=color:#f92672>|</span> Server ver: <span style=color:#ae81ff>8</span>.<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>28</span>, Binlog ver: <span style=color:#ae81ff>4</span>                                                        <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>126</span> <span style=color:#f92672>|</span> Previous_gtids <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>157</span> <span style=color:#f92672>|</span>                                                                                          <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>157</span> <span style=color:#f92672>|</span> Anonymous_Gtid <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>236</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>SET</span> <span style=color:#f92672>@@</span><span style=color:#66d9ef>SESSION</span>.GTID_NEXT<span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;ANONYMOUS&#39;</span>                                                     <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>236</span> <span style=color:#f92672>|</span> Query          <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>332</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>BEGIN</span>                                                                                    <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>332</span> <span style=color:#f92672>|</span> Query          <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>496</span> <span style=color:#f92672>|</span> use <span style=color:#f92672>`</span>test_db<span style=color:#f92672>`</span>; <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>from</span> t <span style=color:#75715e>/*comment*/</span> <span style=color:#66d9ef>where</span> a<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>4</span> <span style=color:#66d9ef>and</span> t_modified<span style=color:#f92672>&lt;=</span><span style=color:#e6db74>&#39;2018-11-10&#39;</span> <span style=color:#66d9ef>limit</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>496</span> <span style=color:#f92672>|</span> Xid            <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>527</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>COMMIT</span> <span style=color:#75715e>/* xid=12 */</span>                                                                      <span style=color:#f92672>|</span>
<span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------------------------+
</span><span style=color:#75715e></span>
</code></pre></div><p>当使用steaement格式日志时，可能会存在主备数据不一致的情况，例如：</p><ol><li>如果 delete 语句使用的是索引 a，那么会根据索引 a 找到第一个满足条件的行，也就是说删除的是 a=4 这一行；</li><li>但如果使用的是索引 t_modified，那么删除的就是 t_modified=&lsquo;2018-11-09’也就是 a=5 这一行。</li></ol><p>由于 statement 格式下，记录到 binlog 里的是语句原文，因此可能会出现这样一种情况：在主库执行这条 SQL 语句的时候，用的是索引 a；而在备库执行这条 SQL 语句的时候，却使用了索引 t_modified。因此，MySQL 认为这样写是有风险的。</p><p>当binlog_format=‘row’时：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>show</span> binlog events <span style=color:#66d9ef>in</span> <span style=color:#e6db74>&#39;binlog.000002&#39;</span>;
<span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----+----------------+-----------+-------------+--------------------------------------+
</span><span style=color:#75715e></span><span style=color:#f92672>|</span> Log_name      <span style=color:#f92672>|</span> Pos <span style=color:#f92672>|</span> Event_type     <span style=color:#f92672>|</span> Server_id <span style=color:#f92672>|</span> End_log_pos <span style=color:#f92672>|</span> Info                                 <span style=color:#f92672>|</span>
<span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----+----------------+-----------+-------------+--------------------------------------+
</span><span style=color:#75715e></span><span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span>   <span style=color:#ae81ff>4</span> <span style=color:#f92672>|</span> Format_desc    <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>126</span> <span style=color:#f92672>|</span> Server ver: <span style=color:#ae81ff>8</span>.<span style=color:#ae81ff>0</span>.<span style=color:#ae81ff>28</span>, Binlog ver: <span style=color:#ae81ff>4</span>    <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>126</span> <span style=color:#f92672>|</span> Previous_gtids <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>157</span> <span style=color:#f92672>|</span>                                      <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>157</span> <span style=color:#f92672>|</span> Anonymous_Gtid <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>236</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>SET</span> <span style=color:#f92672>@@</span><span style=color:#66d9ef>SESSION</span>.GTID_NEXT<span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;ANONYMOUS&#39;</span> <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>236</span> <span style=color:#f92672>|</span> Query          <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>322</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>BEGIN</span>                                <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>322</span> <span style=color:#f92672>|</span> Table_map      <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>375</span> <span style=color:#f92672>|</span> table_id: <span style=color:#ae81ff>88</span> (test_db.t)             <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>375</span> <span style=color:#f92672>|</span> Delete_rows    <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>423</span> <span style=color:#f92672>|</span> table_id: <span style=color:#ae81ff>88</span> flags: STMT_END_F       <span style=color:#f92672>|</span>
<span style=color:#f92672>|</span> binlog.<span style=color:#ae81ff>000002</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>423</span> <span style=color:#f92672>|</span> Xid            <span style=color:#f92672>|</span>         <span style=color:#ae81ff>1</span> <span style=color:#f92672>|</span>         <span style=color:#ae81ff>454</span> <span style=color:#f92672>|</span> <span style=color:#66d9ef>COMMIT</span> <span style=color:#75715e>/* xid=8 */</span>                   <span style=color:#f92672>|</span>
<span style=color:#f92672>+</span><span style=color:#75715e>---------------+-----+----------------+-----------+-------------+--------------------------------------+
</span></code></pre></div><p>与 statement 格式的 binlog 相比，前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p><ul><li>Table_map event，用于说明接下来要操作的表是 test 库的表 t;</li><li>Delete_rows event，用于定义删除的行为。</li></ul><p>但这里我们看不到详细信息，需要借助<code>mysqlbinlog</code>工具。用下面这个命令解析和查看 binlog 中的内容。</p><pre><code>mysqlbinlog  -vv data/master.000001 --start-position=8900;
</code></pre><pre><code># The proper term is pseudo_replica_mode, but we use this compatibility alias
# to make the statement usable on server versions 8.0.24 and older.
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
DELIMITER /*!*/;
# at 126
#220615  6:51:35 server id 1  end_log_pos 126 CRC32 0xc895f13c  Start: binlog v 4, server v 8.0.28 created 220615  6:51:35 at startup
# Warning: this binlog is either in use or was not closed properly.
ROLLBACK/*!*/;
BINLOG '
d4GpYg8BAAAAegAAAH4AAAABAAQAOC4wLjI4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAB3galiEwANAAgAAAAABAAEAAAAYgAEGggAAAAICAgCAAAACgoKKioAEjQA
CigAATzxlcg=
'/*!*/;
# at 157
#220615  6:52:14 server id 1  end_log_pos 236 CRC32 0x245f18b1  Anonymous_GTID  last_committed=0        sequence_number=1       rbr_only=yes    original_committed_timestamp=1655275934841953immediate_commit_timestamp=1655275934841953     transaction_length=297
/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
# original_commit_timestamp=1655275934841953 (2022-06-15 06:52:14.841953 UTC)
# immediate_commit_timestamp=1655275934841953 (2022-06-15 06:52:14.841953 UTC)
/*!80001 SET @@session.original_commit_timestamp=1655275934841953*//*!*/;
/*!80014 SET @@session.original_server_version=80028*//*!*/;
/*!80014 SET @@session.immediate_server_version=80028*//*!*/;
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 236
#220615  6:52:14 server id 1  end_log_pos 322 CRC32 0xfa351183  Query   thread_id=8     exec_time=0     error_code=0
SET TIMESTAMP=1655275934/*!*/;
SET @@session.pseudo_thread_id=8/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1168113696/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C latin1 *//*!*/;
SET @@session.character_set_client=8,@@session.collation_connection=8,@@session.collation_server=255/*!*/;
SET @@session.time_zone='SYSTEM'/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;
BEGIN
/*!*/;
# at 322
#220615  6:52:14 server id 1  end_log_pos 375 CRC32 0xe571a47d  Table_map: `test_db`.`t` mapped to number 88
# at 375
#220615  6:52:14 server id 1  end_log_pos 423 CRC32 0xafba99da  Delete_rows: table id 88 flags: STMT_END_F

BINLOG '
noGpYhMBAAAANQAAAHcBAAAAAFgAAAAAAAEAB3Rlc3RfZGIAAXQAAwMDEQEAAgEBAH2kceU=
noGpYiABAAAAMAAAAKcBAAAAAFgAAAAAAAEAAgAD/wAEAAAABAAAAFvmH4Dambqv
'/*!*/;
### DELETE FROM `test_db`.`t`
### WHERE
###   @1=4 /* INT meta=0 nullable=0 is_null=0 */
###   @2=4 /* INT meta=0 nullable=1 is_null=0 */
###   @3=1541808000 /* TIMESTAMP(0) meta=0 nullable=0 is_null=0 */
# at 423
#220615  6:52:14 server id 1  end_log_pos 454 CRC32 0x7e73732f  Xid = 8
COMMIT/*!*/;
SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
</code></pre><p>从上文日志中可以看出：</p><ul><li>server id 1，表示这个事务是在 server_id=1 的这个库上执行的。</li><li>每个 event 都有 CRC32 的值，这是因为我把参数 binlog_checksum 设置成了 CRC32。</li><li>Table_map event 跟在statement类型日志中看到的相同，显示了接下来要打开的表，map 到数字 226。现在我们这条 SQL 语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的 Table_map event、都会 map 到一个单独的数字，用于区分对不同表的操作。</li><li>在 mysqlbinlog 的命令中，使用了 -vv 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4 这些值）。</li><li>binlog_row_image 的默认配置是 FULL，因此 Delete_event 里面，包含了删掉的行的所有字段的值。如果把 binlog_row_image 设置为 MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录 id=4 这个信息。</li><li>最后的 Xid event，用于表示事务被正确地提交了。</li></ul><p>当 binlog_format 使用 row 格式的时候，binlog 里面记录了真实删除行的主键 id，这样 binlog 传到备库去的时候，就肯定会删除 id=4 的行，不会有主备删除不同行的问题。</p><h4 id=为什么会有-mixed-格式的-binlog>为什么会有 mixed 格式的 binlog？<a hidden class=anchor aria-hidden=true href=#为什么会有-mixed-格式的-binlog>#</a></h4><ul><li>因为有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。</li><li>但 row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</li><li>所以，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</li></ul><p>也就是说，mixed 格式可以利用 statment 格式的优点，同时又避免了数据不一致的风险。</p><p>因此，如果你的线上 MySQL 设置的 binlog 格式是 statement 的话，那基本上就可以认为这是一个不合理的设置。你至少应该把 binlog 的格式设置为 mixed。</p><p>但现在越来越多的场景要求把 MySQL 的 binlog 格式设置成 row。这么做的理由有很多，一个最直接的好处：恢复数据。</p><ul><li><p>从row格式的日志可以看出，binlog会把删掉的整行信息都保存下来，所以，如果你在执行完一条 delete 语句以后，发现删错数据了，可以直接把 binlog 中记录的 delete 语句转成 insert，把被错删的数据插入回去就可以恢复了。</p></li><li><p>如果你是执行错了 insert 语句呢？那就更直接了。row 格式下，insert 语句的 binlog 里会记录所有的字段信息，这些信息可以用来精确定位刚刚被插入的那一行。这时，你直接把 insert 语句转成 delete 语句，删除掉这被误插入的一行数据就可以了。</p></li><li><p>如果执行的是 update 语句的话，binlog 里面会记录修改前整行的数据和修改后的整行数据。所以，如果你误执行了 update 语句的话，只需要把这个 event 前后的两行信息对调一下，再去数据库里面执行，就能恢复这个更新操作了。</p></li></ul><h4 id=循环复制问题>循环复制问题<a hidden class=anchor aria-hidden=true href=#循环复制问题>#</a></h4><p>现在可以知道，binlog 的特性确保了在备库执行相同的 binlog，可以得到与主库相同的状态。因此我们可以认为图1中所示的M-S结构中A、B两个节点的内容是一致的。</p><p>但实际生产上使用比较多的是双 M 结构，也就是下图所示的主备切换流程。</p><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220615151126.png alt=20220615151126></p><p>对比上图和图 1，你可以发现，双 M 结构和 M-S 结构，其实区别只是多了一条线，即：节点 A 和 B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。</p><p>但是，双 M 结构还有一个问题需要解决。</p><p>业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（我建议你把参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。</p><p>那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？</p><p>从row格式的日志中可以看到，MySQL 在 binlog 中记录了这个命令第一次执行时所在实例的 server id。因此，可以用下面的逻辑，来解决两个节点间的循环复制的问题：</p><ul><li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li><li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li><li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li></ul><p>按照这个逻辑，如果我们设置了双 M 结构，日志的执行流就会变成这样：</p><ul><li>从节点 A 更新的事务，binlog 里面记的都是 A 的 server id；</li><li>传到节点 B 执行一次以后，节点 B 生成的 binlog 的 server id 也是 A 的 server id；</li><li>再传回给节点 A，A 判断到这个 server id 与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/mysql/>MySQL</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A6%82%E8%A7%88mysql%E7%AF%87%E4%BA%8C%E6%8C%81%E4%B9%85%E5%8C%96/><span class=title>« Prev Page</span><br><span>概览MySQL篇二：持久化</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A6%82%E8%A7%88mysql%E7%AF%87%E4%B8%80%E7%B4%A2%E5%BC%95/><span class=title>Next Page »</span><br><span>概览MySQL篇一：索引</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>