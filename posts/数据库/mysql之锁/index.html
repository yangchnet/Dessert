<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mysql:锁 | Linote</title><meta name=keywords content="mysql"><meta name=description content="索引是什么，为何存在，以什么样的结构组织或存储索引? 简单来说，索引是一个目录，用来对数据进行快速的查找。就像一本厚厚的字典，想要查询某个字或者词语，我们固然可以一页页翻阅整本词典，但更好的方式是通过拼音索引或者笔画索引到这条记录。
索引可以有效减小查询的资源消耗，但索引不是毫无代价的，大量的创建索引会造成存储空间的损耗，我们要根据业务需求，有目的的创建对业务有帮助的索引。
在MYSQL的InnoDB引擎中，索引是以B+树的形式存在的。B+树的节点存储在物理页上。
根据叶子节点的内容，索引类型分为主键索引和非主键索引。
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是*主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。
为什么更推荐使用自增主键? 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。
B+树天然就是有序的，当我们想在上图中插入一个ID=400的记录，那么可能需要进行页分裂操作，这就需要挪动后面的数据。但如果想插入一个ID=700的值，只需要在最后附加一条记录就可以，不需要对前面的值就行操作。
自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
使用索引查询的过程是怎么样的，什么叫回表、覆盖索引？ 对于如下表：
mysql> create table T ( ID int primary key, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '', index k(k)) engine=InnoDB; insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); 当执行select * from T where k between 3 and 5时，过程如下：
 在 k 索引树上找到 k=3 的记录，取得 ID = 300； 再到 ID 索引树查到 ID=300 对应的 R3； 在 k 索引树取下一个值 k=5，取得 ID=500； 再回到 ID 索引树查到 ID=500 对应的 R4； 在 k 索引树取下一个值 k=6，不满足条件，循环结束。  可以看到，MYSQL先在k索引树上查找满足条件的记录，拿到主键，然后再到主键索引树上去取整条记录。这个用主键去主键索引上取数据的操作就叫做回表。"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B9%8B%E9%94%81/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Mysql:锁"><meta property="og:description" content="索引是什么，为何存在，以什么样的结构组织或存储索引? 简单来说，索引是一个目录，用来对数据进行快速的查找。就像一本厚厚的字典，想要查询某个字或者词语，我们固然可以一页页翻阅整本词典，但更好的方式是通过拼音索引或者笔画索引到这条记录。
索引可以有效减小查询的资源消耗，但索引不是毫无代价的，大量的创建索引会造成存储空间的损耗，我们要根据业务需求，有目的的创建对业务有帮助的索引。
在MYSQL的InnoDB引擎中，索引是以B+树的形式存在的。B+树的节点存储在物理页上。
根据叶子节点的内容，索引类型分为主键索引和非主键索引。
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是*主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。
为什么更推荐使用自增主键? 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。
B+树天然就是有序的，当我们想在上图中插入一个ID=400的记录，那么可能需要进行页分裂操作，这就需要挪动后面的数据。但如果想插入一个ID=700的值，只需要在最后附加一条记录就可以，不需要对前面的值就行操作。
自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
使用索引查询的过程是怎么样的，什么叫回表、覆盖索引？ 对于如下表：
mysql> create table T ( ID int primary key, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '', index k(k)) engine=InnoDB; insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); 当执行select * from T where k between 3 and 5时，过程如下：
 在 k 索引树上找到 k=3 的记录，取得 ID = 300； 再到 ID 索引树查到 ID=300 对应的 R3； 在 k 索引树取下一个值 k=5，取得 ID=500； 再回到 ID 索引树查到 ID=500 对应的 R4； 在 k 索引树取下一个值 k=6，不满足条件，循环结束。  可以看到，MYSQL先在k索引树上查找满足条件的记录，拿到主键，然后再到主键索引树上去取整条记录。这个用主键去主键索引上取数据的操作就叫做回表。"><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B9%8B%E9%94%81/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-22T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-22T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="Mysql:锁"><meta name=twitter:description content="索引是什么，为何存在，以什么样的结构组织或存储索引? 简单来说，索引是一个目录，用来对数据进行快速的查找。就像一本厚厚的字典，想要查询某个字或者词语，我们固然可以一页页翻阅整本词典，但更好的方式是通过拼音索引或者笔画索引到这条记录。
索引可以有效减小查询的资源消耗，但索引不是毫无代价的，大量的创建索引会造成存储空间的损耗，我们要根据业务需求，有目的的创建对业务有帮助的索引。
在MYSQL的InnoDB引擎中，索引是以B+树的形式存在的。B+树的节点存储在物理页上。
根据叶子节点的内容，索引类型分为主键索引和非主键索引。
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是*主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。
为什么更推荐使用自增主键? 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。
B+树天然就是有序的，当我们想在上图中插入一个ID=400的记录，那么可能需要进行页分裂操作，这就需要挪动后面的数据。但如果想插入一个ID=700的值，只需要在最后附加一条记录就可以，不需要对前面的值就行操作。
自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
使用索引查询的过程是怎么样的，什么叫回表、覆盖索引？ 对于如下表：
mysql> create table T ( ID int primary key, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '', index k(k)) engine=InnoDB; insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); 当执行select * from T where k between 3 and 5时，过程如下：
 在 k 索引树上找到 k=3 的记录，取得 ID = 300； 再到 ID 索引树查到 ID=300 对应的 R3； 在 k 索引树取下一个值 k=5，取得 ID=500； 再回到 ID 索引树查到 ID=500 对应的 R4； 在 k 索引树取下一个值 k=6，不满足条件，循环结束。  可以看到，MYSQL先在k索引树上查找满足条件的记录，拿到主键，然后再到主键索引树上去取整条记录。这个用主键去主键索引上取数据的操作就叫做回表。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"Mysql:锁","item":"http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B9%8B%E9%94%81/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mysql:锁","name":"Mysql:锁","description":"索引是什么，为何存在，以什么样的结构组织或存储索引? 简单来说，索引是一个目录，用来对数据进行快速的查找。就像一本厚厚的字典，想要查询某个字或者词语，我们固然可以一页页翻阅整本词典，但更好的方式是通过拼音索引或者笔画索引到这条记录。\n索引可以有效减小查询的资源消耗，但索引不是毫无代价的，大量的创建索引会造成存储空间的损耗，我们要根据业务需求，有目的的创建对业务有帮助的索引。\n在MYSQL的InnoDB引擎中，索引是以B+树的形式存在的。B+树的节点存储在物理页上。\n根据叶子节点的内容，索引类型分为主键索引和非主键索引。\n主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。\n非主键索引的叶子节点内容是*主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。\n为什么更推荐使用自增主键? 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。\nB+树天然就是有序的，当我们想在上图中插入一个ID=400的记录，那么可能需要进行页分裂操作，这就需要挪动后面的数据。但如果想插入一个ID=700的值，只需要在最后附加一条记录就可以，不需要对前面的值就行操作。\n自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。\n除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。\n使用索引查询的过程是怎么样的，什么叫回表、覆盖索引？ 对于如下表：\nmysql\u0026gt; create table T ( ID int primary key, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT \u0026#39;\u0026#39;, index k(k)) engine=InnoDB; insert into T values(100,1, \u0026#39;aa\u0026#39;),(200,2,\u0026#39;bb\u0026#39;),(300,3,\u0026#39;cc\u0026#39;),(500,5,\u0026#39;ee\u0026#39;),(600,6,\u0026#39;ff\u0026#39;),(700,7,\u0026#39;gg\u0026#39;); 当执行select * from T where k between 3 and 5时，过程如下：\n 在 k 索引树上找到 k=3 的记录，取得 ID = 300； 再到 ID 索引树查到 ID=300 对应的 R3； 在 k 索引树取下一个值 k=5，取得 ID=500； 再回到 ID 索引树查到 ID=500 对应的 R4； 在 k 索引树取下一个值 k=6，不满足条件，循环结束。  可以看到，MYSQL先在k索引树上查找满足条件的记录，拿到主键，然后再到主键索引树上去取整条记录。这个用主键去主键索引上取数据的操作就叫做回表。","keywords":["mysql"],"articleBody":"索引是什么，为何存在，以什么样的结构组织或存储索引? 简单来说，索引是一个目录，用来对数据进行快速的查找。就像一本厚厚的字典，想要查询某个字或者词语，我们固然可以一页页翻阅整本词典，但更好的方式是通过拼音索引或者笔画索引到这条记录。\n索引可以有效减小查询的资源消耗，但索引不是毫无代价的，大量的创建索引会造成存储空间的损耗，我们要根据业务需求，有目的的创建对业务有帮助的索引。\n在MYSQL的InnoDB引擎中，索引是以B+树的形式存在的。B+树的节点存储在物理页上。\n根据叶子节点的内容，索引类型分为主键索引和非主键索引。\n主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。\n非主键索引的叶子节点内容是*主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。\n为什么更推荐使用自增主键? 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。\nB+树天然就是有序的，当我们想在上图中插入一个ID=400的记录，那么可能需要进行页分裂操作，这就需要挪动后面的数据。但如果想插入一个ID=700的值，只需要在最后附加一条记录就可以，不需要对前面的值就行操作。\n自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。\n除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。\n使用索引查询的过程是怎么样的，什么叫回表、覆盖索引？ 对于如下表：\nmysql create table T ( ID int primary key, k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT '', index k(k)) engine=InnoDB; insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg'); 当执行select * from T where k between 3 and 5时，过程如下：\n 在 k 索引树上找到 k=3 的记录，取得 ID = 300； 再到 ID 索引树查到 ID=300 对应的 R3； 在 k 索引树取下一个值 k=5，取得 ID=500； 再回到 ID 索引树查到 ID=500 对应的 R4； 在 k 索引树取下一个值 k=6，不满足条件，循环结束。  可以看到，MYSQL先在k索引树上查找满足条件的记录，拿到主键，然后再到主键索引树上去取整条记录。这个用主键去主键索引上取数据的操作就叫做回表。\n回表的过程重新访问了主键索引，有没有什么办法可以避免回表？\n如果将上面的查询语句改成select ID from T where k between 3 and 5，这时我们查询k索引树的时候，由于ID已经在k键索引上存在了，因此就不需要再进行回表操作。索引覆盖了我们的查询需求，称为覆盖索引。\n什么叫最左前缀，索引下推 对于一个记录居民身份信息的表，其（name, age）索引如下： 当我们想要在这张表上查询name=张三的记录时，可以通过索引快速定位到ID4，然后继续往后查找。类似的，当我们想要查找name like 张%的记录时，也可以利用这个索引快速定位到满足条件的第一个记录ID3.\n可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。\n对于如下语句：\nmysql select * from tuser where name like '张%' and age=10 and ismale=1; 在MYSQL5.6之前，在（name， age）索引上找到符合name like '张%'的记录后，仍然需要根据索引上存储的主键去主索引上回表，待将整行数据全部取出后再进行判断。\n但仔细观察可以发现，（name， age）联合索引上已经存在age字段，也就是说，对于age=10这个条件判断，我们完全不需要进行回表，只用当前索引上的数据就可以进行判断。这叫做索引下推\n什么是change buffer，有什么作用 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。这个操作称为merge.\n这里需要注意的是，change buffer看起来像是内存缓存一类的东西，但是change buffer是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。\n如果将change buffer也存在磁盘上，而数据也是存储在磁盘上，那么change buffer相比直接读取磁盘数据快在哪里呢？\n从磁盘读取一条记录，是随机读写，而写change buffer，是顺序读写。这二者的速度存在较大差异。随机读写由于存在磁头移道等物理操作，因此比较慢，但顺序读写比较快速。\nchange buffer的限制 change buffer只是暂时的将更新操作保存下来，而并没有去读取真正的数据。考虑以下情况，表中要求某一字段为唯一的，而在更新时不小心插入了一个与原有某数据重复的条目，这显然是不被允许的。\n因此，当表中存在唯一索引、唯一值等限制，这时候就不能用change buffer了。只有普通索引和不存在值唯一性约束的列，才可以用change buffer。\nchange buffer用的是buffer pool中的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。\nchange buffer的使用场景 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。\n因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。\n反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。\n扫描行数是如何判断的？ 当一个语句被分析完毕后，会由优化器来选择索引，目的是找出一个最优的执行方案，并用最小的代价去执行语句。其中，扫描行数是一个比较重要的判断标准。\nMySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。\n这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。\n可以使用show index方法，查看索引的基数。但，基数可能会不准确。\nMYSQL采用采样的统计的方法得到索引的基数。\n为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。\n采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。\n而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。\n在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数innodb_stats_persistent 的值来选择：\n 设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。 设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。  由于是采样统计，所以不管 N 是 20 还是 8，这个基数都是很容易不准的。\n如何修正索引统计信息？\nanalyze table table_name; 对于字符串索引，有哪些优化方式 对于邮箱等字段，可以使用前缀索引。但使用前缀索引存在一个问题：即使前缀索引中已经包含了查询所需要的全部信息，但MySQL仍然要进行回表，因为系统并不确定前缀索引的定义是否截断了完整信息。也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了.\n对于身份证号这种类型，可以使用倒序存储，这样可以更好的使用前缀索引。\n还可以使用hash字段，在表上再创建一个整数字段，来保存字段的校验码，同时在这个字段上创建索引。\n","wordCount":"256","inLanguage":"en","datePublished":"2022-03-22T00:00:00Z","dateModified":"2022-03-22T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B9%8B%E9%94%81/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>Mysql:锁</h1><div class=post-meta><span title="2022-03-22 00:00:00 +0000 UTC">March 22, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%b4%a2%e5%bc%95%e6%98%af%e4%bb%80%e4%b9%88%e4%b8%ba%e4%bd%95%e5%ad%98%e5%9c%a8%e4%bb%a5%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e7%bb%93%e6%9e%84%e7%bb%84%e7%bb%87%e6%88%96%e5%ad%98%e5%82%a8%e7%b4%a2%e5%bc%95 aria-label=索引是什么，为何存在，以什么样的结构组织或存储索引?>索引是什么，为何存在，以什么样的结构组织或存储索引?</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9b%b4%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8%e8%87%aa%e5%a2%9e%e4%b8%bb%e9%94%ae aria-label=为什么更推荐使用自增主键?>为什么更推荐使用自增主键?</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95%e6%9f%a5%e8%af%a2%e7%9a%84%e8%bf%87%e7%a8%8b%e6%98%af%e6%80%8e%e4%b9%88%e6%a0%b7%e7%9a%84%e4%bb%80%e4%b9%88%e5%8f%ab%e5%9b%9e%e8%a1%a8%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95 aria-label=使用索引查询的过程是怎么样的，什么叫回表、覆盖索引？>使用索引查询的过程是怎么样的，什么叫回表、覆盖索引？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e5%8f%ab%e6%9c%80%e5%b7%a6%e5%89%8d%e7%bc%80%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8 aria-label=什么叫最左前缀，索引下推>什么叫最左前缀，索引下推</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afchange-buffer%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8 aria-label="什么是change buffer，有什么作用">什么是change buffer，有什么作用</a><ul><li><a href=#change-buffer%e7%9a%84%e9%99%90%e5%88%b6 aria-label="change buffer的限制">change buffer的限制</a></li><li><a href=#change-buffer%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label="change buffer的使用场景">change buffer的使用场景</a></li></ul></li><li><a href=#%e6%89%ab%e6%8f%8f%e8%a1%8c%e6%95%b0%e6%98%af%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e7%9a%84 aria-label=扫描行数是如何判断的？>扫描行数是如何判断的？</a></li><li><a href=#%e5%af%b9%e4%ba%8e%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b4%a2%e5%bc%95%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8c%96%e6%96%b9%e5%bc%8f aria-label=对于字符串索引，有哪些优化方式>对于字符串索引，有哪些优化方式</a></li></ul></div></details></div><div class=post-content><h3 id=索引是什么为何存在以什么样的结构组织或存储索引>索引是什么，为何存在，以什么样的结构组织或存储索引?<a hidden class=anchor aria-hidden=true href=#索引是什么为何存在以什么样的结构组织或存储索引>#</a></h3><p>简单来说，索引是一个目录，用来对数据进行快速的查找。就像一本厚厚的字典，想要查询某个字或者词语，我们固然可以一页页翻阅整本词典，但更好的方式是通过拼音索引或者笔画索引到这条记录。</p><p>索引可以有效减小查询的资源消耗，但索引不是毫无代价的，大量的创建索引会造成存储空间的损耗，我们要根据业务需求，有目的的创建对业务有帮助的索引。</p><p>在MYSQL的InnoDB引擎中，索引是以B+树的形式存在的。B+树的节点存储在物理页上。</p><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220322143227.png alt=20220322143227></p><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是<strong>整行数据</strong>。<strong>在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）</strong>。</p><p>非主键索引的叶子节点内容是*<strong>主键的值</strong>。<strong>在 InnoDB 里，非主键索引也被称为二级索引（secondary index）</strong>。</p><h3 id=为什么更推荐使用自增主键>为什么更推荐使用自增主键?<a hidden class=anchor aria-hidden=true href=#为什么更推荐使用自增主键>#</a></h3><p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p><p>B+树天然就是有序的，当我们想在上图中插入一个<code>ID=400</code>的记录，那么可能需要进行页分裂操作，这就需要挪动后面的数据。但如果想插入一个<code>ID=700</code>的值，只需要在最后附加一条记录就可以，不需要对前面的值就行操作。</p><p>自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p><h3 id=使用索引查询的过程是怎么样的什么叫回表覆盖索引>使用索引查询的过程是怎么样的，什么叫回表、覆盖索引？<a hidden class=anchor aria-hidden=true href=#使用索引查询的过程是怎么样的什么叫回表覆盖索引>#</a></h3><p>对于如下表：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>create</span> <span style=color:#66d9ef>table</span> T (
ID int <span style=color:#66d9ef>primary</span> <span style=color:#66d9ef>key</span>,
k int <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#ae81ff>0</span>,
s varchar(<span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#e6db74>&#39;&#39;</span>,
<span style=color:#66d9ef>index</span> k(k))
engine<span style=color:#f92672>=</span>InnoDB;

<span style=color:#66d9ef>insert</span> <span style=color:#66d9ef>into</span> T <span style=color:#66d9ef>values</span>(<span style=color:#ae81ff>100</span>,<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;aa&#39;</span>),(<span style=color:#ae81ff>200</span>,<span style=color:#ae81ff>2</span>,<span style=color:#e6db74>&#39;bb&#39;</span>),(<span style=color:#ae81ff>300</span>,<span style=color:#ae81ff>3</span>,<span style=color:#e6db74>&#39;cc&#39;</span>),(<span style=color:#ae81ff>500</span>,<span style=color:#ae81ff>5</span>,<span style=color:#e6db74>&#39;ee&#39;</span>),(<span style=color:#ae81ff>600</span>,<span style=color:#ae81ff>6</span>,<span style=color:#e6db74>&#39;ff&#39;</span>),(<span style=color:#ae81ff>700</span>,<span style=color:#ae81ff>7</span>,<span style=color:#e6db74>&#39;gg&#39;</span>);
</code></pre></div><p><img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220322144650.png alt=20220322144650></p><p>当执行<code>select * from T where k between 3 and 5</code>时，过程如下：</p><ol><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li></ol><p>可以看到，MYSQL先在k索引树上查找满足条件的记录，拿到主键，然后再到主键索引树上去取整条记录。这个用主键去主键索引上取数据的操作就叫做<strong>回表</strong>。</p><p>回表的过程重新访问了主键索引，有没有什么办法可以避免回表？</p><p>如果将上面的查询语句改成<code>select ID from T where k between 3 and 5</code>，这时我们查询k索引树的时候，由于<code>ID</code>已经在k键索引上存在了，因此就不需要再进行回表操作。索引覆盖了我们的查询需求，称为<strong>覆盖索引</strong>。</p><h3 id=什么叫最左前缀索引下推>什么叫最左前缀，索引下推<a hidden class=anchor aria-hidden=true href=#什么叫最左前缀索引下推>#</a></h3><p>对于一个记录居民身份信息的表，其（name, age）索引如下：
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20220322150532.png alt=20220322150532></p><p>当我们想要在这张表上查询<code>name=张三</code>的记录时，可以通过索引快速定位到<code>ID4</code>，然后继续往后查找。类似的，当我们想要查找<code>name like 张%</code>的记录时，也可以利用这个索引快速定位到满足条件的第一个记录<code>ID3</code>.</p><p>可以看到，不只是索引的全部定义，只要满足<strong>最左前缀</strong>，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>对于如下语句：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>mysql<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>select</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>from</span> tuser <span style=color:#66d9ef>where</span> name <span style=color:#66d9ef>like</span> <span style=color:#e6db74>&#39;张%&#39;</span> <span style=color:#66d9ef>and</span> age<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span> <span style=color:#66d9ef>and</span> ismale<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</code></pre></div><p>在MYSQL5.6之前，在（name， age）索引上找到符合<code>name like '张%'</code>的记录后，仍然需要根据索引上存储的主键去主索引上回表，待将整行数据全部取出后再进行判断。</p><p>但仔细观察可以发现，（name， age）联合索引上已经存在<code>age</code>字段，也就是说，对于<code>age=10</code>这个条件判断，我们完全不需要进行回表，只用当前索引上的数据就可以进行判断。这叫做<strong>索引下推</strong></p><h3 id=什么是change-buffer有什么作用>什么是change buffer，有什么作用<a hidden class=anchor aria-hidden=true href=#什么是change-buffer有什么作用>#</a></h3><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 <strong>change buffer</strong> 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 <code>change buffer</code> 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。这个操作称为<strong>merge</strong>.</p><p>这里需要注意的是，<code>change buffer</code>看起来像是内存缓存一类的东西，但是<code>change buffer</code>是可以持久化的数据。也就是说，<code>change buffer</code>在内存中有拷贝，也会被写入到磁盘上。</p><p>如果将<code>change buffer</code>也存在磁盘上，而数据也是存储在磁盘上，那么<code>change buffer</code>相比直接读取磁盘数据快在哪里呢？</p><p>从磁盘读取一条记录，是随机读写，而写<code>change buffer</code>，是顺序读写。这二者的速度存在较大差异。随机读写由于存在磁头移道等物理操作，因此比较慢，但顺序读写比较快速。</p><h4 id=change-buffer的限制>change buffer的限制<a hidden class=anchor aria-hidden=true href=#change-buffer的限制>#</a></h4><p><code>change buffer</code>只是暂时的将更新操作保存下来，而并没有去读取真正的数据。考虑以下情况，表中要求某一字段为唯一的，而在更新时不小心插入了一个与原有某数据重复的条目，这显然是不被允许的。</p><p>因此，当表中存在唯一索引、唯一值等限制，这时候就不能用<code>change buffer</code>了。只有普通索引和不存在值唯一性约束的列，才可以用<code>change buffer</code>。</p><p><code>change buffer</code>用的是<code>buffer pool</code>中的内存，因此不能无限增大。<code>change buffer</code> 的大小，可以通过参数 <strong>innodb_change_buffer_max_size</strong> 来动态设置。这个参数设置为 <code>50</code> 的时候，表示 <code>change buffer</code> 的大小最多只能占用 <code>buffer pool</code> 的 <strong>50%</strong>。</p><h4 id=change-buffer的使用场景>change buffer的使用场景<a hidden class=anchor aria-hidden=true href=#change-buffer的使用场景>#</a></h4><p><code>merge</code> 的时候是真正进行数据更新的时刻，而 <code>change buffer</code> 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 <code>merge</code> 之前，<code>change buffer</code> 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 <code>change buffer</code> 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 <code>change buffer</code>，但之后由于马上要访问这个数据页，会立即触发 <code>merge</code> 过程。这样随机访问 IO 的次数不会减少，反而增加了 <code>change buffer</code> 的维护代价。所以，对于这种业务模式来说，<code>change buffer</code> 反而起到了副作用。</p><h3 id=扫描行数是如何判断的>扫描行数是如何判断的？<a hidden class=anchor aria-hidden=true href=#扫描行数是如何判断的>#</a></h3><p>当一个语句被分析完毕后，会由优化器来选择索引，目的是找出一个最优的执行方案，并用最小的代价去执行语句。其中，扫描行数是一个比较重要的判断标准。</p><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p><p>可以使用<code>show index</code>方法，查看索引的基数。但，基数可能会不准确。</p><p>MYSQL采用采样的统计的方法得到索引的基数。</p><p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p><p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 <strong>1/M</strong> 的时候，会自动触发重新做一次索引统计。</p><p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数<strong>innodb_stats_persistent</strong> 的值来选择：</p><ul><li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li><li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li></ul><p>由于是采样统计，所以不管 N 是 20 还是 8，这个基数都是很容易不准的。</p><p>如何修正索引统计信息？</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>analyze</span> <span style=color:#66d9ef>table</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>table_name</span><span style=color:#f92672>&gt;</span>;
</code></pre></div><h3 id=对于字符串索引有哪些优化方式>对于字符串索引，有哪些优化方式<a hidden class=anchor aria-hidden=true href=#对于字符串索引有哪些优化方式>#</a></h3><p>对于邮箱等字段，可以使用前缀索引。但使用前缀索引存在一个问题：即使前缀索引中已经包含了查询所需要的全部信息，但MySQL仍然要进行回表，因为系统并不确定前缀索引的定义是否截断了完整信息。也就是说，<strong>使用前缀索引就用不上覆盖索引对查询性能的优化了</strong>.</p><p>对于身份证号这种类型，可以使用倒序存储，这样可以更好的使用前缀索引。</p><p>还可以使用hash字段，在表上再创建一个整数字段，来保存字段的校验码，同时在这个字段上创建索引。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/mysql/>mysql</a></li></ul><nav class=paginav><a class=next href=http://yangchnet.github.io/Dessert/posts/golang/%E5%88%87%E7%89%87append%E8%A7%84%E5%88%99/><span class=title>Next Page »</span><br><span>切片append规则</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>