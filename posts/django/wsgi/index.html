<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>wsgi | Linote</title><meta name=keywords content="wsgi,django,web"><meta name=description content="转载自：https://segmentfault.com/a/1190000011365430
 1. WSGI介绍 1.1 什么是WSGI 首先介绍几个关于WSGI相关的概念 WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python 模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Torando,Flask,Django
uwsgi:与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。
uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。
WSGI协议主要包括server和application两部分：
 WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。
 WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和applicatiodn组合实现自己的web应用。例如uWSGI和Gunicorn都是实现了WSGI server协议的服务器，Django，Flask是实现了WSGI application协议的web框架，可以根据项目实际情况搭配使用。
以上介绍了相关的常识，接下来我们来看看如何简单实现WSGI协议。
1.2 怎么实现WSGI 上文说过，实现WSGI协议必须要有wsgi server和application，因此，我们就来实现这两个东西。
我们来看看官方WSGI使用WSGI的wsgiref模块实现的小demo
def demo_app(environ,start_response): from StringIO import StringIO stdout = StringIO() print >>stdout, &#34;Hello world!&#34; print >>stdout h = environ.items(); h.sort() for k,v in h: print >>stdout, k,'=', repr(v) start_response(&#34;200 OK&#34;, [('Content-Type','text/plain')]) return [stdout."><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/django/wsgi/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="wsgi"><meta property="og:description" content="转载自：https://segmentfault.com/a/1190000011365430
 1. WSGI介绍 1.1 什么是WSGI 首先介绍几个关于WSGI相关的概念 WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python 模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Torando,Flask,Django
uwsgi:与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。
uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。
WSGI协议主要包括server和application两部分：
 WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。
 WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和applicatiodn组合实现自己的web应用。例如uWSGI和Gunicorn都是实现了WSGI server协议的服务器，Django，Flask是实现了WSGI application协议的web框架，可以根据项目实际情况搭配使用。
以上介绍了相关的常识，接下来我们来看看如何简单实现WSGI协议。
1.2 怎么实现WSGI 上文说过，实现WSGI协议必须要有wsgi server和application，因此，我们就来实现这两个东西。
我们来看看官方WSGI使用WSGI的wsgiref模块实现的小demo
def demo_app(environ,start_response): from StringIO import StringIO stdout = StringIO() print >>stdout, &#34;Hello world!&#34; print >>stdout h = environ.items(); h.sort() for k,v in h: print >>stdout, k,'=', repr(v) start_response(&#34;200 OK&#34;, [('Content-Type','text/plain')]) return [stdout."><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/django/wsgi/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-09T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-09T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="wsgi"><meta name=twitter:description content="转载自：https://segmentfault.com/a/1190000011365430
 1. WSGI介绍 1.1 什么是WSGI 首先介绍几个关于WSGI相关的概念 WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python 模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Torando,Flask,Django
uwsgi:与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。
uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。
WSGI协议主要包括server和application两部分：
 WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。
 WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和applicatiodn组合实现自己的web应用。例如uWSGI和Gunicorn都是实现了WSGI server协议的服务器，Django，Flask是实现了WSGI application协议的web框架，可以根据项目实际情况搭配使用。
以上介绍了相关的常识，接下来我们来看看如何简单实现WSGI协议。
1.2 怎么实现WSGI 上文说过，实现WSGI协议必须要有wsgi server和application，因此，我们就来实现这两个东西。
我们来看看官方WSGI使用WSGI的wsgiref模块实现的小demo
def demo_app(environ,start_response): from StringIO import StringIO stdout = StringIO() print >>stdout, &#34;Hello world!&#34; print >>stdout h = environ.items(); h.sort() for k,v in h: print >>stdout, k,'=', repr(v) start_response(&#34;200 OK&#34;, [('Content-Type','text/plain')]) return [stdout."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"wsgi","item":"http://yangchnet.github.io/Dessert/posts/django/wsgi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"wsgi","name":"wsgi","description":"转载自：https://segmentfault.com/a/1190000011365430\n 1. WSGI介绍 1.1 什么是WSGI 首先介绍几个关于WSGI相关的概念 WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python 模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Torando,Flask,Django\nuwsgi:与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。\nuWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。\nWSGI协议主要包括server和application两部分：\n WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。\n WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和applicatiodn组合实现自己的web应用。例如uWSGI和Gunicorn都是实现了WSGI server协议的服务器，Django，Flask是实现了WSGI application协议的web框架，可以根据项目实际情况搭配使用。\n以上介绍了相关的常识，接下来我们来看看如何简单实现WSGI协议。\n1.2 怎么实现WSGI 上文说过，实现WSGI协议必须要有wsgi server和application，因此，我们就来实现这两个东西。\n我们来看看官方WSGI使用WSGI的wsgiref模块实现的小demo\ndef demo_app(environ,start_response): from StringIO import StringIO stdout = StringIO() print \u0026gt;\u0026gt;stdout, \u0026#34;Hello world!\u0026#34; print \u0026gt;\u0026gt;stdout h = environ.items(); h.sort() for k,v in h: print \u0026gt;\u0026gt;stdout, k,\u0026#39;=\u0026#39;, repr(v) start_response(\u0026#34;200 OK\u0026#34;, [(\u0026#39;Content-Type\u0026#39;,\u0026#39;text/plain\u0026#39;)]) return [stdout.","keywords":["wsgi","django","web"],"articleBody":" 转载自：https://segmentfault.com/a/1190000011365430\n 1. WSGI介绍 1.1 什么是WSGI 首先介绍几个关于WSGI相关的概念 WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python 模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP 3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Torando,Flask,Django\nuwsgi:与WSGI一样是一种通信协议，是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。\nuWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。\nWSGI协议主要包括server和application两部分：\n WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。\n WSGI协议其实是定义了一种server与application解耦的规范，即可以有多个实现WSGI server的服务器，也可以有多个实现WSGI application的框架，那么就可以选择任意的server和applicatiodn组合实现自己的web应用。例如uWSGI和Gunicorn都是实现了WSGI server协议的服务器，Django，Flask是实现了WSGI application协议的web框架，可以根据项目实际情况搭配使用。\n以上介绍了相关的常识，接下来我们来看看如何简单实现WSGI协议。\n1.2 怎么实现WSGI 上文说过，实现WSGI协议必须要有wsgi server和application，因此，我们就来实现这两个东西。\n我们来看看官方WSGI使用WSGI的wsgiref模块实现的小demo\ndef demo_app(environ,start_response): from StringIO import StringIO stdout = StringIO() print stdout, \"Hello world!\" print stdout h = environ.items(); h.sort() for k,v in h: print stdout, k,'=', repr(v) start_response(\"200 OK\", [('Content-Type','text/plain')]) return [stdout.getvalue()] httpd = make_server('localhost', 8002, demo_app) httpd.serve_forever() # 使用select  实现了一个application，来获取客户端的环境和回调函数两个参数，以及httpd服务端的实现，我们来看看make_server的源代码\ndef make_server( host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler): \"\"\"Create a new WSGI server listening on `host` and `port` for `app`\"\"\" server = server_class((host, port), handler_class) server.set_app(app) return server 下面我们自己来实现一遍： WSGI 规定每个 python 程序（Application）必须是一个可调用的对象（实现了__call__ 函数的方法或者类），接受两个参数 environ（WSGI 的环境信息） 和 start_response（开始响应请求的函数），并且返回 iterable。几点说明：\nenviron 和 start_response 由 http server 提供并实现 environ 变量是包含了环境信息的字典 Application 内部在返回前调用 start_response start_response也是一个 callable，接受两个必须的参数，status（HTTP状态）和 response_headers（响应消息的头） 可调用对象要返回一个值，这个值是可迭代的。  application\n # 1. 可调用对象是一个函数 def application(environ, start_response): response_body = 'The request method was %s' % environ['REQUEST_METHOD'] # HTTP response code and message status = '200 OK' # 应答的头部是一个列表，每对键值都必须是一个 tuple。 response_headers = [('Content-Type', 'text/plain'), ('Content-Length', str(len(response_body)))] # 调用服务器程序提供的 start_response，填入两个参数 start_response(status, response_headers) # 返回必须是 iterable return [response_body] # 2. 可调用对象是一个类 class AppClass: \"\"\"这里的可调用对象就是 AppClass 这个类，调用它就能生成可以迭代的结果。 使用方法类似于： for result in AppClass(env, start_response): do_somthing(result) \"\"\" def __init__(self, environ, start_response): self.environ = environ self.start = start_response def __iter__(self): status = '200 OK' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield \"Hello world!\\n\" # 3. 可调用对象是一个实例  class AppClass: \"\"\"这里的可调用对象就是 AppClass 的实例，使用方法类似于： app = AppClass() for result in app(environ, start_response): do_somthing(result) \"\"\" def __init__(self): pass def __call__(self, environ, start_response): status = '200 OK' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield \"Hello world!\\n\"  server\n 上面已经说过，标准要能够确切地实行，必须要求程序端和服务器端共同遵守。上面提到， envrion 和 start_response 都是服务器端提供的。下面就看看，服务器端要履行的义务。\n准备 environ 参数 定义 start_response 函数 调用程序端的可调用对象 import os, sys def run_with_cgi(application): # application 是程序端的可调用对象 # 准备 environ 参数，这是一个字典，里面的内容是一次 HTTP 请求的环境变量 environ = dict(os.environ.items()) environ['wsgi.input'] = sys.stdin environ['wsgi.errors'] = sys.stderr environ['wsgi.version'] = (1, 0) environ['wsgi.multithread'] = False environ['wsgi.multiprocess'] = True environ['wsgi.run_once'] = True environ['wsgi.url_scheme'] = 'http' headers_set = [] headers_sent = [] # 把应答的结果输出到终端 def write(data): sys.stdout.write(data) sys.stdout.flush() # 实现 start_response 函数，根据程序端传过来的 status 和 response_headers 参数， # 设置状态和头部 def start_response(status, response_headers, exc_info=None): headers_set[:] = [status, response_headers] return write # 调用客户端的可调用对象，把准备好的参数传递过去 result = application(environ, start_response) # 处理得到的结果，这里简单地把结果输出到标准输出。 try: for data in result: if data: # don't send headers until body appears write(data) finally: if hasattr(result, 'close'): result.close() 2. 由Django框架分析WSGI 下面我们以django为例，分析一下wsgi的整个流程\n2.1 django WSGI application WSGI application应该实现为一个可调用iter对象，例如函数、方法、类(包含call方法)。需要接收两个参数：一个字典，该字典可以包含了客户端请求的信息以及其他信息，可以认为是请求上下文，一般叫做environment（编码中多简写为environ、env），一个用于发送HTTP响应状态（HTTP status）、响应头（HTTP headers）的回调函数,也就是start_response()。通过回调函数将响应状态和响应头返回给server，同时返回响应正文(response body)，响应正文是可迭代的、并包含了多个字符串。 下面是Django中application的具体实现部分：\n# 继承, 但只实现了 __call__ 方法, 方便使用 class WSGIHandler(base.BaseHandler): initLock = Lock() # 可以将其视为一个代表 http 请求的类 request_class = WSGIRequest # WSGIHandler 也可以作为函数来调用 def __call__(self, environ, start_response): # Set up middleware if needed. We couldn't do this earlier, because # settings weren't available. # 这里的检测: 因为 self._request_middleware 是最后才设定的, 所以如果为空, # 很可能是因为 self.load_middleware() 没有调用成功. if self._request_middleware is None: with self.initLock: try: # Check that middleware is still uninitialised. if self._request_middleware is None: 因为 load_middleware() 可能没有调用, 调用一次. self.load_middleware() except: # Unload whatever middleware we got self._request_middleware = None raise set_script_prefix(base.get_script_name(environ)) signls.request_started.send(sender=self.__class__) # __class__ 代表自己的类 try: # 实例化 request_class = WSGIRequest, 将在日后文章中展开, 可以将其视为一个代表 http 请求的类 request = self.request_class(environ) except UnicodeDecodeError: logger.warning('Bad Request (UnicodeDecodeError)', exc_info=sys.exc_info(), extra={ 'status_code': 400, } ) response = http.HttpResponseBadRequest() else: # 调用 self.get_response(), 将会返回一个相应对象 response\n############# 关键的操作, self.response() 可以获取响应数据.  response = self.get_response(request) # 将 self 挂钩到 response 对象 response._handler_class = self.__class__ try: status_text = STATUS_CODE_TEXT[response.status_code] except KeyError: status_text = 'UNKNOWN STATUS CODE' # 状态码 status = '%s%s' % (response.status_code, status_text) response_headers = [(str(k), str(v)) for k, v in response.items()] # 对于每个一个 cookie, 都在 header 中设置: Set-cookie xxx=yyy for c in response.cookies.values(): response_headers.append((str('Set-Cookie'), str(c.output(header='')))) # start_response() 操作已经在上节中介绍了 start_response(force_str(status), response_headers) # 成功返回相应对象 return response 可以看出application的流程包括:加载所有中间件，以及执行框架相关的操作，设置当前线程脚本前缀，发送请求开始信号；处理请求，调用get_response()方法处理当前请求，该方法的的主要逻辑是通过urlconf找到对应的view和callback，按顺序执行各种middleware和callback。调用由server传入的start_response()方法将响应header与status返回给server。返回响应正文\n2.2 django WSGI Server 负责获取http请求，将请求传递给WSGI application，由application处理请求后返回response。以Django内建server为例看一下具体实现。通过runserver运行django 项目，在启动时都会调用下面的run方法，创建一个WSGIServer的实例，之后再调用其serve_forever()方法启动服务。\ndef run(addr, port, wsgi_handler, ipv6=False, threading=False): server_address = (addr, port) if threading: httpd_cls = type(str('WSGIServer'), (socketserver.ThreadingMixIn, WSGIServer), {}) else: httpd_cls = WSGIServer # 这里的wsgi_handler就是WSGIApplication  httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6) if threading: httpd.daemon_threads = True httpd.set_app(wsgi_handler) httpd.serve_forever() 下面表示WSGI server服务器处理流程中关键的类和方法。\n**WSGIServerrun()**方法会创建WSGIServer实例，主要作用是接收客户端请求，将请求传递给application，然后将application返回的response返回给客户端。 创建实例时会指定HTTP请求的handler：WSGIRequestHandler类 通过set_app和get_app方法设置和获取WSGIApplication实例wsgi_handler 处理http请求时，调用handler_request方法，会创建WSGIRequestHandler 实例处理http请求。 WSGIServer中get_request方法通过socket接受请求数据\nWSGIRequestHandler 由WSGIServer在调用handle_request时创建实例，传入request、cient_address、WSGIServer三个参数，__init__方法在实例化同时还会调用自身的handle方法handle方法会创建ServerHandler实例，然后调用其run方法处理请求\nServerHandler WSGIRequestHandler在其handle方法中调用run方法，传入self.server.get_app()参数，获取WSGIApplication，然后调用实例(call)，获取response，其中会传入start_response回调，用来处理返回的header和status。通过application获取response以后，通过finish_response返回response\nWSGIHandler WSGI协议中的application，接收两个参数，environ字典包含了客户端请求的信息以及其他信息，可以认为是请求上下文，start_response用于发送返回status和header的回调函数\n虽然上面一个WSGI server涉及到多个类实现以及相互引用，但其实原理还是调用WSGIHandler，传入请求参数以及回调方法start_response()，并将响应返回给客户端\n","wordCount":"631","inLanguage":"en","datePublished":"2021-04-09T00:00:00Z","dateModified":"2021-04-09T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/django/wsgi/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>wsgi</h1><div class=post-meta><span title="2021-04-09 00:00:00 +0000 UTC">April 9, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-wsgi%e4%bb%8b%e7%bb%8d aria-label="1. WSGI介绍">1. WSGI介绍</a><ul><li><a href=#11-%e4%bb%80%e4%b9%88%e6%98%afwsgi aria-label="1.1 什么是WSGI">1.1 什么是WSGI</a></li><li><a href=#12-%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0wsgi aria-label="1.2 怎么实现WSGI">1.2 怎么实现WSGI</a></li></ul></li><li><a href=#2-%e7%94%b1django%e6%a1%86%e6%9e%b6%e5%88%86%e6%9e%90wsgi aria-label="2. 由Django框架分析WSGI">2. 由Django框架分析WSGI</a><ul><li><a href=#21-django-wsgi-application aria-label="2.1 django WSGI application">2.1 django WSGI application</a></li><li><a href=#22-django-wsgi-server aria-label="2.2 django WSGI Server">2.2 django WSGI Server</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>转载自：https://segmentfault.com/a/1190000011365430</p></blockquote><h2 id=1-wsgi介绍>1. WSGI介绍<a hidden class=anchor aria-hidden=true href=#1-wsgi介绍>#</a></h2><h3 id=11-什么是wsgi>1.1 什么是WSGI<a hidden class=anchor aria-hidden=true href=#11-什么是wsgi>#</a></h3><p>首先介绍几个关于WSGI相关的概念
WSGI：全称是<code>Web Server Gateway Interface</code>，<code>WSGI</code>不是服务器，<code>python</code>
模块，框架，API或者任何软件，只是一种规范，描述<code>web server</code>如何与<code>web application</code>通信的规范。<code>server</code>和<code>application</code>的规范在<code>PEP 3333</code>中有具体描述。要实现<code>WSGI</code>协议，必须同时实现<code>web server</code>和<code>web application</code>，当前运行在<code>WSGI</code>协议之上的web框架有<code>Torando,Flask,Django</code></p><p><code>uwsgi</code>:与<code>WSGI</code>一样是一种通信协议，是<code>uWSGI</code>服务器的独占协议，用于定义传输信息的类型(type of information)，每一个<code>uwsgi packet</code>前4byte为传输信息类型的描述，与<code>WSGI</code>协议是两种东西，据说该协议是<code>fcgi</code>协议的10倍快。</p><p><code>uWSGI</code>：是一个web服务器，实现了<code>WSGI</code>协议、<code>uwsgi</code>协议、<code>http</code>协议等。</p><p>WSGI协议主要包括<code>server</code>和<code>application</code>两部分：</p><blockquote><p><code>WSGI server</code>负责从客户端接收请求，将<code>request</code>转发给<code>application</code>，将<code>application</code>返回的<code>response</code>返回给客户端；
<code>WSGI application</code>接收由<code>server</code>转发的<code>request</code>，处理请求，并将处理结果返回给<code>server</code>。<code>application</code>中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现<code>server</code>与<code>application</code>，因此可以在<code>WSGI</code>服务器与<code>WSGI</code>应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。</p></blockquote><p><code>WSGI</code>协议其实是定义了一种<code>server</code>与<code>application</code>解耦的规范，即可以有多个实现<code>WSGI server</code>的服务器，也可以有多个实现<code>WSGI application</code>的框架，那么就可以选择任意的<code>server</code>和<code>applicatiodn</code>组合实现自己的web应用。例如<code>uWSGI</code>和<code>Gunicorn</code>都是实现了<code>WSGI server</code>协议的服务器，<code>Django</code>，<code>Flask</code>是实现了<code>WSGI application</code>协议的web框架，可以根据项目实际情况搭配使用。</p><p>以上介绍了相关的常识，接下来我们来看看如何简单实现WSGI协议。</p><h3 id=12-怎么实现wsgi>1.2 怎么实现WSGI<a hidden class=anchor aria-hidden=true href=#12-怎么实现wsgi>#</a></h3><p>上文说过，实现<code>WSGI</code>协议必须要有<code>wsgi server</code>和<code>application</code>，因此，我们就来实现这两个东西。<br>我们来看看官方WSGI使用WSGI的wsgiref模块实现的小demo</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>demo_app</span>(environ,start_response):  
    <span style=color:#f92672>from</span> StringIO <span style=color:#f92672>import</span> StringIO  
    stdout <span style=color:#f92672>=</span> StringIO()  
    <span style=color:#66d9ef>print</span> <span style=color:#f92672>&gt;&gt;</span>stdout, <span style=color:#e6db74>&#34;Hello world!&#34;</span>  
    <span style=color:#66d9ef>print</span> <span style=color:#f92672>&gt;&gt;</span>stdout  
    h <span style=color:#f92672>=</span> environ<span style=color:#f92672>.</span>items(); h<span style=color:#f92672>.</span>sort()  
    <span style=color:#66d9ef>for</span> k,v <span style=color:#f92672>in</span> h:  
        <span style=color:#66d9ef>print</span> <span style=color:#f92672>&gt;&gt;</span>stdout, k,<span style=color:#e6db74>&#39;=&#39;</span>, repr(v)  
    start_response(<span style=color:#e6db74>&#34;200 OK&#34;</span>, [(<span style=color:#e6db74>&#39;Content-Type&#39;</span>,<span style=color:#e6db74>&#39;text/plain&#39;</span>)])  
    <span style=color:#66d9ef>return</span> [stdout<span style=color:#f92672>.</span>getvalue()]  
  
httpd <span style=color:#f92672>=</span> make_server(<span style=color:#e6db74>&#39;localhost&#39;</span>, <span style=color:#ae81ff>8002</span>,  demo_app)  
httpd<span style=color:#f92672>.</span>serve_forever()  <span style=color:#75715e># 使用select  </span>
</code></pre></div><p>实现了一个application，来获取客户端的环境和回调函数两个参数，以及httpd服务端的实现，我们来看看make_server的源代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_server</span>(  
    host, port, app, server_class<span style=color:#f92672>=</span>WSGIServer, handler_class<span style=color:#f92672>=</span>WSGIRequestHandler):  
    <span style=color:#e6db74>&#34;&#34;&#34;Create a new WSGI server listening on `host` and `port` for `app`&#34;&#34;&#34;</span>  
    server <span style=color:#f92672>=</span> server_class((host, port), handler_class)  
    server<span style=color:#f92672>.</span>set_app(app)  
    <span style=color:#66d9ef>return</span> server
</code></pre></div><p>下面我们自己来实现一遍：
WSGI 规定每个 python 程序（Application）必须是一个可调用的对象（实现了__call__ 函数的方法或者类），接受两个参数 environ（WSGI 的环境信息） 和 start_response（开始响应请求的函数），并且返回 iterable。几点说明：</p><pre><code>environ 和 start_response 由 http server 提供并实现
environ 变量是包含了环境信息的字典
Application 内部在返回前调用 start_response
start_response也是一个 callable，接受两个必须的参数，status（HTTP状态）和 response_headers（响应消息的头）
可调用对象要返回一个值，这个值是可迭代的。
</code></pre><blockquote><p>application</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python> <span style=color:#75715e># 1. 可调用对象是一个函数</span>
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>application</span>(environ, start_response):
 
    response_body <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;The request method was </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> environ[<span style=color:#e6db74>&#39;REQUEST_METHOD&#39;</span>]
    
    <span style=color:#75715e># HTTP response code and message</span>
    status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;200 OK&#39;</span>
    
    <span style=color:#75715e># 应答的头部是一个列表，每对键值都必须是一个 tuple。</span>
    response_headers <span style=color:#f92672>=</span> [(<span style=color:#e6db74>&#39;Content-Type&#39;</span>, <span style=color:#e6db74>&#39;text/plain&#39;</span>),
                        (<span style=color:#e6db74>&#39;Content-Length&#39;</span>, str(len(response_body)))]
    
    <span style=color:#75715e># 调用服务器程序提供的 start_response，填入两个参数</span>
    start_response(status, response_headers)
    
    <span style=color:#75715e># 返回必须是 iterable</span>
    <span style=color:#66d9ef>return</span> [response_body]    
   
<span style=color:#75715e># 2. 可调用对象是一个类</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppClass</span>:
    <span style=color:#e6db74>&#34;&#34;&#34;这里的可调用对象就是 AppClass 这个类，调用它就能生成可以迭代的结果。
</span><span style=color:#e6db74>        使用方法类似于： 
</span><span style=color:#e6db74>        for result in AppClass(env, start_response):
</span><span style=color:#e6db74>            do_somthing(result)
</span><span style=color:#e6db74>    &#34;&#34;&#34;</span>

    <span style=color:#66d9ef>def</span> __init__(self, environ, start_response):
        self<span style=color:#f92672>.</span>environ <span style=color:#f92672>=</span> environ
        self<span style=color:#f92672>.</span>start <span style=color:#f92672>=</span> start_response

    <span style=color:#66d9ef>def</span> __iter__(self):
        status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;200 OK&#39;</span>
        response_headers <span style=color:#f92672>=</span> [(<span style=color:#e6db74>&#39;Content-type&#39;</span>, <span style=color:#e6db74>&#39;text/plain&#39;</span>)]
        self<span style=color:#f92672>.</span>start(status, response_headers)
        <span style=color:#66d9ef>yield</span> <span style=color:#e6db74>&#34;Hello world!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
 
<span style=color:#75715e># 3. 可调用对象是一个实例 </span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AppClass</span>:
    <span style=color:#e6db74>&#34;&#34;&#34;这里的可调用对象就是 AppClass 的实例，使用方法类似于： 
</span><span style=color:#e6db74>        app = AppClass()
</span><span style=color:#e6db74>        for result in app(environ, start_response):
</span><span style=color:#e6db74>             do_somthing(result)
</span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
 
    <span style=color:#66d9ef>def</span> __init__(self):
        <span style=color:#66d9ef>pass</span>
 
    <span style=color:#66d9ef>def</span> __call__(self, environ, start_response):
        status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;200 OK&#39;</span>
        response_headers <span style=color:#f92672>=</span> [(<span style=color:#e6db74>&#39;Content-type&#39;</span>, <span style=color:#e6db74>&#39;text/plain&#39;</span>)]
        self<span style=color:#f92672>.</span>start(status, response_headers)
        <span style=color:#66d9ef>yield</span> <span style=color:#e6db74>&#34;Hello world!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>
</code></pre></div><blockquote><p>server</p></blockquote><p>上面已经说过，标准要能够确切地实行，必须要求程序端和服务器端共同遵守。上面提到， envrion 和 start_response 都是服务器端提供的。下面就看看，服务器端要履行的义务。</p><pre><code>准备 environ 参数
定义 start_response 函数
调用程序端的可调用对象
</code></pre><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> os<span style=color:#f92672>,</span> sys
 
<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run_with_cgi</span>(application):    <span style=color:#75715e># application 是程序端的可调用对象</span>
    <span style=color:#75715e># 准备 environ 参数，这是一个字典，里面的内容是一次 HTTP 请求的环境变量</span>
    environ <span style=color:#f92672>=</span> dict(os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>items())
    environ[<span style=color:#e6db74>&#39;wsgi.input&#39;</span>]        <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>stdin
    environ[<span style=color:#e6db74>&#39;wsgi.errors&#39;</span>]       <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>stderr
    environ[<span style=color:#e6db74>&#39;wsgi.version&#39;</span>]      <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)
    environ[<span style=color:#e6db74>&#39;wsgi.multithread&#39;</span>]  <span style=color:#f92672>=</span> False
    environ[<span style=color:#e6db74>&#39;wsgi.multiprocess&#39;</span>] <span style=color:#f92672>=</span> True
    environ[<span style=color:#e6db74>&#39;wsgi.run_once&#39;</span>]     <span style=color:#f92672>=</span> True            
    environ[<span style=color:#e6db74>&#39;wsgi.url_scheme&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;http&#39;</span>
 
    headers_set <span style=color:#f92672>=</span> []
    headers_sent <span style=color:#f92672>=</span> []
 
    <span style=color:#75715e># 把应答的结果输出到终端</span>
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>write</span>(data):
        sys<span style=color:#f92672>.</span>stdout<span style=color:#f92672>.</span>write(data)
        sys<span style=color:#f92672>.</span>stdout<span style=color:#f92672>.</span>flush()
 
    <span style=color:#75715e># 实现 start_response 函数，根据程序端传过来的 status 和 response_headers 参数，</span>
    <span style=color:#75715e># 设置状态和头部</span>
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>start_response</span>(status, response_headers, exc_info<span style=color:#f92672>=</span>None):
        headers_set[:] <span style=color:#f92672>=</span> [status, response_headers]
          <span style=color:#66d9ef>return</span> write
 
    <span style=color:#75715e># 调用客户端的可调用对象，把准备好的参数传递过去</span>
    result <span style=color:#f92672>=</span> application(environ, start_response)
    
    <span style=color:#75715e># 处理得到的结果，这里简单地把结果输出到标准输出。</span>
    <span style=color:#66d9ef>try</span>:
        <span style=color:#66d9ef>for</span> data <span style=color:#f92672>in</span> result:
            <span style=color:#66d9ef>if</span> data:    <span style=color:#75715e># don&#39;t send headers until body appears</span>
                write(data)
    <span style=color:#66d9ef>finally</span>:
        <span style=color:#66d9ef>if</span> hasattr(result, <span style=color:#e6db74>&#39;close&#39;</span>):
            result<span style=color:#f92672>.</span>close()
</code></pre></div><h2 id=2-由django框架分析wsgi>2. 由Django框架分析WSGI<a hidden class=anchor aria-hidden=true href=#2-由django框架分析wsgi>#</a></h2><p>下面我们以django为例，分析一下wsgi的整个流程</p><h3 id=21-django-wsgi-application>2.1 django WSGI application<a hidden class=anchor aria-hidden=true href=#21-django-wsgi-application>#</a></h3><p><code>WSGI application</code>应该实现为一个可调用<code>iter</code>对象，例如函数、方法、类(包含<strong>call</strong>方法)。需要接收两个参数：一个字典，该字典可以包含了客户端请求的信息以及其他信息，可以认为是请求上下文，一般叫做<code>environment</code>（编码中多简写为<code>environ、env</code>），一个用于发送HTTP响应状态（<code>HTTP status</code>）、响应头（<code>HTTP headers</code>）的回调函数,也就是start_response()。通过回调函数将响应状态和响应头返回给server，同时返回响应正文(<code>response body</code>)，响应正文是可迭代的、并包含了多个字符串。
下面是<code>Django</code>中<code>application</code>的具体实现部分：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 继承, 但只实现了 __call__ 方法, 方便使用</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WSGIHandler</span>(base<span style=color:#f92672>.</span>BaseHandler):
    initLock <span style=color:#f92672>=</span> Lock()
 
    <span style=color:#75715e># 可以将其视为一个代表 http 请求的类</span>
    request_class <span style=color:#f92672>=</span> WSGIRequest
 
    <span style=color:#75715e># WSGIHandler 也可以作为函数来调用</span>
    <span style=color:#66d9ef>def</span> __call__(self, environ, start_response):
        <span style=color:#75715e># Set up middleware if needed. We couldn&#39;t do this earlier, because</span>
        <span style=color:#75715e># settings weren&#39;t available.</span>
 
        <span style=color:#75715e># 这里的检测: 因为 self._request_middleware 是最后才设定的, 所以如果为空,</span>
        <span style=color:#75715e># 很可能是因为 self.load_middleware() 没有调用成功.</span>
        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>_request_middleware <span style=color:#f92672>is</span> None:
            <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>initLock:
                <span style=color:#66d9ef>try</span>:
                    <span style=color:#75715e># Check that middleware is still uninitialised.</span>
                    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>_request_middleware <span style=color:#f92672>is</span> None:
                        <span style=color:#960050;background-color:#1e0010>因为</span> load_middleware() <span style=color:#960050;background-color:#1e0010>可能没有调用</span>, <span style=color:#960050;background-color:#1e0010>调用一次</span><span style=color:#f92672>.</span>
                        self<span style=color:#f92672>.</span>load_middleware()
                <span style=color:#66d9ef>except</span>:
                    <span style=color:#75715e># Unload whatever middleware we got</span>
                    self<span style=color:#f92672>.</span>_request_middleware <span style=color:#f92672>=</span> None
                    <span style=color:#66d9ef>raise</span>
 
        set_script_prefix(base<span style=color:#f92672>.</span>get_script_name(environ))
        signls<span style=color:#f92672>.</span>request_started<span style=color:#f92672>.</span>send(sender<span style=color:#f92672>=</span>self<span style=color:#f92672>.</span>__class__) <span style=color:#75715e># __class__ 代表自己的类</span>
 
        <span style=color:#66d9ef>try</span>:
            <span style=color:#75715e># 实例化 request_class = WSGIRequest, 将在日后文章中展开, 可以将其视为一个代表 http 请求的类</span>
            request <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>request_class(environ)
 
        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>UnicodeDecodeError</span>:
            logger<span style=color:#f92672>.</span>warning(<span style=color:#e6db74>&#39;Bad Request (UnicodeDecodeError)&#39;</span>,
                exc_info<span style=color:#f92672>=</span>sys<span style=color:#f92672>.</span>exc_info(),
                extra<span style=color:#f92672>=</span>{
                    <span style=color:#e6db74>&#39;status_code&#39;</span>: <span style=color:#ae81ff>400</span>,
                }
            )
            response <span style=color:#f92672>=</span> http<span style=color:#f92672>.</span>HttpResponseBadRequest()
        <span style=color:#66d9ef>else</span>:
            <span style=color:#75715e># 调用 self.get_response(), 将会返回一个相应对象 response&lt;br&gt;            ############# 关键的操作, self.response() 可以获取响应数据.          </span>
            response <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>get_response(request)
 
        <span style=color:#75715e># 将 self 挂钩到 response 对象</span>
        response<span style=color:#f92672>.</span>_handler_class <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__class__
 
        <span style=color:#66d9ef>try</span>:
            status_text <span style=color:#f92672>=</span> STATUS_CODE_TEXT[response<span style=color:#f92672>.</span>status_code]
        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
            status_text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;UNKNOWN STATUS CODE&#39;</span>
 
         <span style=color:#75715e># 状态码</span>
        status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (response<span style=color:#f92672>.</span>status_code, status_text)
 
        response_headers <span style=color:#f92672>=</span> [(str(k), str(v)) <span style=color:#66d9ef>for</span> k, v <span style=color:#f92672>in</span> response<span style=color:#f92672>.</span>items()]
 
        <span style=color:#75715e># 对于每个一个 cookie, 都在 header 中设置: Set-cookie xxx=yyy</span>
        <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> response<span style=color:#f92672>.</span>cookies<span style=color:#f92672>.</span>values():
            response_headers<span style=color:#f92672>.</span>append((str(<span style=color:#e6db74>&#39;Set-Cookie&#39;</span>), str(c<span style=color:#f92672>.</span>output(header<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&#39;</span>))))
 
        <span style=color:#75715e># start_response() 操作已经在上节中介绍了</span>
        start_response(force_str(status), response_headers)
 
        <span style=color:#75715e># 成功返回相应对象</span>
        <span style=color:#66d9ef>return</span> response
</code></pre></div><p>可以看出application的流程包括:加载所有中间件，以及执行框架相关的操作，设置当前线程脚本前缀，发送请求开始信号；处理请求，调用get_response()方法处理当前请求，该方法的的主要逻辑是通过urlconf找到对应的view和callback，按顺序执行各种middleware和callback。调用由server传入的start_response()方法将响应header与status返回给server。返回响应正文</p><h3 id=22-django-wsgi-server>2.2 django WSGI Server<a hidden class=anchor aria-hidden=true href=#22-django-wsgi-server>#</a></h3><p>负责获取http请求，将请求传递给WSGI application，由application处理请求后返回response。以Django内建server为例看一下具体实现。通过runserver运行django
项目，在启动时都会调用下面的run方法，创建一个WSGIServer的实例，之后再调用其serve_forever()方法启动服务。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(addr, port, wsgi_handler, ipv6<span style=color:#f92672>=</span>False, threading<span style=color:#f92672>=</span>False): 
    server_address <span style=color:#f92672>=</span> (addr, port) 
    <span style=color:#66d9ef>if</span> threading: 
        httpd_cls <span style=color:#f92672>=</span> type(str(<span style=color:#e6db74>&#39;WSGIServer&#39;</span>), (socketserver<span style=color:#f92672>.</span>ThreadingMixIn, WSGIServer), {}) 
    <span style=color:#66d9ef>else</span>: 
        httpd_cls <span style=color:#f92672>=</span> WSGIServer <span style=color:#75715e># 这里的wsgi_handler就是WSGIApplication </span>
        httpd <span style=color:#f92672>=</span> httpd_cls(server_address, WSGIRequestHandler, ipv6<span style=color:#f92672>=</span>ipv6) 
    <span style=color:#66d9ef>if</span> threading: 
        httpd<span style=color:#f92672>.</span>daemon_threads <span style=color:#f92672>=</span> True httpd<span style=color:#f92672>.</span>set_app(wsgi_handler)    
    httpd<span style=color:#f92672>.</span>serve_forever()
</code></pre></div><p>下面表示WSGI server服务器处理流程中关键的类和方法。</p><p>**WSGIServerrun()**方法会创建WSGIServer实例，主要作用是接收客户端请求，将请求传递给application，然后将application返回的response返回给客户端。
创建实例时会指定HTTP请求的handler：WSGIRequestHandler类
通过set_app和get_app方法设置和获取WSGIApplication实例wsgi_handler
处理http请求时，调用handler_request方法，会创建WSGIRequestHandler
实例处理http请求。
WSGIServer中get_request方法通过socket接受请求数据</p><p><strong>WSGIRequestHandler</strong> 由WSGIServer在调用handle_request时创建实例，传入request、cient_address、WSGIServer三个参数，__init__方法在实例化同时还会调用自身的handle方法handle方法会创建ServerHandler实例，然后调用其run方法处理请求</p><p><strong>ServerHandler</strong> WSGIRequestHandler在其handle方法中调用run方法，传入self.server.get_app()参数，获取WSGIApplication，然后调用实例(<strong>call</strong>)，获取response，其中会传入start_response回调，用来处理返回的header和status。通过application获取response以后，通过finish_response返回response</p><p><strong>WSGIHandler</strong> WSGI协议中的application，接收两个参数，environ字典包含了客户端请求的信息以及其他信息，可以认为是请求上下文，start_response用于发送返回status和header的回调函数</p><p>虽然上面一个WSGI server涉及到多个类实现以及相互引用，但其实原理还是调用WSGIHandler，传入请求参数以及回调方法start_response()，并将响应返回给客户端</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/wsgi/>wsgi</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/django/>Django</a></li><li><a href=http://yangchnet.github.io/Dessert/tags/web/>web</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/golang/%E9%9D%A2%E8%AF%95%E9%A2%98/><span class=title>« Prev Page</span><br><span>面试题golang</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/orm%E7%AE%80%E4%BB%8B/><span class=title>Next Page »</span><br><span>ORM简介</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>