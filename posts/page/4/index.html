<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Linote</title><meta name=keywords content><meta name=description content="Posts - Linote"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><link rel=alternate type=application/rss+xml href=http://yangchnet.github.io/Dessert/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>端口消耗问题</h2></header><section class=entry-content><p>1. 两种端口 我们知道TCP/UDP在工作时都需要一个端口来进行收发信息，有两种类型的端口：
临时端口或者叫动态端口，是默认情况下计算机进行出站连接时所有的端口集 已知端口，是特定应用程序或服务的定义端口。 例如，文件服务器服务在端口 445 上，HTTPS 为 443，HTTP 为 80，RPC 为 135。 自定义应用程序还将具有其定义的端口号。 客户端要想连接到应用程序或服务，需要使用计算机中的临时端口去连接服务器的已知端口。如：客户端计算机上的浏览器将使用临时端口连接到端口 https://www.microsoft.com 443。
当浏览器创建与多个网站的大量连接的情况下，其所尝试的任何新连接都将使用临时端口。 一段时间之后，连接将开始失败，并且出现此故障的可能性很高，因为浏览器已使用所有可用端口进行外部连接，并且建立连接的任何新尝试都将失败，因为没有更多的端口可用。 当使用计算机上的所有端口时，我们将它视为端口耗尽。
2. TCP/IP的默认动态端口范围 window上有两种动态端口范围：
起始端口49152，结束端口65535 （新版） 起始端口1025，结束端口5000（旧版） 可使用如下命令查看计算机上动态端口范围：
netsh int ipv4 show dynamicport tcp netsh int ipv4 show dynamicport udp netsh int ipv6 show dynamicport tcp netsh int ipv6 show dynamicport udp 也可以手动更改动态端口的范围：
netsh int &lt;ipv4|ipv6> set dynamic &lt;tcp|udp> start=number num=range 其中start是起始端口号，num是范围
例如：
netsh int ipv4 set dynamicport tcp start=10000 num=1000 netsh int ipv4 set dynamicport udp start=10000 num=1000 netsh int ipv6 set dynamicport tcp start=10000 num=1000 netsh int ipv6 set dynamicport udp start=10000 num=1000 这些示例命令将动态端口范围设置为从10000开始，分配1000个动态端口，即：10000-19999。可以设置的最小端口范围是255，可以设置的最小起始端口为1025。若要复制 Windows Server 2003 的默认行为，请使用 1025 作为起始端口，然后使用 3976 作为 TCP 和 UDP 的范围。 这导致起始端口为 1025，结束端口为 5000。</p></section><footer class=entry-footer><span title="2021-09-28 00:00:00 +0000 UTC">September 28, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 端口消耗问题" href=http://yangchnet.github.io/Dessert/posts/windows/%E7%AB%AF%E5%8F%A3%E6%B6%88%E8%80%97%E9%97%AE%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2>golang中的tag</h2></header><section class=entry-content><p>1. tag的基本介绍 字段标签可以存储元信息，这些元信息可以使用反射来访问。通常这些元信息用来提供一个字段如何从一种格式编码至另一种格式的相关信息（或是数据应如何在数据库中存储等）。但实际上标签可以存储任何你想要的元信息，无论是你自己使用还是由另一个包使用。
就像reflect.StructTag文档中提到的那样，字段标签通常是由空格分割的key:"value"列表，例如：
type User struct { Name string `json:"name" xml:"name"` } 其中的key通常表示后面"value"所对应的包，例如json这个key将被encoding/json这个包使用。
如果需要在"value"中传递多个值，那么通常使用,逗号来分割，例如：
Name string `json:"name,omitempty" xml:"name"` 值为破折号通常代表在处理时忽略该字段，例如在json中代表不要序列化这个字段
2. 例子：获取自定义tag 我们可以使用反射包来获取结构体字段的值。首先我们需要获取结构体的Type，然后查询字段，可以使用Type.Field(i int)或者Type.FieldByName(name string)。这些方法返回一个代表结构体字段的StructField值和一个代表tag的类型为StructTag的StructField.Tag值。
前面我们提到，字段标签通常是由空格分割的key:"value"列表，如果你的确是这么做的，你可以使用StructTag.Get(key string)这个方法来获取这个key对应的value。如果你不是这么做的，Get()方法可能不能解析key:"value"对并找到你想要的标签。如果你没有遵循字段标签通常是由空格分割的key:"value"列表，那么你可能需要实现自己的解析逻辑。
go1.7中添加了StructTag.Lookup()方法，这个方法的行为类似于Get()，但其将不包含给定键的标签与将空字符串与给定键相关联的标签区分开来。
来看下面这个例子：
type User struct { Name string `mytag:"MyName"` Email stirng `mytag:"MyEmail"` } u := User{"Bob", "bob@cc.com"} t := reflect.TypeOf(u) for _ fieldName := range []string{"Name", "Email"} { field, found := t.FieldByName(fieldName) if !found { continue } fmt.Printf("\nField: User.%s\n", fieldName) fmt.Printf("\tWhole tag value : %q\n", field....</p></section><footer class=entry-footer><span title="2021-09-14 00:00:00 +0000 UTC">September 14, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to golang中的tag" href=http://yangchnet.github.io/Dessert/posts/golang/golang%E4%B8%AD%E7%9A%84tag/></a></article><article class=post-entry><header class=entry-header><h2>vagrant+ansible安装k8s集群</h2></header><section class=entry-content><p>部署环境： ubuntu20.04， 8G+4核 kubernete版本： 1.22.1
1. 安装vagrant和ansible 按官网教程即可
2. Vagrantfile 建立如下目录
k8s-cluster ├── kubernetes-setup │ ├── master-playbook.yml │ └── node-playbook.yml └── Vagrantfile 其中，Vagrantfile内容如下：
IMAGE_NAME = "bento/ubuntu-16.04" N = 2 Vagrant.configure("2") do |config| config.ssh.insert_key = false config.vm.provider "virtualbox" do |v| v.memory = 2048 v.cpus = 2 end config.vm.define "k8s-master" do |master| master.vm.box = IMAGE_NAME master.vm.network "private_network", ip: "192.168.50.10" master.vm.hostname = "k8s-master" master.vm.provision "ansible" do |ansible| ansible.playbook = "kubernetes-setup/master-playbook.yml" ansible.extra_vars = { node_ip: "192....</p></section><footer class=entry-footer><span title="2021-09-06 00:00:00 +0000 UTC">September 6, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to vagrant+ansible安装k8s集群" href=http://yangchnet.github.io/Dessert/posts/dockerk8s/vagrant+ansible%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/></a></article><article class=post-entry><header class=entry-header><h2>使用kubeadm安装单节点Kubernetes</h2></header><section class=entry-content><p>环境：ubuntu-20.04, kubernetes:v1.22.1
1. 安装docker 安装时有可能会遇到网络问题，你可以选择换源或是为apt设置代理，设置代理的方法见这里
更新源镜像并安装依赖 sudo apt-get update sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ gnupg \ lsb-release 安装docker 官方GPG密钥 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 设置稳定版本 echo \ "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs)stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 安装docker sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd....</p></section><footer class=entry-footer><span title="2021-09-04 00:00:00 +0000 UTC">September 4, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 使用kubeadm安装单节点Kubernetes" href=http://yangchnet.github.io/Dessert/posts/env/%E4%BD%BF%E7%94%A8kubeadm%E5%AE%89%E8%A3%85%E5%8D%95%E8%8A%82%E7%82%B9kubernetes/></a></article><article class=post-entry><header class=entry-header><h2>为apt设置代理</h2></header><section class=entry-content><p>1. 临时设置 sudo apt-get -o Acquire::http::proxy="http://127.0.0.1:8000/" update 2. 永久设置 创建/etc/apt/apt.conf
touch /etc/apt/apt.conf 写入如下内容：
Acquire::http::Proxy "http://yourproxyaddress:proxyport"; 如果proxy需要密码，则格式如下：
Acquire::http::Proxy "http://username:password@yourproxyaddress:proxyport"; Reference: https://www.jianshu.com/p/fdae9cb5181b
https://askubuntu.com/questions/257290/configure-proxy-for-apt</p></section><footer class=entry-footer><span title="2021-09-03 00:00:00 +0000 UTC">September 3, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 为apt设置代理" href=http://yangchnet.github.io/Dessert/posts/linux/%E4%B8%BAapt%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2>k8s中的apiVersion</h2></header><section class=entry-content><p>apiVersion可能的字段值： Kind apiVersion CertificateSigningRequest certificates.k8s.io/v1beta1 ClusterRoleBinding rbac.authorization.k8s.io/v1 ClusterRole rbac.authorization.k8s.io/v1 ComponentStatus v1 ConfigMap v1 ControllerRevision apps/v1 CronJob batch/v1beta1 DaemonSet extensions/v1beta1 Deployment extensions/v1beta1 Endpoints v1 Event v1 HorizontalPodAutoscaler autoscaling/v1 Ingress extensions/v1beta1 Job batch/v1 LimitRange v1 Namespace v1 NetworkPolicy extensions/v1beta1 Node v1 PersistentVolumeClaim v1 PersistentVolume v1 PodDisruptionBudget policy/v1beta1 Pod v1 PodSecurityPolicy extensions/v1beta1 PodTemplate v1 ReplicaSet extensions/v1beta1 ReplicationController v1 ResourceQuota v1 RoleBinding rbac....</p></section><footer class=entry-footer><span title="2021-09-02 00:00:00 +0000 UTC">September 2, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to k8s中的apiVersion" href=http://yangchnet.github.io/Dessert/posts/dockerk8s/k8s%E4%B8%AD%E7%9A%84apiversion/></a></article><article class=post-entry><header class=entry-header><h2>安装etcd</h2></header><section class=entry-content><p>安装goreman go get github.com/mattn/goreman 下载etcd 从etcd release 页面下载etcd v3.4.9二进制文件 tar -zxvf etcd-v3.4.9-linux-amd64.tar.gz # 解压 cd etcd-v3.4.9-linux-amd64 sudo mv etcd /usr/local/bin sudo mv etcdctl /usr/local/bin 下载Procfile文件 https://github.com/etcd-io/etcd/blob/v3.4.9/Procfile
# Use goreman to run `go get github.com/mattn/goreman` etcd1: bin/etcd --name infra1 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster 'infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380' --initial-cluster-state new --enable-pprof --logger=zap --log-outputs=stderr etcd2: bin/etcd --name infra2 --listen-client-urls http://127.0.0.1:22379 --advertise-client-urls http://127.0.0.1:22379 --listen-peer-urls http://127.0.0.1:22380 --initial-advertise-peer-urls http://127....</p></section><footer class=entry-footer><span title="2021-09-02 00:00:00 +0000 UTC">September 2, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 安装etcd" href=http://yangchnet.github.io/Dessert/posts/etcd/%E5%AE%89%E8%A3%85etcd/></a></article><article class=post-entry><header class=entry-header><h2>ORM之sqlc</h2></header><section class=entry-content><p>1. 安装sqlc go get github.com/kyleconroy/sqlc/cmd/sqlc 2. 基本使用 建立基本项目结构 mkdir sqlc-demo cd sqlc-demo go mod init sqlc-demo 在sqlc-demo中建立如下目录结构：
. ├── db │ ├── queries │ ├── schema │ └── sqlc └── go.mod 其中query中存储查询语句，schema中存储数据库表结构，sqlc中存储生成的代码。
基本表结构 sqlc-demo/db/schema/table.sql
CREATE TABLE "accounts" ( "id" bigserial PRIMARY KEY, "owner" varchar NOT NULL, "balance" bigint NOT NULL, "currency" varchar NOT NULL, "created_at" timestamptz NOT NULL DEFAULT (now()) ); CREATE TABLE "entries" ( "id" bigserial PRIMARY KEY, "account_id" bigint NOT NULL, "amount" bigint NOT NULL, "created_at" timestamptz NOT NULL DEFAULT (now()) ); CREATE TABLE "transfers" ( "id" bigserial PRIMARY KEY, "from_account_id" bigint NOT NULL, "to_account_id" bigint NOT NULL, "amount" bigint NOT NULL, "created_at" timestamptz NOT NULL DEFAULT (now()) ); 配置文件 sqlc-demo/sqlc....</p></section><footer class=entry-footer><span title="2021-08-22 00:00:00 +0000 UTC">August 22, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to ORM之sqlc" href=http://yangchnet.github.io/Dessert/posts/golang/orm%E4%B9%8Bsqlc/></a></article><article class=post-entry><header class=entry-header><h2>数据库版本管理-migrate</h2></header><section class=entry-content><p>migrate是一个golang写成的数据库版本迁移工具，可以用来方便的对数据库进行迁移和回退。 Github上有详细的教程等：https://github.com/golang-migrate/migrate
建立目录 mkdir -p migrate-demo/db cd migrate-demo/db mkdir ddl mkdir -p schema/blog 现在migrate-demo目录下结构如下：
. └── db ├── ddl └── schema └── blog 其中，ddl中存储建库的sql文件，schema存放建表的sql文件
建库 建库
vim db/ddl/blog.sql CREATE DATABASE IF NOT EXISTS blog DEFAULT CHARACTER SET utf8mb4 DEFAULT COLLATE utf8mb4_unicode_ci; build镜像 编写Dockerfile
vim db/Dockerfile FROMmysql:5.7COPY ./ddl /docker-entrypoint-initdb.d/ENV MYSQL_ROOT_PASSWORD=admin123 复制到/docker-entrypoint-initdb.d目录下的sql脚本会被自动执行
docker build -t mysql-demo -f ./Dockerfile . build成功后，使用docker images命令查看镜像：
REPOSITORY TAG IMAGE ID CREATED SIZE mysql-demo latest 6a2faae69a6f 26 minutes ago 447MB 启动镜像并查看 docker run --name mysql -p 13306:3306 -d mysql-demo 进入容器查看数据库...</p></section><footer class=entry-footer><span title="2021-08-15 00:00:00 +0000 UTC">August 15, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 数据库版本管理-migrate" href=http://yangchnet.github.io/Dessert/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-migrate/></a></article><article class=post-entry><header class=entry-header><h2>WSL2-不输Mac的开发体验（三）：WSL2中使用docker&k8s</h2></header><section class=entry-content><p>1. docker for wsl2 在wsl2中使用docker的最佳实践不是在wsl2中安装docker，而是安装docker desktop：
从docker官网下载并安装完成后，打开docker desktop，选择setting->General，确保Use the WSL 2 based engine选项被勾选，然后选择右下角Apply&Restart。
重启docker desktop后，再次打开设置，确保setting->Resources->WSL INTEGRATION选项页中你的WSL发行版被勾选。
完成以上步骤之后，打开你的wsl, 输入docker： 出现这一堆说明安装成功。
使用docker run helloworld验证你的docker可以正常启动容器。
如果输入docker命令后无法启动，可以尝试sudo docker
2. k8s for wsl2 安装了docker desktop后，可以通过setting->Kubernetes，勾选Enable Kubernetes来为你的wsl提供k8s服务，但由于网络问题，通常不可能成功。
所以我们要"换源"。
打开setting->Docker Engine，将右侧配置文件改为：
{ "registry-mirrors": [ "https://docker.mirrors.ustc.edu.cn", "https://registry.docker-cn.com" ], "insecure-registries": [], "debug": false, "experimental": false, "features": { "buildkit": true } } Apply&Restart，重启docker desktop。
现在我们还需要一些额外的镜像。 clone AliyunContainerService/k8s-for-docker-desktop 这个项目。
git clone https://github.com/AliyunContainerService/k8s-for-docker-desktop.git 查看自己的docker desktop上Kubernetes的版本。
可以看到我们这里是v1.21.2。相应的，我们进入刚才clone的文件夹下，切换到v1.21.2分支
git checkout v1.21.2 切换分支后，在当前目录下执行：...</p></section><footer class=entry-footer><span title="2021-08-12 00:00:00 +0000 UTC">August 12, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to WSL2-不输Mac的开发体验（三）：WSL2中使用docker&k8s" href=http://yangchnet.github.io/Dessert/posts/env/wsl2-%E4%B8%8D%E8%BE%93mac%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C%E4%B8%89wsl2%E4%B8%AD%E4%BD%BF%E7%94%A8dockerk8s/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://yangchnet.github.io/Dessert/posts/page/3/>« Prev Page</a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/page/5/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>