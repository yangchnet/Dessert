<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>拥抱大模型（四）：Chain，像人类一样思考 | Linote</title><meta name=keywords content="langchain"><meta name=description content="什么叫Chain，从字面意思理解，Chain是一个链，我们可以通过Chain来链接LangChain的各个组件和功能-模型之间彼此链接，或模型与其他组件链接。 这种将多个组件相互链接，组合成一个链的想法简单但很强大。它简化了复杂应用程序的实现，并使之更加模块化，能够创建出单一的、连贯的应用程序，从而使调试、维护和改进应用程序变得容易。
我们可以简单的把Chain理解为通过设计好的一些链路去调用大模型，从而获取我们想要的结果。下面是一个例子：
  首先我们让大模型扮演产品经理，给出小说推荐网站的产品设计。   有了产品设计后，由架构师进行初步的架构设计   现在架构设计也有了，来个程序员写SQL： 那，上面的这种promot链，我们用langchain怎么实现呢？   使用langchain实现 Sequential Chain 首先，导入所有需要的库
# 设置OpenAI API密钥 import os os.environ[&#34;OPENAI_API_KEY&#34;] = '你的OpenAI API Key' from langchain.llms import OpenAI from langchain.chains import LLMChain from langchain.prompts import PromptTemplate from langchain.chains import SequentialChain 添加第一个LLMChain，生成小说网站的产品设计。LLMChain可以看作是链条的一个环节
# 这是第一个LLMChain，用于生成鲜花的介绍，输入为花的名称和种类 llm = OpenAI(temperature=.7) template = &#34;&#34;&#34; 你是一个产品经理，请你对{product}给出一个设计想法。&#34;&#34;&#34; prompt_template = PromptTemplate(input_variables=[&#34;product&#34;], template=template) introduction_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=&#34;introduction&#34;) 添加第二个LLMChain，根据产品设计生成软件架构
# 这是第二个LLMChain，用于根据鲜花的介绍写出鲜花的评论 llm = OpenAI(temperature=.7) template = &#34;&#34;&#34; 你是一位软件架构师。给定一个{product}的设计，你需要给出产品软件架构说明和技术栈选型。 产品设计: {introduction} 软件架构说明:&#34;&#34;&#34; prompt_template = PromptTemplate(input_variables=[&#34;product&#34;, &#34;introduction&#34;], template=template) review_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=&#34;framwork&#34;) 第三个Chain，根据产品架构生成SQL语句"><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/posts/llm/%E6%8B%A5%E6%8A%B1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9B%9Bchain%E5%83%8F%E4%BA%BA%E7%B1%BB%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><script defer crossorigin=anonymous src=/Dessert/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="拥抱大模型（四）：Chain，像人类一样思考"><meta property="og:description" content="什么叫Chain，从字面意思理解，Chain是一个链，我们可以通过Chain来链接LangChain的各个组件和功能-模型之间彼此链接，或模型与其他组件链接。 这种将多个组件相互链接，组合成一个链的想法简单但很强大。它简化了复杂应用程序的实现，并使之更加模块化，能够创建出单一的、连贯的应用程序，从而使调试、维护和改进应用程序变得容易。
我们可以简单的把Chain理解为通过设计好的一些链路去调用大模型，从而获取我们想要的结果。下面是一个例子：
  首先我们让大模型扮演产品经理，给出小说推荐网站的产品设计。   有了产品设计后，由架构师进行初步的架构设计   现在架构设计也有了，来个程序员写SQL： 那，上面的这种promot链，我们用langchain怎么实现呢？   使用langchain实现 Sequential Chain 首先，导入所有需要的库
# 设置OpenAI API密钥 import os os.environ[&#34;OPENAI_API_KEY&#34;] = '你的OpenAI API Key' from langchain.llms import OpenAI from langchain.chains import LLMChain from langchain.prompts import PromptTemplate from langchain.chains import SequentialChain 添加第一个LLMChain，生成小说网站的产品设计。LLMChain可以看作是链条的一个环节
# 这是第一个LLMChain，用于生成鲜花的介绍，输入为花的名称和种类 llm = OpenAI(temperature=.7) template = &#34;&#34;&#34; 你是一个产品经理，请你对{product}给出一个设计想法。&#34;&#34;&#34; prompt_template = PromptTemplate(input_variables=[&#34;product&#34;], template=template) introduction_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=&#34;introduction&#34;) 添加第二个LLMChain，根据产品设计生成软件架构
# 这是第二个LLMChain，用于根据鲜花的介绍写出鲜花的评论 llm = OpenAI(temperature=.7) template = &#34;&#34;&#34; 你是一位软件架构师。给定一个{product}的设计，你需要给出产品软件架构说明和技术栈选型。 产品设计: {introduction} 软件架构说明:&#34;&#34;&#34; prompt_template = PromptTemplate(input_variables=[&#34;product&#34;, &#34;introduction&#34;], template=template) review_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=&#34;framwork&#34;) 第三个Chain，根据产品架构生成SQL语句"><meta property="og:type" content="article"><meta property="og:url" content="http://yangchnet.github.io/Dessert/posts/llm/%E6%8B%A5%E6%8A%B1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9B%9Bchain%E5%83%8F%E4%BA%BA%E7%B1%BB%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-04T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-04T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="拥抱大模型（四）：Chain，像人类一样思考"><meta name=twitter:description content="什么叫Chain，从字面意思理解，Chain是一个链，我们可以通过Chain来链接LangChain的各个组件和功能-模型之间彼此链接，或模型与其他组件链接。 这种将多个组件相互链接，组合成一个链的想法简单但很强大。它简化了复杂应用程序的实现，并使之更加模块化，能够创建出单一的、连贯的应用程序，从而使调试、维护和改进应用程序变得容易。
我们可以简单的把Chain理解为通过设计好的一些链路去调用大模型，从而获取我们想要的结果。下面是一个例子：
  首先我们让大模型扮演产品经理，给出小说推荐网站的产品设计。   有了产品设计后，由架构师进行初步的架构设计   现在架构设计也有了，来个程序员写SQL： 那，上面的这种promot链，我们用langchain怎么实现呢？   使用langchain实现 Sequential Chain 首先，导入所有需要的库
# 设置OpenAI API密钥 import os os.environ[&#34;OPENAI_API_KEY&#34;] = '你的OpenAI API Key' from langchain.llms import OpenAI from langchain.chains import LLMChain from langchain.prompts import PromptTemplate from langchain.chains import SequentialChain 添加第一个LLMChain，生成小说网站的产品设计。LLMChain可以看作是链条的一个环节
# 这是第一个LLMChain，用于生成鲜花的介绍，输入为花的名称和种类 llm = OpenAI(temperature=.7) template = &#34;&#34;&#34; 你是一个产品经理，请你对{product}给出一个设计想法。&#34;&#34;&#34; prompt_template = PromptTemplate(input_variables=[&#34;product&#34;], template=template) introduction_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=&#34;introduction&#34;) 添加第二个LLMChain，根据产品设计生成软件架构
# 这是第二个LLMChain，用于根据鲜花的介绍写出鲜花的评论 llm = OpenAI(temperature=.7) template = &#34;&#34;&#34; 你是一位软件架构师。给定一个{product}的设计，你需要给出产品软件架构说明和技术栈选型。 产品设计: {introduction} 软件架构说明:&#34;&#34;&#34; prompt_template = PromptTemplate(input_variables=[&#34;product&#34;, &#34;introduction&#34;], template=template) review_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=&#34;framwork&#34;) 第三个Chain，根据产品架构生成SQL语句"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://yangchnet.github.io/Dessert/posts/"},{"@type":"ListItem","position":3,"name":"拥抱大模型（四）：Chain，像人类一样思考","item":"http://yangchnet.github.io/Dessert/posts/llm/%E6%8B%A5%E6%8A%B1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9B%9Bchain%E5%83%8F%E4%BA%BA%E7%B1%BB%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"拥抱大模型（四）：Chain，像人类一样思考","name":"拥抱大模型（四）：Chain，像人类一样思考","description":"什么叫Chain，从字面意思理解，Chain是一个链，我们可以通过Chain来链接LangChain的各个组件和功能-模型之间彼此链接，或模型与其他组件链接。 这种将多个组件相互链接，组合成一个链的想法简单但很强大。它简化了复杂应用程序的实现，并使之更加模块化，能够创建出单一的、连贯的应用程序，从而使调试、维护和改进应用程序变得容易。\n我们可以简单的把Chain理解为通过设计好的一些链路去调用大模型，从而获取我们想要的结果。下面是一个例子：\n  首先我们让大模型扮演产品经理，给出小说推荐网站的产品设计。   有了产品设计后，由架构师进行初步的架构设计   现在架构设计也有了，来个程序员写SQL： 那，上面的这种promot链，我们用langchain怎么实现呢？   使用langchain实现 Sequential Chain 首先，导入所有需要的库\n# 设置OpenAI API密钥 import os os.environ[\u0026#34;OPENAI_API_KEY\u0026#34;] = \u0026#39;你的OpenAI API Key\u0026#39; from langchain.llms import OpenAI from langchain.chains import LLMChain from langchain.prompts import PromptTemplate from langchain.chains import SequentialChain 添加第一个LLMChain，生成小说网站的产品设计。LLMChain可以看作是链条的一个环节\n# 这是第一个LLMChain，用于生成鲜花的介绍，输入为花的名称和种类 llm = OpenAI(temperature=.7) template = \u0026#34;\u0026#34;\u0026#34; 你是一个产品经理，请你对{product}给出一个设计想法。\u0026#34;\u0026#34;\u0026#34; prompt_template = PromptTemplate(input_variables=[\u0026#34;product\u0026#34;], template=template) introduction_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=\u0026#34;introduction\u0026#34;) 添加第二个LLMChain，根据产品设计生成软件架构\n# 这是第二个LLMChain，用于根据鲜花的介绍写出鲜花的评论 llm = OpenAI(temperature=.7) template = \u0026#34;\u0026#34;\u0026#34; 你是一位软件架构师。给定一个{product}的设计，你需要给出产品软件架构说明和技术栈选型。 产品设计: {introduction} 软件架构说明:\u0026#34;\u0026#34;\u0026#34; prompt_template = PromptTemplate(input_variables=[\u0026#34;product\u0026#34;, \u0026#34;introduction\u0026#34;], template=template) review_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=\u0026#34;framwork\u0026#34;) 第三个Chain，根据产品架构生成SQL语句","keywords":["langchain"],"articleBody":"什么叫Chain，从字面意思理解，Chain是一个链，我们可以通过Chain来链接LangChain的各个组件和功能-模型之间彼此链接，或模型与其他组件链接。 这种将多个组件相互链接，组合成一个链的想法简单但很强大。它简化了复杂应用程序的实现，并使之更加模块化，能够创建出单一的、连贯的应用程序，从而使调试、维护和改进应用程序变得容易。\n我们可以简单的把Chain理解为通过设计好的一些链路去调用大模型，从而获取我们想要的结果。下面是一个例子：\n  首先我们让大模型扮演产品经理，给出小说推荐网站的产品设计。   有了产品设计后，由架构师进行初步的架构设计   现在架构设计也有了，来个程序员写SQL： 那，上面的这种promot链，我们用langchain怎么实现呢？   使用langchain实现 Sequential Chain 首先，导入所有需要的库\n# 设置OpenAI API密钥 import os os.environ[\"OPENAI_API_KEY\"] = '你的OpenAI API Key' from langchain.llms import OpenAI from langchain.chains import LLMChain from langchain.prompts import PromptTemplate from langchain.chains import SequentialChain 添加第一个LLMChain，生成小说网站的产品设计。LLMChain可以看作是链条的一个环节\n# 这是第一个LLMChain，用于生成鲜花的介绍，输入为花的名称和种类 llm = OpenAI(temperature=.7) template = \"\"\" 你是一个产品经理，请你对{product}给出一个设计想法。\"\"\" prompt_template = PromptTemplate(input_variables=[\"product\"], template=template) introduction_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=\"introduction\") 添加第二个LLMChain，根据产品设计生成软件架构\n# 这是第二个LLMChain，用于根据鲜花的介绍写出鲜花的评论 llm = OpenAI(temperature=.7) template = \"\"\" 你是一位软件架构师。给定一个{product}的设计，你需要给出产品软件架构说明和技术栈选型。 产品设计: {introduction} 软件架构说明:\"\"\" prompt_template = PromptTemplate(input_variables=[\"product\", \"introduction\"], template=template) review_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=\"framwork\") 第三个Chain，根据产品架构生成SQL语句\n# 这是第三个LLMChain，用于根据鲜花的介绍和评论写出一篇自媒体的文案 template = \"\"\" 你是一个软件工程师，给定一个{product}的软件架构，请你给出其中主要的数据库表的SQL语句 软件架构: {framwork} SQL语句: \"\"\" prompt_template = PromptTemplate(input_variables=[\"product\", \"framwork\"], template=template) social_post_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=\"sql_text\") 最后，添加SequentialChain，把前面三个链串起来。\noverall_chain = SequentialChain( chains=[introduction_chain, review_chain, social_post_chain], input_variables=[\"product\"], output_variables=[\"introduction\",\"framework\",\"sql_text\"], verbose=True) # 运行链，并打印结果 result = overall_chain({\"product\":\"小说推荐网站\"}) print(result) 输出：\n{ \"product\": \"小说推荐网站\", \"introduction\": \"作为一个产品经理，我会考虑以下设计想法来提高小说推荐网站的用户体验和吸引力：\\n\\n1. 个性化推荐：基于用户的阅读历史、喜好和评分等信息，为用户推荐个性化的小说列表。可以通过机器学习算法和数据分析来实现。\\n\\n2. 社交互动：为用户提供社交功能，让用户可以在网站上与其他读者交流、分享和评论小说。这样可以增加用户的参与度和忠诚度。\\n\\n3. 多维度分类：除了按照类型、作者、出版社等传统分类方式，还可以增加按照情节、主题、人物等多维度分类方式，让用户更容易找到自己喜欢的小说。\\n\\n4. 优质内容推荐：为用户推荐优质的小说内容，可以通过与出版社、作家等合作，或者通过专业编辑团队筛选出优秀的小说。\\n\\n5. 移动端适配：随着移动设备的普及，小说推荐网站需要适配移动端，提供更好的用户体验和便捷的阅读方式。\\n\\n6. 付费服务：为用户提供付费服务，例如VIP会员、广告免费等，以增加网站的收入和用户忠诚度。\\n\\n以上是我对小说推荐网站的设计想法，希望能够对您有所帮助。\", \"framework\": \"基于以上产品设计，我建议采用微服务架构，将不同的功能模块拆分成独立的服务，以提高系统的可扩展性和可维护性。具体架构如下：\\n\\n1. 用户服务：负责用户注册、登录、个人信息管理等功能。\\n\\n2. 推荐服务：基于用户的阅读历史、喜好和评分等信息，为用户推荐个性化的小说列表。\\n\\n3. 社交服务：负责用户之间的交流、分享和评论等社交功能。\\n\\n4. 分类服务：负责小说的多维度分类和搜索功能。\\n\\n5. 内容服务：负责小说的内容管理和优质内容推荐。\\n\\n6. 支付服务：负责用户付费服务的管理和支付功能。\\n\\n7. 移动端服务：负责移动端的适配和提供更好的用户体验和便捷的阅读方式。\\n\\n技术栈选型：\\n\\n1. 后端框架：Spring Boot、Spring Cloud\\n\\n2. 数据库：MySQL、Redis\\n\\n3. 消息队列：Kafka\\n\\n4. 搜索引擎：Elasticsearch\\n\\n5. 缓存：Redis\\n\\n6. 前端框架：React、Ant Design\\n\\n7. 移动端框架：React Native\\n\\n8. 机器学习算法：TensorFlow、Scikit-learn\\n\\n9. 云服务：AWS、阿里云\\n\\n以上是我对小说推荐网站的软件架构说明和技术栈选型建议，希望能够对您有所帮助。\", \"sql_text\": \"以下是主要的数据库表的SQL语句：\\n\\n1. 用户服务：\\n\\nCREATE TABLE users (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n username VARCHAR(50) NOT NULL,\\n password VARCHAR(50) NOT NULL,\\n email VARCHAR(50) NOT NULL,\\n phone VARCHAR(20),\\n avatar VARCHAR(100),\\n created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\\n);\\n\\n2. 推荐服务：\\n\\nCREATE TABLE user_read_history (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n user_id INT NOT NULL,\\n book_id INT NOT NULL,\\n read_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n FOREIGN KEY (user_id) REFERENCES users(id),\\n FOREIGN KEY (book_id) REFERENCES books(id)\\n);\\n\\nCREATE TABLE user_rating (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n user_id INT NOT NULL,\\n book_id INT NOT NULL,\\n rating INT NOT NULL,\\n FOREIGN KEY (user_id) REFERENCES users(id),\\n FOREIGN KEY (book_id) REFERENCES books(id)\\n);\\n\\n3. 社交服务：\\n\\nCREATE TABLE comments (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n user_id INT NOT NULL,\\n book_id INT NOT NULL,\\n content TEXT NOT NULL,\\n created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n FOREIGN KEY (user_id) REFERENCES users(id),\\n FOREIGN KEY (book_id) REFERENCES books(id)\\n);\\n\\n4. 分类服务：\\n\\nCREATE TABLE categories (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n name VARCHAR(50) NOT NULL,\\n parent_id INT,\\n created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n FOREIGN KEY (parent_id) REFERENCES categories(id)\\n);\\n\\nCREATE TABLE book_category (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n book_id INT NOT NULL,\\n category_id INT NOT NULL,\\n FOREIGN KEY (book_id) REFERENCES books(id),\\n FOREIGN KEY (category_id) REFERENCES categories(id)\\n);\\n\\n5. 内容服务：\\n\\nCREATE TABLE books (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n title VARCHAR(100) NOT NULL,\\n author VARCHAR(50) NOT NULL,\\n description TEXT NOT NULL,\\n cover VARCHAR(100),\\n created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\\n);\\n\\n6. 支付服务：\\n\\nCREATE TABLE orders (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n user_id INT NOT NULL,\\n book_id INT NOT NULL,\\n amount DECIMAL(10,2) NOT NULL,\\n status INT NOT NULL,\\n created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n FOREIGN KEY (user_id) REFERENCES users(id),\\n FOREIGN KEY (book_id) REFERENCES books(id)\\n);\\n\\n7. 移动端服务：\\n\\nCREATE TABLE devices (\\n id INT PRIMARY KEY AUTO_INCREMENT,\\n user_id INT NOT NULL,\\n device_token VARCHAR(100) NOT NULL,\\n device_type INT NOT NULL,\\n created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\\n updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n FOREIGN KEY (user_id) REFERENCES users(id)\\n);\" } langchain还提供了许多其他类型的链：https://python.langchain.com/docs/modules/chains\nRouter Chain Sequential Chain只是根据设计好的思维链路进行思考，但有时我们会面临抉择，在收到不同的任务时让不同的角色去完成。例如，现在我们有两个角色：软件架构师，软件工程师，我们需要根据问题的内容决定让谁去回答问题。首先构建两个提示信息的模板：\n# 构建两个场景的模板 frame_template = \"\"\"你是一个经验丰富的软件架构师，擅长解答关于软件架构，技术选型的问题。 下面是需要你来回答的问题: {input}\"\"\" engineer_template = \"\"\"你是一位软件工程师，擅长解决技术细节，代码编写的问题。 下面是需要你来回答的问题: {input}\"\"\" # 构建提示信息 prompt_infos = [ { \"key\": \"framework\", \"description\": \"擅长解答关于软件架构，技术选型的问题\", \"template\": frame_template, }, { \"key\": \"engineer\", \"description\": \"擅长解决技术细节，代码编写的问题\", \"template\": engineer_template, }] 初始化语言模型\n# 初始化语言模型 from langchain.llms import OpenAI import os os.environ[\"OPENAI_API_KEY\"] = '你的OpenAI Key' llm = OpenAI() 构建目标链\n# 构建目标链 from langchain.chains.llm import LLMChain from langchain.prompts import PromptTemplate chain_map = {} for info in prompt_infos: prompt = PromptTemplate(template=info['template'], input_variables=[\"input\"]) print(\"目标提示:\\n\",prompt) chain = LLMChain(llm=llm, prompt=prompt,verbose=True) chain_map[info[\"key\"]] = chain 目标链长这个样子：\n目标提示: input_variables=['input'] output_parser=None partial_variables={} template='你是一个经验丰富的软件架构师，擅长解答关于软件架构，技术选型的问题。\\n 下面是需要你来回答的问题:\\n {input}' template_format='f-string' validate_template=True 目标提示: input_variables=['input'] output_parser=None partial_variables={} template='你是一位软件工程师，擅长解决技术细节，代码编写的问题。\\n 下面是需要你来回答的问题:\\n {input}' template_format='f-string' validate_template=True 构建路由链：\n# 构建路由链 from langchain.chains.router.llm_router import LLMRouterChain, RouterOutputParser from langchain.chains.router.multi_prompt_prompt import MULTI_PROMPT_ROUTER_TEMPLATE as RounterTemplate destinations = [f\"{p['key']}: {p['description']}\" for p in prompt_infos] router_template = RounterTemplate.format(destinations=\"\\n\".join(destinations)) print(\"路由模板:\\n\",router_template) router_prompt = PromptTemplate( template=router_template, input_variables=[\"input\"], output_parser=RouterOutputParser(),) print(\"路由提示:\\n\",router_prompt) router_chain = LLMRouterChain.from_llm(llm, router_prompt, verbose=True) 路由模板的样子：\n路由模板: Given a raw text input to a language model select the model prompt best suited for the input. You will be given the names of the available prompts and a description of what the prompt is best suited for. You may also revise the original input if you think that revising it will ultimately lead to a better response from the language model.  Return a markdown code snippet with a JSON object formatted to look like: ```json {{ \"destination\": string \\ name of the prompt to use or \"DEFAULT\" \"next_inputs\": string \\ a potentially modified version of the original input }} REMEMBER: “destination” MUST be one of the candidate prompt names specified below OR it can be “DEFAULT” if the input is not well suited for any of the candidate prompts. REMEMBER: “next_inputs” can just be the original input if you don’t think any modifications are needed.\n« CANDIDATE PROMPTS » framework: 擅长解答关于软件架构，技术选型的问题 engineer: 擅长解决技术细节，代码编写的问题\n« INPUT » {input}\n« OUTPUT »\n路由提示: input_variables=[‘input’] output_parser=RouterOutputParser(default_destination=‘DEFAULT’, next_inputs_type=, next_inputs_inner_key=‘input’) partial_variables={} template=‘Given a raw text input to a language model select the model prompt best suited for the input. You will be given the names of the available prompts and a description of what the prompt is best suited for. You may also revise the original input if you think that revising it will ultimately lead to a better response from the language model.\\n\\n« FORMATTING »\\nReturn a markdown code snippet with a JSON object formatted to look like:\\njson\\n{{\\n \"destination\": string \\\\ name of the prompt to use or \"DEFAULT\"\\n \"next_inputs\": string \\\\ a potentially modified version of the original input\\n}}\\n\\n\\nREMEMBER: “destination” MUST be one of the candidate prompt names specified below OR it can be “DEFAULT” if the input is not well suited for any of the candidate prompts.\\nREMEMBER: “next_inputs” can just be the original input if you don't think any modifications are needed.\\n\\n« CANDIDATE PROMPTS »\\nframework: 擅长解答关于软件架构，技术选型的问题\\nengineer: 擅长解决技术细节，代码编写的问题\\n\\n« INPUT »\\n{input}\\n\\n« OUTPUT »\\n’ template_format=‘f-string’ validate_template=True\n构建默认链，除了处理目标链和路由链之外，我们还需要准备一个默认链。如果路由链没有找到适合的链，那么，就以默认链进行处理。 ```python # 构建默认链 from langchain.chains import ConversationChain default_chain = ConversationChain(llm=llm, output_key=\"text\", verbose=True) 最后，我们使用 MultiPromptChain 类把前几个链整合在一起，实现路由功能。这个 MultiPromptChain 类是一个多路选择链，它使用一个 LLM 路由器链在多个提示之间进行选择。MultiPromptChain 中有三个关键元素。\n router_chain（类型 RouterChain）：这是用于决定目标链和其输入的链。当给定某个输入时，这个 router_chain 决定哪一个 destination_chain 应该被选中，以及传给它的具体输入是什么。 destination_chains（类型 Mapping[str, LLMChain]）：这是一个映射，将名称映射到可以将输入路由到的候选链。例如，你可能有多种处理文本输入的方法（或“链”），每种方法针对特定类型的问题。destination_chains 可以是这样一个字典：{‘weather’: weather_chain, ‘news’: news_chain}。在这里，weather_chain 可能专门处理与天气相关的问题，而 news_chain 处理与新闻相关的问题。 default_chain（类型 LLMChain）：当 router_chain 无法将输入映射到 destination_chains 中的任何一个链时，LLMChain 将使用此默认链。这是一个备选方案，确保即使路由器不能决定正确的链，也总有一个链可以处理输入。  它的工作流程如下：\n 输入首先传递给 router_chain。 router_chain 根据某些标准或逻辑决定应该使用哪一个 destination_chain。 输入随后被路由到选定的 destination_chain，该链进行处理并返回结果。如果 router_chain 不能决定正确的 destination_chain，则输入会被传递给 default_chain。 这样，MultiPromptChain 就为我们提供了一个在多个处理链之间动态路由输入的机制，以得到最相关或最优的输出。  # 构建多提示链 from langchain.chains.router import MultiPromptChain chain = MultiPromptChain( router_chain=router_chain, destination_chains=chain_map, default_chain=default_chain, verbose=True) 开始运行吧：\nprint(chain.run(\"博客网站应该如何设计\")) 输出如下：\n Entering new chain...  Entering new chain...  Finished chain. framework: {'input': '博客网站应该如何设计'}  Entering new chain... Prompt after formatting: 你是一个经验丰富的软件架构师，擅长解答关于软件架构，技术选型的问题。 下面是需要你来回答的问题: 博客网站应该如何设计  Finished chain.  Finished chain. 博客网站的设计应该考虑以下几个方面： 1. 用户体验：博客网站应该易于使用，用户可以轻松地找到他们感兴趣的内容。网站应该具有良好的导航和搜索功能，以便用户可以快速找到他们需要的信息。 2. 响应式设计：博客网站应该能够适应不同的设备和屏幕大小，包括桌面电脑、平板电脑和手机等。这样可以确保用户在任何设备上都能够方便地访问网站。 。。。。（略） ","wordCount":"1045","inLanguage":"en","datePublished":"2024-02-04T00:00:00Z","dateModified":"2024-02-04T00:00:00Z","author":{"@type":"Person","name":"李昌"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://yangchnet.github.io/Dessert/posts/llm/%E6%8B%A5%E6%8A%B1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9B%9Bchain%E5%83%8F%E4%BA%BA%E7%B1%BB%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/"},"publisher":{"@type":"Organization","name":"Linote","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/posts/>Posts</a></div><h1 class=post-title>拥抱大模型（四）：Chain，像人类一样思考</h1><div class=post-meta><span title="2024-02-04 00:00:00 +0000 UTC">February 4, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;李昌</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bd%bf%e7%94%a8langchain%e5%ae%9e%e7%8e%b0 aria-label=使用langchain实现>使用langchain实现</a><ul><li><a href=#sequential-chain aria-label="Sequential Chain">Sequential Chain</a></li><li><a href=#router-chain aria-label="Router Chain">Router Chain</a></li></ul></li></ul></div></details></div><div class=post-content><p>什么叫Chain，从字面意思理解，Chain是一个链，我们可以通过Chain来链接LangChain的各个组件和功能-模型之间彼此链接，或模型与其他组件链接。
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20241220155943.png alt=20241220155943>
这种将多个组件相互链接，组合成一个链的想法简单但很强大。它简化了复杂应用程序的实现，并使之更加模块化，能够创建出单一的、连贯的应用程序，从而使调试、维护和改进应用程序变得容易。</p><p>我们可以简单的把Chain理解为通过设计好的一些链路去调用大模型，从而获取我们想要的结果。下面是一个例子：</p><ol><li><p>首先我们让大模型扮演产品经理，给出小说推荐网站的产品设计。
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20241220160003.png alt=20241220160003></p></li><li><p>有了产品设计后，由架构师进行初步的架构设计
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20241220160018.png alt=20241220160018>
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20241220160031.png alt=20241220160031></p></li><li><p>现在架构设计也有了，来个程序员写SQL：
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20241220160045.png alt=20241220160045>
<img loading=lazy src=https://raw.githubusercontent.com/lich-Img/blogImg/master/img/20241220160058.png alt=20241220160058>
那，上面的这种promot链，我们用langchain怎么实现呢？</p></li></ol><h1 id=使用langchain实现>使用langchain实现<a hidden class=anchor aria-hidden=true href=#使用langchain实现>#</a></h1><p></p><h2 id=sequential-chain>Sequential Chain<a hidden class=anchor aria-hidden=true href=#sequential-chain>#</a></h2><p>首先，导入所有需要的库</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 设置OpenAI API密钥</span>
<span style=color:#f92672>import</span> os
os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;OPENAI_API_KEY&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;你的OpenAI API Key&#39;</span>

<span style=color:#f92672>from</span> langchain.llms <span style=color:#f92672>import</span> OpenAI
<span style=color:#f92672>from</span> langchain.chains <span style=color:#f92672>import</span> LLMChain
<span style=color:#f92672>from</span> langchain.prompts <span style=color:#f92672>import</span> PromptTemplate
<span style=color:#f92672>from</span> langchain.chains <span style=color:#f92672>import</span> SequentialChain
</code></pre></div><p>添加第一个LLMChain，生成小说网站的产品设计。LLMChain可以看作是链条的一个环节</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 这是第一个LLMChain，用于生成鲜花的介绍，输入为花的名称和种类</span>
llm <span style=color:#f92672>=</span> OpenAI(temperature<span style=color:#f92672>=.</span><span style=color:#ae81ff>7</span>)
template <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>你是一个产品经理，请你对{product}给出一个设计想法。&#34;&#34;&#34;</span>
prompt_template <span style=color:#f92672>=</span> PromptTemplate(input_variables<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;product&#34;</span>], template<span style=color:#f92672>=</span>template)
introduction_chain <span style=color:#f92672>=</span> LLMChain(llm<span style=color:#f92672>=</span>llm, prompt<span style=color:#f92672>=</span>prompt_template, output_key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;introduction&#34;</span>)
</code></pre></div><p>添加第二个LLMChain，根据产品设计生成软件架构</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 这是第二个LLMChain，用于根据鲜花的介绍写出鲜花的评论</span>
llm <span style=color:#f92672>=</span> OpenAI(temperature<span style=color:#f92672>=.</span><span style=color:#ae81ff>7</span>)
template <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>你是一位软件架构师。给定一个{product}的设计，你需要给出产品软件架构说明和技术栈选型。
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>产品设计:
</span><span style=color:#e6db74>{introduction}
</span><span style=color:#e6db74>软件架构说明:&#34;&#34;&#34;</span>
prompt_template <span style=color:#f92672>=</span> PromptTemplate(input_variables<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;product&#34;</span>, <span style=color:#e6db74>&#34;introduction&#34;</span>], template<span style=color:#f92672>=</span>template)
review_chain <span style=color:#f92672>=</span> LLMChain(llm<span style=color:#f92672>=</span>llm, prompt<span style=color:#f92672>=</span>prompt_template, output_key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;framwork&#34;</span>)
</code></pre></div><p>第三个Chain，根据产品架构生成SQL语句</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 这是第三个LLMChain，用于根据鲜花的介绍和评论写出一篇自媒体的文案</span>
template <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;
</span><span style=color:#e6db74>你是一个软件工程师，给定一个{product}的软件架构，请你给出其中主要的数据库表的SQL语句
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>软件架构:
</span><span style=color:#e6db74>{framwork}
</span><span style=color:#e6db74>
</span><span style=color:#e6db74>SQL语句:
</span><span style=color:#e6db74>&#34;&#34;&#34;</span>
prompt_template <span style=color:#f92672>=</span> PromptTemplate(input_variables<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;product&#34;</span>, <span style=color:#e6db74>&#34;framwork&#34;</span>], template<span style=color:#f92672>=</span>template)
social_post_chain <span style=color:#f92672>=</span> LLMChain(llm<span style=color:#f92672>=</span>llm, prompt<span style=color:#f92672>=</span>prompt_template, output_key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;sql_text&#34;</span>)
</code></pre></div><p>最后，添加SequentialChain，把前面三个链串起来。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>overall_chain <span style=color:#f92672>=</span> SequentialChain(
    chains<span style=color:#f92672>=</span>[introduction_chain, review_chain, social_post_chain],
    input_variables<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;product&#34;</span>],
    output_variables<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;introduction&#34;</span>,<span style=color:#e6db74>&#34;framework&#34;</span>,<span style=color:#e6db74>&#34;sql_text&#34;</span>],
    verbose<span style=color:#f92672>=</span>True)

<span style=color:#75715e># 运行链，并打印结果</span>
result <span style=color:#f92672>=</span> overall_chain({<span style=color:#e6db74>&#34;product&#34;</span>:<span style=color:#e6db74>&#34;小说推荐网站&#34;</span>})
<span style=color:#66d9ef>print</span>(result)
</code></pre></div><p>输出：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:#f92672>&#34;product&#34;</span>: <span style=color:#e6db74>&#34;小说推荐网站&#34;</span>,
    <span style=color:#f92672>&#34;introduction&#34;</span>: <span style=color:#e6db74>&#34;作为一个产品经理，我会考虑以下设计想法来提高小说推荐网站的用户体验和吸引力：\n\n1. 个性化推荐：基于用户的阅读历史、喜好和评分等信息，为用户推荐个性化的小说列表。可以通过机器学习算法和数据分析来实现。\n\n2. 社交互动：为用户提供社交功能，让用户可以在网站上与其他读者交流、分享和评论小说。这样可以增加用户的参与度和忠诚度。\n\n3. 多维度分类：除了按照类型、作者、出版社等传统分类方式，还可以增加按照情节、主题、人物等多维度分类方式，让用户更容易找到自己喜欢的小说。\n\n4. 优质内容推荐：为用户推荐优质的小说内容，可以通过与出版社、作家等合作，或者通过专业编辑团队筛选出优秀的小说。\n\n5. 移动端适配：随着移动设备的普及，小说推荐网站需要适配移动端，提供更好的用户体验和便捷的阅读方式。\n\n6. 付费服务：为用户提供付费服务，例如VIP会员、广告免费等，以增加网站的收入和用户忠诚度。\n\n以上是我对小说推荐网站的设计想法，希望能够对您有所帮助。&#34;</span>,
    <span style=color:#f92672>&#34;framework&#34;</span>: <span style=color:#e6db74>&#34;基于以上产品设计，我建议采用微服务架构，将不同的功能模块拆分成独立的服务，以提高系统的可扩展性和可维护性。具体架构如下：\n\n1. 用户服务：负责用户注册、登录、个人信息管理等功能。\n\n2. 推荐服务：基于用户的阅读历史、喜好和评分等信息，为用户推荐个性化的小说列表。\n\n3. 社交服务：负责用户之间的交流、分享和评论等社交功能。\n\n4. 分类服务：负责小说的多维度分类和搜索功能。\n\n5. 内容服务：负责小说的内容管理和优质内容推荐。\n\n6. 支付服务：负责用户付费服务的管理和支付功能。\n\n7. 移动端服务：负责移动端的适配和提供更好的用户体验和便捷的阅读方式。\n\n技术栈选型：\n\n1. 后端框架：Spring Boot、Spring Cloud\n\n2. 数据库：MySQL、Redis\n\n3. 消息队列：Kafka\n\n4. 搜索引擎：Elasticsearch\n\n5. 缓存：Redis\n\n6. 前端框架：React、Ant Design\n\n7. 移动端框架：React Native\n\n8. 机器学习算法：TensorFlow、Scikit-learn\n\n9. 云服务：AWS、阿里云\n\n以上是我对小说推荐网站的软件架构说明和技术栈选型建议，希望能够对您有所帮助。&#34;</span>,
    <span style=color:#f92672>&#34;sql_text&#34;</span>: <span style=color:#e6db74>&#34;以下是主要的数据库表的SQL语句：\n\n1. 用户服务：\n\nCREATE TABLE users (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  username VARCHAR(50) NOT NULL,\n  password VARCHAR(50) NOT NULL,\n  email VARCHAR(50) NOT NULL,\n  phone VARCHAR(20),\n  avatar VARCHAR(100),\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n);\n\n2. 推荐服务：\n\nCREATE TABLE user_read_history (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  book_id INT NOT NULL,\n  read_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  FOREIGN KEY (user_id) REFERENCES users(id),\n  FOREIGN KEY (book_id) REFERENCES books(id)\n);\n\nCREATE TABLE user_rating (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  book_id INT NOT NULL,\n  rating INT NOT NULL,\n  FOREIGN KEY (user_id) REFERENCES users(id),\n  FOREIGN KEY (book_id) REFERENCES books(id)\n);\n\n3. 社交服务：\n\nCREATE TABLE comments (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  book_id INT NOT NULL,\n  content TEXT NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  FOREIGN KEY (user_id) REFERENCES users(id),\n  FOREIGN KEY (book_id) REFERENCES books(id)\n);\n\n4. 分类服务：\n\nCREATE TABLE categories (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(50) NOT NULL,\n  parent_id INT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  FOREIGN KEY (parent_id) REFERENCES categories(id)\n);\n\nCREATE TABLE book_category (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  book_id INT NOT NULL,\n  category_id INT NOT NULL,\n  FOREIGN KEY (book_id) REFERENCES books(id),\n  FOREIGN KEY (category_id) REFERENCES categories(id)\n);\n\n5. 内容服务：\n\nCREATE TABLE books (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  title VARCHAR(100) NOT NULL,\n  author VARCHAR(50) NOT NULL,\n  description TEXT NOT NULL,\n  cover VARCHAR(100),\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n);\n\n6. 支付服务：\n\nCREATE TABLE orders (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  book_id INT NOT NULL,\n  amount DECIMAL(10,2) NOT NULL,\n  status INT NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  FOREIGN KEY (user_id) REFERENCES users(id),\n  FOREIGN KEY (book_id) REFERENCES books(id)\n);\n\n7. 移动端服务：\n\nCREATE TABLE devices (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  device_token VARCHAR(100) NOT NULL,\n  device_type INT NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  FOREIGN KEY (user_id) REFERENCES users(id)\n);&#34;</span>
}
</code></pre></div><p>langchain还提供了许多其他类型的链：<a href=https://python.langchain.com/docs/modules/chains>https://python.langchain.com/docs/modules/chains</a></p><p></p><h2 id=router-chain>Router Chain<a hidden class=anchor aria-hidden=true href=#router-chain>#</a></h2><p>Sequential Chain只是根据设计好的思维链路进行思考，但有时我们会面临抉择，在收到不同的任务时让不同的角色去完成。例如，现在我们有两个角色：软件架构师，软件工程师，我们需要根据问题的内容决定让谁去回答问题。首先构建两个提示信息的模板：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>构建两个场景的模板</span>
<span style=color:#960050;background-color:#1e0010>frame_template</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#e6db74>&#34;&#34;&#34;你是一个经验丰富的软件架构师，擅长解答关于软件架构，技术选型的问题。
</span><span style=color:#e6db74>                        下面是需要你来回答的问题:
</span><span style=color:#e6db74>                        {input}&#34;&#34;&#34;</span>

<span style=color:#960050;background-color:#1e0010>engineer_template</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#e6db74>&#34;&#34;&#34;你是一位软件工程师，擅长解决技术细节，代码编写的问题。
</span><span style=color:#e6db74>                        下面是需要你来回答的问题:
</span><span style=color:#e6db74>                        {input}&#34;&#34;&#34;</span>

<span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>构建提示信息</span>
<span style=color:#960050;background-color:#1e0010>prompt_infos</span> <span style=color:#960050;background-color:#1e0010>=</span> [
    {
        <span style=color:#f92672>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;framework&#34;</span>,
        <span style=color:#f92672>&#34;description&#34;</span>: <span style=color:#e6db74>&#34;擅长解答关于软件架构，技术选型的问题&#34;</span>,
        <span style=color:#f92672>&#34;template&#34;</span>: <span style=color:#960050;background-color:#1e0010>frame_template</span>,
    },
    {
        <span style=color:#f92672>&#34;key&#34;</span>: <span style=color:#e6db74>&#34;engineer&#34;</span>,
        <span style=color:#f92672>&#34;description&#34;</span>: <span style=color:#e6db74>&#34;擅长解决技术细节，代码编写的问题&#34;</span>,
        <span style=color:#f92672>&#34;template&#34;</span>: <span style=color:#960050;background-color:#1e0010>engineer_template</span>,
    }]
</code></pre></div><p>初始化语言模型</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#960050;background-color:#1e0010>初始化语言模型</span>
<span style=color:#960050;background-color:#1e0010>from</span> <span style=color:#960050;background-color:#1e0010>langchain.llms</span> <span style=color:#960050;background-color:#1e0010>import</span> <span style=color:#960050;background-color:#1e0010>OpenAI</span>
<span style=color:#960050;background-color:#1e0010>import</span> <span style=color:#960050;background-color:#1e0010>os</span>
<span style=color:#960050;background-color:#1e0010>os.environ</span>[<span style=color:#e6db74>&#34;OPENAI_API_KEY&#34;</span>] <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#960050;background-color:#1e0010>&#39;你的OpenAI</span> <span style=color:#960050;background-color:#1e0010>Key&#39;</span>
<span style=color:#960050;background-color:#1e0010>llm</span> <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#960050;background-color:#1e0010>OpenAI()</span>
</code></pre></div><p>构建目标链</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 构建目标链</span>
<span style=color:#f92672>from</span> langchain.chains.llm <span style=color:#f92672>import</span> LLMChain
<span style=color:#f92672>from</span> langchain.prompts <span style=color:#f92672>import</span> PromptTemplate
chain_map <span style=color:#f92672>=</span> {}
<span style=color:#66d9ef>for</span> info <span style=color:#f92672>in</span> prompt_infos:
    prompt <span style=color:#f92672>=</span> PromptTemplate(template<span style=color:#f92672>=</span>info[<span style=color:#e6db74>&#39;template&#39;</span>], 
                            input_variables<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;input&#34;</span>])
    <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;目标提示:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,prompt)
    chain <span style=color:#f92672>=</span> LLMChain(llm<span style=color:#f92672>=</span>llm, prompt<span style=color:#f92672>=</span>prompt,verbose<span style=color:#f92672>=</span>True)
    chain_map[info[<span style=color:#e6db74>&#34;key&#34;</span>]] <span style=color:#f92672>=</span> chain
</code></pre></div><p>目标链长这个样子：</p><pre><code>目标提示:
 input_variables=['input'] output_parser=None partial_variables={} template='你是一个经验丰富的软件架构师，擅长解答关于软件架构，技术选型的问题。\n                        下面是需要你来回答的问题:\n                        {input}' template_format='f-string' validate_template=True
目标提示:
 input_variables=['input'] output_parser=None partial_variables={} template='你是一位软件工程师，擅长解决技术细节，代码编写的问题。\n                        下面是需要你来回答的问题:\n                        {input}' template_format='f-string' validate_template=True
</code></pre><p>构建路由链：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 构建路由链</span>
<span style=color:#f92672>from</span> langchain.chains.router.llm_router <span style=color:#f92672>import</span> LLMRouterChain, RouterOutputParser
<span style=color:#f92672>from</span> langchain.chains.router.multi_prompt_prompt <span style=color:#f92672>import</span> MULTI_PROMPT_ROUTER_TEMPLATE <span style=color:#66d9ef>as</span> RounterTemplate
destinations <span style=color:#f92672>=</span> [f<span style=color:#e6db74>&#34;{p[&#39;key&#39;]}: {p[&#39;description&#39;]}&#34;</span> <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> prompt_infos]
router_template <span style=color:#f92672>=</span> RounterTemplate<span style=color:#f92672>.</span>format(destinations<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>join(destinations))
<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;路由模板:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,router_template)
router_prompt <span style=color:#f92672>=</span> PromptTemplate(
    template<span style=color:#f92672>=</span>router_template,
    input_variables<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;input&#34;</span>],
    output_parser<span style=color:#f92672>=</span>RouterOutputParser(),)
<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;路由提示:</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,router_prompt)
router_chain <span style=color:#f92672>=</span> LLMRouterChain<span style=color:#f92672>.</span>from_llm(llm, 
                                       router_prompt,
                                       verbose<span style=color:#f92672>=</span>True)
</code></pre></div><p>路由模板的样子：</p><pre><code>路由模板:
 Given a raw text input to a language model select the model prompt best suited for the input. You will be given the names of the available prompts and a description of what the prompt is best suited for. You may also revise the original input if you think that revising it will ultimately lead to a better response from the language model.

&lt;&lt; FORMATTING &gt;&gt;
Return a markdown code snippet with a JSON object formatted to look like:
```json
{{
    &quot;destination&quot;: string \ name of the prompt to use or &quot;DEFAULT&quot;
    &quot;next_inputs&quot;: string \ a potentially modified version of the original input
}}
</code></pre><p>REMEMBER: &ldquo;destination&rdquo; MUST be one of the candidate prompt names specified below OR it can be &ldquo;DEFAULT&rdquo; if the input is not well suited for any of the candidate prompts.
REMEMBER: &ldquo;next_inputs&rdquo; can just be the original input if you don&rsquo;t think any modifications are needed.</p><p>&#171; CANDIDATE PROMPTS &#187;
framework: 擅长解答关于软件架构，技术选型的问题
engineer: 擅长解决技术细节，代码编写的问题</p><p>&#171; INPUT &#187;
{input}</p><p>&#171; OUTPUT &#187;</p><p>路由提示:
input_variables=[&lsquo;input&rsquo;] output_parser=RouterOutputParser(default_destination=&lsquo;DEFAULT&rsquo;, next_inputs_type=&lt;class &lsquo;str&rsquo;>, next_inputs_inner_key=&lsquo;input&rsquo;) partial_variables={} template=&lsquo;Given a raw text input to a language model select the model prompt best suited for the input. You will be given the names of the available prompts and a description of what the prompt is best suited for. You may also revise the original input if you think that revising it will ultimately lead to a better response from the language model.\n\n&#171; FORMATTING &#187;\nReturn a markdown code snippet with a JSON object formatted to look like:\n<code>json\n{{\n "destination": string \\ name of the prompt to use or "DEFAULT"\n "next_inputs": string \\ a potentially modified version of the original input\n}}\n</code>\n\nREMEMBER: &ldquo;destination&rdquo; MUST be one of the candidate prompt names specified below OR it can be &ldquo;DEFAULT&rdquo; if the input is not well suited for any of the candidate prompts.\nREMEMBER: &ldquo;next_inputs&rdquo; can just be the original input if you don't think any modifications are needed.\n\n&#171; CANDIDATE PROMPTS &#187;\nframework: 擅长解答关于软件架构，技术选型的问题\nengineer: 擅长解决技术细节，代码编写的问题\n\n&#171; INPUT &#187;\n{input}\n\n&#171; OUTPUT &#187;\n&rsquo; template_format=&lsquo;f-string&rsquo; validate_template=True</p><pre><code>构建默认链，除了处理目标链和路由链之外，我们还需要准备一个默认链。如果路由链没有找到适合的链，那么，就以默认链进行处理。
```python
# 构建默认链
from langchain.chains import ConversationChain
default_chain = ConversationChain(llm=llm, 
                                  output_key=&quot;text&quot;,
                                  verbose=True)
</code></pre><p>最后，我们使用 MultiPromptChain 类把前几个链整合在一起，实现路由功能。这个 MultiPromptChain 类是一个多路选择链，它使用一个 LLM 路由器链在多个提示之间进行选择。MultiPromptChain 中有三个关键元素。</p><ul><li>router_chain（类型 RouterChain）：这是用于决定目标链和其输入的链。当给定某个输入时，这个 router_chain 决定哪一个 destination_chain 应该被选中，以及传给它的具体输入是什么。</li><li>destination_chains（类型 Mapping[str, LLMChain]）：这是一个映射，将名称映射到可以将输入路由到的候选链。例如，你可能有多种处理文本输入的方法（或“链”），每种方法针对特定类型的问题。destination_chains 可以是这样一个字典：{&lsquo;weather&rsquo;: weather_chain, &lsquo;news&rsquo;: news_chain}。在这里，weather_chain 可能专门处理与天气相关的问题，而 news_chain 处理与新闻相关的问题。</li><li>default_chain（类型 LLMChain）：当 router_chain 无法将输入映射到 destination_chains 中的任何一个链时，LLMChain 将使用此默认链。这是一个备选方案，确保即使路由器不能决定正确的链，也总有一个链可以处理输入。</li></ul><p>它的工作流程如下：</p><ul><li>输入首先传递给 router_chain。</li><li>router_chain 根据某些标准或逻辑决定应该使用哪一个 destination_chain。</li><li>输入随后被路由到选定的 destination_chain，该链进行处理并返回结果。如果 router_chain 不能决定正确的 destination_chain，则输入会被传递给 default_chain。</li><li>这样，MultiPromptChain 就为我们提供了一个在多个处理链之间动态路由输入的机制，以得到最相关或最优的输出。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># 构建多提示链</span>
<span style=color:#f92672>from</span> langchain.chains.router <span style=color:#f92672>import</span> MultiPromptChain
chain <span style=color:#f92672>=</span> MultiPromptChain(
    router_chain<span style=color:#f92672>=</span>router_chain,
    destination_chains<span style=color:#f92672>=</span>chain_map,
    default_chain<span style=color:#f92672>=</span>default_chain,
    verbose<span style=color:#f92672>=</span>True)
</code></pre></div><p>开始运行吧：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(chain<span style=color:#f92672>.</span>run(<span style=color:#e6db74>&#34;博客网站应该如何设计&#34;</span>))
</code></pre></div><p>输出如下：</p><pre><code>&gt; Entering new  chain...

&gt; Entering new  chain...

&gt; Finished chain.
framework: {'input': '博客网站应该如何设计'}

&gt; Entering new  chain...
Prompt after formatting:
你是一个经验丰富的软件架构师，擅长解答关于软件架构，技术选型的问题。
                        下面是需要你来回答的问题:
                        博客网站应该如何设计

&gt; Finished chain.

&gt; Finished chain.
博客网站的设计应该考虑以下几个方面：

1. 用户体验：博客网站应该易于使用，用户可以轻松地找到他们感兴趣的内容。网站应该具有良好的导航和搜索功能，以便用户可以快速找到他们需要的信息。

2. 响应式设计：博客网站应该能够适应不同的设备和屏幕大小，包括桌面电脑、平板电脑和手机等。这样可以确保用户在任何设备上都能够方便地访问网站。
。。。。（略）
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=http://yangchnet.github.io/Dessert/tags/langchain/>langchain</a></li></ul><nav class=paginav><a class=prev href=http://yangchnet.github.io/Dessert/posts/llm/%E6%8B%A5%E6%8A%B1%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%BA%94memory%E8%AE%A9%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8B%A5%E6%9C%89%E8%AE%B0%E5%BF%86/><span class=title>« Prev Page</span><br><span>拥抱大模型（五）：Memory，让大模型拥有记忆</span></a>
<a class=next href=http://yangchnet.github.io/Dessert/posts/golang/function-as-a-method-receiver/><span class=title>Next Page »</span><br><span>Function as a Method Receiver</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>