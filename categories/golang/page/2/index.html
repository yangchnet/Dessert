<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang | Linote</title><meta name=keywords content><meta name=description content><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/categories/golang/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><link rel=alternate type=application/rss+xml href=http://yangchnet.github.io/categories/golang/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Golang"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://yangchnet.github.io/categories/golang/"><meta property="og:image" content="http://yangchnet.github.io/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/papermod-cover.png"><meta name=twitter:title content="Golang"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/ accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://yangchnet.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/categories/>Categories</a></div><h1>Golang</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>标准库之unsafe</h2></header><section class=entry-content><p>1. Go中对指针的限制 Go 的指针不能进行数学运算。 不同类型的指针不能相互转换。 不同类型的指针不能使用 == 或 != 比较。只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 == 和 != 直接和 nil 作比较。 不同类型的指针变量不能相互赋值。 使用unsafe包，可以一定程度上打破这些限制，那么为什么要打破这些限制。请看下文。
2. unsafe.Pointer unsafe.Pointer的定义
type ArbitraryType int type Pointer *ArbitraryType unsafe 包提供了 2 点重要的能力：
任何类型的指针和 unsafe.Pointer 可以相互转换。 uintptr 类型和 unsafe.Pointer 可以相互转换。 pointer 不能直接进行数学运算，但可以把它转换成 uintptr，对 uintptr 类型进行数学运算，再转换成 pointer 类型。利用这两个对象的相互转换，就可以打破上述4个限制。
// uintptr 是一个整数类型，它足够大，可以存储 type uintptr uintptr 还有一点要注意的是，uintptr 并没有指针的语义，意思就是 uintptr 所指向的对象会被 gc 无情地回收.而 unsafe.Pointer 有指针语义，可以保护它所指向的对象在“有用”的时候不会被垃圾回收。
3. 利用unsafe获取slice和map的长度 slice和map的长度都存储在其内部变量中，因此我们先来看这两个结构体定义：
// runtime/slice.go type slice struct { array unsafe....</p></section><footer class=entry-footer><span title="2022-03-04 00:00:00 +0000 UTC">March 4, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 标准库之unsafe" href=http://yangchnet.github.io/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Bunsafe/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>静态代码检查: golangci-lint</h2></header><section class=entry-content><p>1. 简介 golangci-lint 是对golang进行静态代码检查的工具。其具有以下特性：
速度非常快：golangci-lint 是基于 gometalinter 开发的，但是平均速度要比 gometalinter 快 5 倍。golangci-lint 速度快的原因有三个：可以并行检查代码；可以复用 go build 缓存；会缓存分析结果。 可配置：支持 YAML 格式的配置文件，让检查更灵活，更可控。 IDE 集成：可以集成进多个主流的 IDE，例如 VS Code、GNU Emacs、Sublime Text、Goland 等。 linter 聚合器：1.41.1 版本的 golangci-lint 集成了 76 个 linter，不需要再单独安装这 76 个 linter。并且 golangci-lint 还支持自定义 linter。 最小的误报数：golangci-lint 调整了所集成 linter 的默认设置，大幅度减少了误报。 良好的输出：输出的结果带有颜色、代码行号和 linter 标识，易于查看和定位。 2. 安装 # 安装 go get github.com/golangci/golangci-lint/cmd/golangci-lint@v1.41.1 # 检查是否安装成功 golangci-lint version # 输出 golangci-lint 版本号，说明安装成功 golangci-lint has version v1.44.0 built from (unknown, mod sum: "h1:YJPouGNQEdK+x2KsCpWMIBy0q6MSuxHjkWMxJMNj/DU=") on (unknown) 3....</p></section><footer class=entry-footer><span title="2022-02-09 00:00:00 +0000 UTC">February 9, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 静态代码检查: golangci-lint" href=http://yangchnet.github.io/posts/golang/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5-golangci-lint/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>channel的行为</h2></header><section class=entry-content><p>1. nil channel 接收 接收goroutine阻塞
发送 发送个goroutine阻塞
2. 向无缓冲channel发送消息 接受队列有goroutine 接收端将收到消息
接收队列无goroutine 发送goroutine将阻塞
已有发送goroutine阻塞 发送goroutine将阻塞
3. 从无缓冲channel接收消息 无发送goroutine 接收端阻塞
有发送goroutine 收到消息
4. 向有缓冲channel发送消息 队列未满 正常发送
队列已满 发送端阻塞
5. 从有缓冲channel接收消息 队列中有消息 正常接收
队列中无消息 接收端阻塞
6. 对close channel的操作 向closed channel发送 panic...</p></section><footer class=entry-footer><span title="2022-01-02 00:00:00 +0000 UTC">January 2, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to channel的行为" href=http://yangchnet.github.io/posts/golang/channel%E7%9A%84%E8%A1%8C%E4%B8%BA/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>golang中的tag</h2></header><section class=entry-content><p>1. tag的基本介绍 字段标签可以存储元信息，这些元信息可以使用反射来访问。通常这些元信息用来提供一个字段如何从一种格式编码至另一种格式的相关信息（或是数据应如何在数据库中存储等）。但实际上标签可以存储任何你想要的元信息，无论是你自己使用还是由另一个包使用。
就像reflect.StructTag文档中提到的那样，字段标签通常是由空格分割的key:"value"列表，例如：
type User struct { Name string `json:"name" xml:"name"` } 其中的key通常表示后面"value"所对应的包，例如json这个key将被encoding/json这个包使用。
如果需要在"value"中传递多个值，那么通常使用,逗号来分割，例如：
Name string `json:"name,omitempty" xml:"name"` 值为破折号通常代表在处理时忽略该字段，例如在json中代表不要序列化这个字段
2. 例子：获取自定义tag 我们可以使用反射包来获取结构体字段的值。首先我们需要获取结构体的Type，然后查询字段，可以使用Type.Field(i int)或者Type.FieldByName(name string)。这些方法返回一个代表结构体字段的StructField值和一个代表tag的类型为StructTag的StructField.Tag值。
前面我们提到，字段标签通常是由空格分割的key:"value"列表，如果你的确是这么做的，你可以使用StructTag.Get(key string)这个方法来获取这个key对应的value。如果你不是这么做的，Get()方法可能不能解析key:"value"对并找到你想要的标签。如果你没有遵循字段标签通常是由空格分割的key:"value"列表，那么你可能需要实现自己的解析逻辑。
go1.7中添加了StructTag.Lookup()方法，这个方法的行为类似于Get()，但其将不包含给定键的标签与将空字符串与给定键相关联的标签区分开来。
来看下面这个例子：
type User struct { Name string `mytag:"MyName"` Email stirng `mytag:"MyEmail"` } u := User{"Bob", "bob@cc.com"} t := reflect.TypeOf(u) for _ fieldName := range []string{"Name", "Email"} { field, found := t.FieldByName(fieldName) if !found { continue } fmt.Printf("\nField: User.%s\n", fieldName) fmt.Printf("\tWhole tag value : %q\n", field....</p></section><footer class=entry-footer><span title="2021-09-14 00:00:00 +0000 UTC">September 14, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to golang中的tag" href=http://yangchnet.github.io/posts/golang/golang%E4%B8%AD%E7%9A%84tag/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>ORM之sqlc</h2></header><section class=entry-content><p>1. 安装sqlc go get github.com/kyleconroy/sqlc/cmd/sqlc 2. 基本使用 建立基本项目结构 mkdir sqlc-demo cd sqlc-demo go mod init sqlc-demo 在sqlc-demo中建立如下目录结构：
. ├── db │ ├── queries │ ├── schema │ └── sqlc └── go.mod 其中query中存储查询语句，schema中存储数据库表结构，sqlc中存储生成的代码。
基本表结构 sqlc-demo/db/schema/table.sql
CREATE TABLE "accounts" ( "id" bigserial PRIMARY KEY, "owner" varchar NOT NULL, "balance" bigint NOT NULL, "currency" varchar NOT NULL, "created_at" timestamptz NOT NULL DEFAULT (now()) ); CREATE TABLE "entries" ( "id" bigserial PRIMARY KEY, "account_id" bigint NOT NULL, "amount" bigint NOT NULL, "created_at" timestamptz NOT NULL DEFAULT (now()) ); CREATE TABLE "transfers" ( "id" bigserial PRIMARY KEY, "from_account_id" bigint NOT NULL, "to_account_id" bigint NOT NULL, "amount" bigint NOT NULL, "created_at" timestamptz NOT NULL DEFAULT (now()) ); 配置文件 sqlc-demo/sqlc....</p></section><footer class=entry-footer><span title="2021-08-22 00:00:00 +0000 UTC">August 22, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to ORM之sqlc" href=http://yangchnet.github.io/posts/golang/orm%E4%B9%8Bsqlc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>数据库版本管理-migrate</h2></header><section class=entry-content><p>migrate是一个golang写成的数据库版本迁移工具，可以用来方便的对数据库进行迁移和回退。 Github上有详细的教程等：https://github.com/golang-migrate/migrate
在安装时可能需要指定所用的驱动，否则会因缺少驱动无法连接数据库，例如go install -tags mysql github.com/golang-migrate/migrate/v4/cmd/migrate
建立目录 mkdir -p migrate-demo/db cd migrate-demo/db mkdir ddl mkdir -p schema/blog 现在migrate-demo目录下结构如下：
. └── db ├── ddl └── schema └── blog 其中，ddl中存储建库的sql文件，schema存放建表的sql文件
建库 建库
vim db/ddl/blog.sql CREATE DATABASE IF NOT EXISTS blog DEFAULT CHARACTER SET utf8mb4 DEFAULT COLLATE utf8mb4_unicode_ci; build镜像 编写Dockerfile
vim db/Dockerfile FROMmysql:5.7COPY ./ddl /docker-entrypoint-initdb.d/ENV MYSQL_ROOT_PASSWORD=admin123 复制到/docker-entrypoint-initdb.d目录下的sql脚本会被自动执行
docker build -t mysql-demo -f ./Dockerfile . build成功后，使用docker images命令查看镜像：...</p></section><footer class=entry-footer><span title="2021-08-15 00:00:00 +0000 UTC">August 15, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 数据库版本管理-migrate" href=http://yangchnet.github.io/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86-migrate/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>依赖注入：wire包的使用</h2></header><section class=entry-content><p>官方教程，写的很好，我就不多说了
Let’s learn to use Wire by example. The Wire guide provides thorough documentation of the tool’s usage. For readers eager to see Wire applied to a larger server, the guestbook sample in Go Cloud uses Wire to initialize its components. Here we are going to build a small greeter program to understand how to use Wire. The finished product may be found in the same directory as this README....</p></section><footer class=entry-footer><span title="2021-07-06 00:00:00 +0000 UTC">July 6, 2021</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 依赖注入：wire包的使用" href=http://yangchnet.github.io/posts/golang/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5wire%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>5种goroutine池的实现之对比</h2></header><section class=entry-content><p>1. wazsmwazsm/mortar（★74） 简单介绍
创建一个容量为 N 的池, 在池容量未满时, 每塞入一个任务（生产任务）, 任务池开启一个 worker (建立协程) 去处理任务（消费任务）。 当任务池容量赛满，每塞入一个任务（生产任务）, 任务会被已有的 N 个 worker 抢占执行（消费任务），达到协程限制的功能。但worker创建后不会回收，除非将整个pool撤销。
结构
type Task struct { Handler func(v ...interface{}) // 函数签名 Params []interface{} // 参数 } // Pool task pool type Pool struct { capacity uint64 // 池的容量，自行制定 runningWorkers uint64 // 正在运行的worker status int64 // 池的状态 chTask chan *Task // 任务队列，worker从中获取任务 PanicHandler func(interface{}) // 自定义的PanicHandler，防止因某个goroutine发生panic而导致服务崩溃。 sync.Mutex // 全局锁 } 核心代码...</p></section><footer class=entry-footer><span title="2021-06-19 00:00:00 +0000 UTC">June 19, 2021</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 5种goroutine池的实现之对比" href=http://yangchnet.github.io/posts/golang/5%E7%A7%8Dgoroutine%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AF%B9%E6%AF%94/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>go generate工具</h2></header><section class=entry-content><p>1. go generate go generate命令运行时，将找到源代码中所有包含//go:generate的特殊注释，提取并执行//go:generate后附加的命令。
基本语法：
//go:generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages] 需要注意的几点：
该特殊注释必须在.go源码文件中。 每个源码文件可以包含多个generate特殊注释。 go generate只在运行go generate命令时运行，go build, go get, go test等其他命令不会运行它。 命令串行执行的，如果出错，就终止后面的执行。 特殊注释必须以"//go:generate"开头，双斜线后面没有空格。 简单的例子：
package main import "fmt" //go:generate echo "world" func main() { fmt.Println("hello") } 运行结果：
在go generate命令中，还可以使用一些环境变量：
$GOARCH The execution architecture (arm, amd64, etc.) $GOOS The execution operating system (linux, windows, etc.) $GOFILE The base name of the file....</p></section><footer class=entry-footer><span title="2021-05-27 00:00:00 +0000 UTC">May 27, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to go generate工具" href=http://yangchnet.github.io/posts/golang/go-generate%E5%B7%A5%E5%85%B7/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>golang中context包的使用</h2></header><section class=entry-content><p>context包定义了Context类型，这个类型在API边界即进程中传递截止日期、同步信号，请求值等相关信息。
1. 对context包的介绍 在服务器的传入请求中应包含context，而对服务器的传出调用应接收一个context。它们之间的调用链必须包含context，或是衍生的WithCancel, WithDeadline, WithTimeout, WithValue。当一个WithCancel Context被“cancel”，那么当前context所派生的所有context也都将被取消。
WithCancel, WithDeadline, WithTimeout接收一个Context对象（父对象），并返回其父对象的一个携带有cancel/deadline/timeout的一个拷贝（子对象）。调用CancelFunc会取消其子对象及子对象的子对象等，删除父对象对子对象的引用，并停止所有关联的计时器。未能调用CancelFunc将造成父对象结束前或计时器被触发前子对象的泄露。使用go vet工具可以检查所有控制流路径上是否都使用了CancelFunc
使用context的程序应遵循以下规则，以使各个包之间的接口保持一致，并启用静态分析工具来检查上下文传播：
不要将context存储在结构类型中，而是将context明确传递给需要它的每个函数。Context应该是第一个函数，通常命名为ctx。 func DoSomething(ctx context.Context, arg Arg) error { // ...use ctx... } 不要传递一个值为nil的context，即使一个函数允许这样做。如果你不确定Context的作用那就请传递context.TODO。 只在进程和API间传递请求范围数据时使用context值，不要用于将可选参数传递给函数。 同样的Context可以传递给运行在不同goroutine中的函数，Context是线程安全的。 2. Context接口 type Context interface { Done() &lt;-chan struct{} Err() error Deadline() (deadline time.Time, ok bool) Value(key interface{}) interface{} } Context是一个接口，其定义非常的简单，只包含4个方法：
Done() &lt;-chan struct{} Done()方法将一个channel作为取消信号返回给持有context的函数，当该channel被关闭（即Done()被调用），这些函数应该立即停止其工作并返回。
Err() error Err()返回一个Error，说明为什么取消context。如果Done()没有被调用，那么Err返回nil。
Deadline() (deadline time.Time, ok bool) Deadline()方法返回持有这个context的函数的预期结束时间。如果并没有设置deadline，那么返回的ok将被设置为false。...</p></section><footer class=entry-footer><span title="2021-05-23 00:00:00 +0000 UTC">May 23, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to golang中context包的使用" href=http://yangchnet.github.io/posts/golang/golang%E4%B8%ADcontext%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://yangchnet.github.io/categories/golang/>« Prev Page</a>
<a class=next href=http://yangchnet.github.io/categories/golang/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=http://yangchnet.github.io/>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>