<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux | Linote</title><meta name=keywords content><meta name=description content><meta name=author content="李昌"><link rel=canonical href=http://yangchnet.github.io/Dessert/categories/linux/><link crossorigin=anonymous href=/Dessert/assets/css/stylesheet.min.7e145c6c051b0f6645e8d84c6faed7fed1214bbe82c223c2c19815bee6ee8403.css integrity="sha256-fhRcbAUbD2ZF6NhMb67X/tEhS76CwiPCwZgVvubuhAM=" rel="preload stylesheet" as=style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel=stylesheet><link rel=icon href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://raw.githubusercontent.com/lich-Img/blogImg/master/favicon32.ico><link rel=apple-touch-icon href=http://yangchnet.github.io/Dessert/apple-touch-icon.png><link rel=mask-icon href=http://yangchnet.github.io/Dessert/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><link rel=alternate type=application/rss+xml href=http://yangchnet.github.io/Dessert/categories/linux/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Linux"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://yangchnet.github.io/Dessert/categories/linux/"><meta property="og:image" content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://yangchnet.github.io/Dessert/papermod-cover.png"><meta name=twitter:title content="Linux"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=http://yangchnet.github.io/Dessert accesskey=h title="Linote (Alt + H)">Linote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://yangchnet.github.io/Dessert/archives/ title=存档><span>存档</span></a></li><li><a href=http://yangchnet.github.io/Dessert/categories/ title=分类><span>分类</span></a></li><li><a href=http://yangchnet.github.io/Dessert/search/ title=搜索><span>搜索</span></a></li><li><a href=http://yangchnet.github.io/Dessert/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://yangchnet.github.io/Dessert>Home</a>&nbsp;»&nbsp;<a href=http://yangchnet.github.io/Dessert/categories/>Categories</a></div><h1>Linux</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Linux命令之nc</h2></header><section class=entry-content><p>nc： 任意的TCP/UDP连接和监听
It can open TCP connections, send UDP packets, listen on arbitrary TCP and UDP ports, do port scanning, and deal with both IPv4 and IPv6.
使用case 快速创建client/server对 nc -l 1234 nc 127.0.0.1 1234 任何在client端的输出都将在server端显示
端口扫描 nc -zv 127.0.0.1 8885-8889 其他例子 nc -p 31337 -w 5 abc.com 42 nc -u abc.com 53 nc -s 10.1.2.3 abc.com 42 nc -lU /var/tmp/dsocket</p></section><footer class=entry-footer><span title="2023-11-26 00:00:00 +0000 UTC">November 26, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to Linux命令之nc" href=http://yangchnet.github.io/Dessert/posts/linux/linux%E5%91%BD%E4%BB%A4%E4%B9%8Bnc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>创建Linux新分区，并挂载</h2></header><section class=entry-content><p>要创建一个新的 Linux 文件系统分区并进行挂载，您可以按照以下步骤进行操作：
首先，使用以下命令之一来查看系统中已连接的磁盘和分区： sudo fdisk -l 或者
sudo lsblk 这将显示系统中的磁盘和分区列表。找到您要创建分区的磁盘。
使用以下命令打开磁盘分区工具（例如 fdisk）： sudo fdisk /dev/&lt;disk_name> 将 &lt;disk_name> 替换为您要创建分区的磁盘的名称，例如 /dev/sda。
在磁盘分区工具中，使用以下命令创建新的分区： n 然后按照提示选择分区类型、起始扇区和结束扇区。对于 Linux 文件系统，通常选择默认选项即可。
设置分区的文件系统类型为 Linux。使用以下命令： t 然后选择新创建的分区编号，并选择 Linux 文件系统类型（例如 83）。
保存并退出磁盘分区工具。使用以下命令： w 使用以下命令创建文件系统： sudo mkfs.ext4 /dev/&lt;partition> 将 替换为您刚刚创建的分区设备名称，例如 /dev/sda1。
创建一个目录，用于挂载文件系统。使用以下命令： sudo mkdir /mnt/&lt;mount_point> 将 &lt;mount_point> 替换为您希望挂载文件系统的目录路径。
使用以下命令将文件系统挂载到目标目录： sudo mount /dev/&lt;partition> /mnt/&lt;mount_point> 将 替换为您刚刚创建的分区设备名称，&lt;mount_point> 替换为您在第 7 步中创建的目录路径。
挂载成功后，您可以使用以下命令来验证文件系统是否已挂载： df -h 这将显示已挂载的文件系统列表，包括挂载点和可用空间。...</p></section><footer class=entry-footer><span title="2023-11-26 00:00:00 +0000 UTC">November 26, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 创建Linux新分区，并挂载" href=http://yangchnet.github.io/Dessert/posts/linux/%E5%88%9B%E5%BB%BAlinux%E6%96%B0%E5%88%86%E5%8C%BA%E5%B9%B6%E6%8C%82%E8%BD%BD/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Install Docker on Arch</h2></header><section class=entry-content><p>官方给出的教程是使用docker desktop, 但内存占用太大。
1. 安装docker二进制文件 从这里下载平台对应的二进制文件：https://download.docker.com/linux/static/stable/
然后解压安装：
$ tar xzvf /path/to/&lt;FILE>.tar.gz $ sudo cp docker/* /usr/bin/ 这时可以手动执行sudo dockerd &以启动守护进程，但我们不这样做
配置守护进程 从https://github.com/moby/moby/tree/master/contrib/init/systemd拷贝docker.service, docker.socket两个文件到/etc/systemd/system/docker.service, /etc/systemd/system/docker.socket
然后运行：
$ sudo systemctl daemon-reload # 重新加载配置 $ sudo systemctl start docker #启动dockerd $ sudo systemctl enable docker # 设置开机启动 其实也可以直接yay -S docker :-)
docker-compose $ yay -S docker-compose References https://docs.docker.com/desktop/install/archlinux/
https://docs.docker.com/engine/install/binaries/#install-daemon-and-client-binaries-on-linux
https://docs.docker.com/config/daemon/systemd/
https://wiki.archlinux.org/title/docker
https://wiki.archlinux.org/title/Systemd#Drop-in_files</p></section><footer class=entry-footer><span title="2023-02-21 00:00:00 +0000 UTC">February 21, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to Install Docker on Arch" href=http://yangchnet.github.io/Dessert/posts/linux/install-docker-on-arch/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Manjaro恢复grub</h2></header><section class=entry-content><p>https://wiki.manjaro.org/index.php/GRUB/Restore_the_GRUB_Bootloader#EFI_System
启动笔记本时，突然发现gurb引导项故障了，记录一下修复过程：
首先用U盘制备一个manjaro引导盘。然后有两种方式
timeshift 进入系统BIOS设置U盘启动，然后直接从U盘启动一个manjaro。
如果你有timeshift备份，可以先尝试使用timeshift进行恢复，不行的话，就尝试方法二
grub恢复 进入系统BIOS设置U盘启动，在manjaro提示你选择如何启动系统时，选择Select a bootloader，然后选择grub，不出意外，你的原系统就启动了，但这时如果重启，还是找不到grub引导项。可做如下操作：
首先更新grub
sudo pacman -Syu grub 然后：
grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=manjaro --recheck grub-mkconfig -o /boot/grub/grub.cfg 如果第二个命令提示：/usr/bin/grub-probe：警告： 未知的设备类型 nvme0n1.
那么直接删除/etc/grub.d/60_memtest86+这个文件即可（无风险）
然后重试：
grub-mkconfig -o /boot/grub/grub.cfg 提示完成后，拔掉U盘重启，应该就可以了。</p></section><footer class=entry-footer><span title="2023-02-13 00:00:00 +0000 UTC">February 13, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to Manjaro恢复grub" href=http://yangchnet.github.io/Dessert/posts/linux/manjaro%E6%81%A2%E5%A4%8Dgrub/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>在AUR上发布包</h2></header><section class=entry-content><p>如何在AUR上发布包 1. 准备PKGBUILD 文件 https://wiki.archlinux.org/title/PKGBUILD https://wiki.archlinux.org/title/Creating_packages
想要打包一个可以在AUR上发布的package， 需要使用makepkg工具，makepkg在运行时会寻找当前工作目录下的PKGBUILD文件。
找到之后，会从PKGBUILD配置的source去获取源码并根据PKGBUILD的配置去进行编译，最终产生二进制文件以及一些元信息文件。
如果你使用的是arch系的系统，可以在/usr/share/pacman/目录下找到一些PKGBUILD示例文件。例如：
$ cat /usr/share/pacman/PKGBUILD.proto # This is an example PKGBUILD file. Use this as a start to creating your own, # and remove these comments. For more information, see 'man PKGBUILD'. # NOTE: Please fill out the license field for your package! If it is unknown, # then please put 'unknown'. # Maintainer: Your Name &lt;youremail@domain.com> pkgname=NAME pkgver=VERSION pkgrel=1 epoch= pkgdesc="" arch=() url="" license=('GPL') groups=() depends=() makedepends=() checkdepends=() optdepends=() provides=() conflicts=() replaces=() backup=() options=() install= changelog= source=("$pkgname-$pkgver....</p></section><footer class=entry-footer><span title="2023-02-10 00:00:00 +0000 UTC">February 10, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to 在AUR上发布包" href=http://yangchnet.github.io/Dessert/posts/linux/%E5%9C%A8aur%E4%B8%8A%E5%8F%91%E5%B8%83%E5%8C%85/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>stat系列性能分析工具</h2></header><section class=entry-content><p>1. sysstat简介 sysstat是一个软件包，包含监测系统性能及效率的一组工具，这些工具对于我们收集系统性能数据，比如：CPU 使用率、硬盘和网络吞吐数据，这些数据的收集和分析，有利于我们判断系统是否正常运行，是提高系统运行效率、安全运行服务器的得力助手。
sysstat包含多个工具套件： 首先是stat系列
iostat 输出CPU的统计信息和所有I/O设备的输入输出（I/O）统计信息 mpstat 关于CPU的详细信息（单独输出或者分组输出） pidstat 关于运行中的进程/任务、CPU、内存等的统计信息 sysstat sysstat 工具包的 man 帮助页面。 nfsiostat NFS（Network File System）的I/O统计信息 cifsiostat CIFS(Common Internet File System)的统计信息 还有sa系列 7. sar 保存并输出不同系统资源（CPU、内存、IO、网络、内核等）的详细信息 8. sadc 系统活动数据收集器，用于收集sar工具的后端数据 9. sa1 系统收集并存储sadc数据文件的二进制数据，与sadc工具配合使用 10. sa2 配合sar工具使用，产生每日的摘要报告 11. sadf 用于以不同的数据格式（CVS或者XML）来格式化sar工具的输出
2. 简单使用 iostat iostat: 显示从系统启动至今的io历史数据
iostat -d 2: 每隔两秒显示一个连续的设备报告。
iostat -d 2 6: 为所有设备显示6个报告，每隔两秒显示一个
iostat -x sda sdb 2 6: 为sda和sdb两个设备显示6个报告，每隔2秒显示一个...</p></section><footer class=entry-footer><span title="2022-09-17 00:00:00 +0000 UTC">September 17, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to stat系列性能分析工具" href=http://yangchnet.github.io/Dessert/posts/linux/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-sysstat/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>top命令</h2></header><section class=entry-content><p>在使用top命令查看系统状态时，会出现一堆参数，这些参数分别代表什么意思呢？
第一行 首先打印了当前时间21:11:55，然后是系统已经启动了多久up 4 days, 8:45，我已经4天8小时45分钟没关机了。。
然后当前有3个用户登录3 users，load average是1.47, 1.33, 1.14
load average load average后面有三个值，分别代表过去 1 分钟，5 分钟，15 分钟在这个节点上的 load average.
Load Average 是一种 CPU 资源需求的度量。
举例来说，对于一个单个 CPU 的系统，如果在 1 分钟的时间里，处理器上始终有一个进程在运行，同时操作系统的进程可运行队列中始终都有 9 个进程在等待获取 CPU 资源。那么对于这 1 分钟的时间来说，系统的"load average"就是 1+9=10，这个定义对绝大部分的 Unix 系统都适用。
对于 Linux 来说，如果只考虑 CPU 的资源，Load Averag 等于单位时间内正在运行的进程加上可运行队列的进程，这个定义也是成立的。
对于load average的理解有以下三点：
不论计算机 CPU 是空闲还是满负载，Load Average 都是 Linux 进程调度器中可运行队列（Running Queue）里的一段时间的平均进程数目。
计算机上的 CPU 还有空闲的情况下，CPU Usage 可以直接反映到"load average"上，什么是 CPU 还有空闲呢？具体来说就是可运行队列中的进程数目小于 CPU 个数，这种情况下，单位时间进程 CPU Usage 相加的平均值应该就是"load average"的值。...</p></section><footer class=entry-footer><span title="2022-08-07 00:00:00 +0000 UTC">August 7, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to top命令" href=http://yangchnet.github.io/Dessert/posts/linux/top%E5%91%BD%E4%BB%A4/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>inotify</h2></header><section class=entry-content><p>1. 什么是inotify Inotify API提供了一种监视文件系统的机制事件。 Inotify可用于监视单个文件或监视目录。当监视目录时，Inotify将返回目录本身的事件，以及内部的文件目录。
简单的说，就是inotify可以为你监控文件系统的变化，在发生一些事件时通知你。
2. 实验 需要安装inotify-tools包
# arch系统 yay -S inotify-tools inotify-tools提供了两个命令：inotifywait和inotifywatch
2.1 inotifywait 先来看inotifywait,它被用来"Wait for a particular event on a file or set of files.", 也就是说等待在文件上的某些事件发生。使用inotifywait -h查看其支持的参数：
-h show this help info --exclude &lt;pattern> 排除匹配所给正则的所有事件 --excludei &lt;pattern> 类似前一个命令但非敏感 --include &lt;pattern> 排除除匹配正则之外的所有事件 --includei &lt;pattern> 类似前一个命令但非敏感 -m|--monitor 在timeout之前保持监听，若不设置此标志，inotifywait将在一个事件后退出。 -d|--daemon 类似前一个命令但在后台运行，将日志输出到`--outfile`所指定的文件 -P|--no-dereference 不跟踪符号链接 -r|--recursive 递归的监听、 --fromfile &lt;file> Read files to watch from &lt;file> or `-' for stdin. -o|--outfile &lt;file> 输出到&lt;file>而不是标准输出 -s|--syslog 向syslog发送错误而不是Stderr -q|--quiet 只输出事件 -qq 啥也不输出 --format &lt;fmt> 以特定格式输出 --no-newline 在格式化输出后不打印换行符 --timefmt &lt;fmt> strftime-compatible format string for use with %T in --format string....</p></section><footer class=entry-footer><span title="2022-07-04 00:00:00 +0000 UTC">July 4, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to inotify" href=http://yangchnet.github.io/Dessert/posts/linux/inotify/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>CgroupV2</h2></header><section class=entry-content><p>1. Cgroup概览 cgroup是Linux内核提供的一种按层次组织进程，并对进程资源按层次进行分配和限制的机制。
cgroup 主要由两部分组成——core和controller。core主要负责分层组织进程。 controller负责为属于当前cgroup的进程分配和限制资源.
多个cgroup以树形结构组织，系统中每个进程都属于一个cgroup，一个进程中的所有线程都属于同一个cgroup。
controller可以在cgroup上有选择的开启，开启后的controller将影响这个cgroup内的所有进程。
使用如下命令挂载cgroupv2
mount -t cgroup2 none $MOUNT_POINT # MOUNT_POINT 是任意你想要挂载到的位置 直接在$MOUNT_POINT创建一个文件夹即可创建一个cgroup
mkdir $MOUNT_POINT/$GROUP_NAME 每个cgroup内都有一个cgroup.procs接口文件，其中逐行列出了属于当前cgroup的所有进程的PID。需要注意的是，PID可能重复出现且无序。
若想将某个进程移动到一个cgroup中，只需将其PID写入cgroup.procs文件,进程中的所有线程也会迁移到该cgroup中。fork出的子进程依然属于这个cgroup。
若要删除一个cgroup，需要注意一点：这个cgroup内需要没有任何子进程且仅与僵尸进程相关联，且没有子cgroup.满足了上述条件后，将其作为一个空目录删除即可,使用rm -rf无法对cgroup目录进行删除。
rmdir $MOUNT_POINT/$GROUP_NAME /proc/$PID/cgroup中包含一个进程所属的cgroup。
$ cat /proc/self/cgroup # self表示当前shell进程 0::/user.slice/user-1000.slice/session-2.scope 如果进程成为僵尸进程并且随后删除了与之关联的 cgroup，则将“（已删除）”附加到路径中：
$ cat /proc/842/cgroup 0::/test-cgroup/test-cgroup-nested (deleted) CgroupV2还支持线程模式
每个非根 cgroup 都有一个cgroup.events文件，其中包含populated字段，指示 cgroup 的子层次结构中是否有实时进程。 如果 cgroup 及其后代中没有实时进程，则其值为 0； 否则为1.
例如：考虑如下cgroup结构，括号内数字代表cgroup内进程数：
A(4) - B(0) - C(1) \ D(0) 则A、B 和 C 的populated字段将为 1，而 D 为 0。在 C 中的一个进程退出后，B 和 C 的populated字段将翻转为“0”，文件修改事件将在两个cgroup的cgroup....</p></section><footer class=entry-footer><span title="2022-05-19 00:00:00 +0000 UTC">May 19, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to CgroupV2" href=http://yangchnet.github.io/Dessert/posts/linux/cgroupv2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Linux中的信号</h2></header><section class=entry-content><p>1. Linux 中的信号 信号这个概念在很早期的 Unix 系统上就有。它一般会从 1 开始编号，通常来说，信号编号是 1 到 31，这个编号在所有的 Unix 系统上都是一样的。
取值 名称 解释 默认动作 1 SIGHUP 挂起 2 SIGINT 中断 3 SIGQUIT 退出 4 SIGILL 非法指令 5 SIGTRAP 断点或陷阱指令 6 SIGABRT abort发出的信号 7 SIGBUS 非法内存访问 8 SIGFPE 浮点异常 9 SIGKILL kill信号 不能被忽略、处理和阻塞 10 SIGUSR1 用户信号1 11 SIGSEGV 无效内存访问 12 SIGUSR2 用户信号2 13 SIGPIPE 管道破损，没有读端的管道写数据 14 SIGALRM alarm发出的信号 15 SIGTERM 终止信号 16 SIGSTKFLT 栈溢出 17 SIGCHLD 子进程退出 默认忽略 18 SIGCONT 进程继续 19 SIGSTOP 进程停止 不能被忽略、处理和阻塞 20 SIGTSTP 进程停止 21 SIGTTIN 进程停止，后台进程从终端读数据时 22 SIGTTOU 进程停止，后台进程想终端写数据时 23 SIGURG I/O有紧急数据到达当前进程 默认忽略 24 SIGXCPU 进程的CPU时间片到期 25 SIGXFSZ 文件大小的超出上限 26 SIGVTALRM 虚拟时钟超时 27 SIGPROF profile时钟超时 28 SIGWINCH 窗口大小改变 默认忽略 29 SIGIO I/O相关 30 SIGPWR 关机 默认忽略 31 SIGSYS 系统调用异常 用一句话来概括，信号（Signal）其实就是 Linux 进程收到的一个通知。这些通知产生的源头有很多种，通知的类型也有很多种。比如下面这几个典型的场景：...</p></section><footer class=entry-footer><span title="2022-05-18 00:00:00 +0000 UTC">May 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;李昌</footer><a class=entry-link aria-label="post link to Linux中的信号" href=http://yangchnet.github.io/Dessert/posts/linux/linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://yangchnet.github.io/Dessert/categories/linux/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=http://yangchnet.github.io/Dessert>Linote</a></span>
<script src=https://utteranc.es/client.js repo=yangchnet/Dessert issue-term=pathname theme=github-light crossorigin=anonymous async></script><span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>