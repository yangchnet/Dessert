<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>kubernetes on Linote</title>
    <link>http://yangchnet.github.io/Dessert/tags/kubernetes/</link>
    <description>Recent content in kubernetes on Linote</description>
    <image>
      <url>http://yangchnet.github.io/Dessert/papermod-cover.png</url>
      <link>http://yangchnet.github.io/Dessert/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 05 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://yangchnet.github.io/Dessert/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubernetes之存储</title>
      <link>http://yangchnet.github.io/Dessert/posts/kubernetes/kubernetes%E4%B9%8B%E5%AD%98%E5%82%A8/</link>
      <pubDate>Wed, 05 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>http://yangchnet.github.io/Dessert/posts/kubernetes/kubernetes%E4%B9%8B%E5%AD%98%E5%82%A8/</guid>
      <description>PV与PVC PV （Persistent Volume）描述的，是持久化存储数据卷。这个 API 对象主要定义的是一个持久化存储在宿主机上的目录，比如一个 NFS 的挂载目录。
而 PVC （Persistent Volume Claim）描述的，则是 Pod 所希望使用的持久化存储的属性。比如，Volume 存储的大小、可读写权限等等。
PVC是和PV配合使用的。在普通开发人员需要使用存储时，他不知道K8s中到底有那些存储空间可以使用，也不需要知道。他所需要做的，仅仅：1. 定义一个 PVC，声明想要的 Volume 的属性：2. 在应用的Pod中，声明使用这个PVC。
PV与PVC的关系类似于接口与接口的实现，开发人员只需使用接口即可，而不用关心接口的具体实现，而接口的实现（即存储对象的具体定义）由运维人员完成。这种解耦，就避免了因为向开发者暴露过多的存储系统细节而带来的隐患。此外，这种职责的分离，往往也意味着出现事故时可以更容易定位问题和明确责任，从而避免“扯皮”现象的出现。
用户创建的 PVC 要真正被容器使用起来，就必须先和某个符合条件的 PV 进行绑定。这里要检查的条件，包括两部分：
  第一个条件，当然是 PV 和 PVC 的 spec 字段。比如，PV 的存储（storage）大小，就必须满足 PVC 的要求。
  而第二个条件，则是 PV 和 PVC 的 storageClassName 字段必须一样。
  PV与PVC是如何绑定的 在 Kubernetes 中，存在一个专门处理持久化存储的控制器，叫作 Volume Controller。这个 Volume Controller 维护着多个控制循环，其中有一个循环，扮演的就是撮合 PV 和 PVC 的“红娘”的角色。它的名字叫作 PersistentVolumeController。
PersistentVolumeController 会不断地查看当前每一个 PVC，是不是已经处于 Bound（已绑定）状态。如果不是，那它就会遍历所有的、可用的 PV，并尝试将其与这个“单身”的 PVC 进行绑定。这样，Kubernetes 就可以保证用户提交的每一个 PVC，只要有合适的 PV 出现，它就能够很快进入绑定状态，从而结束“单身”之旅。</description>
    </item>
    
    <item>
      <title>vagrant&#43;ansible安装k8s集群</title>
      <link>http://yangchnet.github.io/Dessert/posts/cloud/vagrant&#43;ansible%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>http://yangchnet.github.io/Dessert/posts/cloud/vagrant&#43;ansible%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4/</guid>
      <description>已过时，不可用
 部署环境： ubuntu20.04， 8G+4核 kubernete版本： 1.22.1
 1. 安装vagrant和ansible 按官网教程即可
2. Vagrantfile 建立如下目录
k8s-cluster ├── kubernetes-setup │ ├── master-playbook.yml │ └── node-playbook.yml └── Vagrantfile 其中，Vagrantfile内容如下：
IMAGE_NAME = &amp;quot;bento/ubuntu-16.04&amp;quot; N = 2 Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.ssh.insert_key = false config.vm.provider &amp;quot;virtualbox&amp;quot; do |v| v.memory = 2048 v.cpus = 2 end config.vm.define &amp;quot;k8s-master&amp;quot; do |master| master.vm.box = IMAGE_NAME master.vm.network &amp;quot;private_network&amp;quot;, ip: &amp;quot;192.168.50.10&amp;quot; master.vm.hostname = &amp;quot;k8s-master&amp;quot; master.vm.provision &amp;quot;ansible&amp;quot; do |ansible| ansible.playbook = &amp;quot;kubernetes-setup/master-playbook.yml&amp;quot; ansible.</description>
    </item>
    
    <item>
      <title>使用kubeadm安装单节点Kubernetes</title>
      <link>http://yangchnet.github.io/Dessert/posts/env/%E4%BD%BF%E7%94%A8kubeadm%E5%AE%89%E8%A3%85%E5%8D%95%E8%8A%82%E7%82%B9kubernetes/</link>
      <pubDate>Sat, 04 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>http://yangchnet.github.io/Dessert/posts/env/%E4%BD%BF%E7%94%A8kubeadm%E5%AE%89%E8%A3%85%E5%8D%95%E8%8A%82%E7%82%B9kubernetes/</guid>
      <description>环境：ubuntu-20.04, kubernetes:v1.22.1
 1. 安装docker  安装时有可能会遇到网络问题，你可以选择换源或是为apt设置代理，设置代理的方法见这里
  更新源镜像并安装依赖  sudo apt-get update sudo apt-get install \  apt-transport-https \  ca-certificates \  curl \  gnupg \  lsb-release 安装docker 官方GPG密钥  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 设置稳定版本  echo \  &amp;#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs)stable&amp;#34; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null 安装docker  sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.</description>
    </item>
    
    <item>
      <title>k8s中的apiVersion</title>
      <link>http://yangchnet.github.io/Dessert/posts/cloud/k8s%E4%B8%AD%E7%9A%84apiversion/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>http://yangchnet.github.io/Dessert/posts/cloud/k8s%E4%B8%AD%E7%9A%84apiversion/</guid>
      <description>apiVersion可能的字段值：    Kind apiVersion     CertificateSigningRequest certificates.k8s.io/v1beta1   ClusterRoleBinding rbac.authorization.k8s.io/v1   ClusterRole rbac.authorization.k8s.io/v1   ComponentStatus v1   ConfigMap v1   ControllerRevision apps/v1   CronJob batch/v1beta1   DaemonSet extensions/v1beta1   Deployment extensions/v1beta1   Endpoints v1   Event v1   HorizontalPodAutoscaler autoscaling/v1   Ingress extensions/v1beta1   Job batch/v1   LimitRange v1   Namespace v1   NetworkPolicy extensions/v1beta1   Node v1   PersistentVolumeClaim v1   PersistentVolume v1   PodDisruptionBudget policy/v1beta1   Pod v1   PodSecurityPolicy extensions/v1beta1   PodTemplate v1   ReplicaSet extensions/v1beta1   ReplicationController v1   ResourceQuota v1   RoleBinding rbac.</description>
    </item>
    
  </channel>
</rss>
